# 소스 생성기 개발 절차

## 학습 목표

- 소스 생성기 프로젝트 설정 방법 이해
- 표준 개발 워크플로우 습득
- 테스트 및 디버깅 전략 수립

---

## 개발 절차 개요

소스 생성기 개발은 다음 7단계로 진행됩니다:

```
┌─────────────────────────────────────────────────────────────┐
│                    소스 생성기 개발 절차                      │
├─────────────────────────────────────────────────────────────┤
│  1. 프로젝트 설정                                            │
│     └── csproj, 패키지 참조                                  │
│                                                             │
│  2. 마커 속성(Attribute) 정의                                │
│     └── [EntityId], [ValueConverter] 등                     │
│                                                             │
│  3. 심볼 분석 전략 수립                                       │
│     └── 어떤 정보를 추출할 것인가?                            │
│                                                             │
│  4. 메타데이터 클래스 설계                                    │
│     └── 추출한 정보를 담을 데이터 구조                         │
│                                                             │
│  5. 코드 생성 템플릿 설계                                     │
│     └── 생성할 코드의 구조                                    │
│                                                             │
│  6. 단위 테스트 작성                                          │
│     └── Verify 스냅샷 테스트                                  │
│                                                             │
│  7. 패키징 및 배포                                            │
│     └── dotnet pack -c Release                              │
└─────────────────────────────────────────────────────────────┘
```

---

## 1. 프로젝트 설정

### csproj 기본 구성

```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>netstandard2.0</TargetFramework>
    <LangVersion>latest</LangVersion>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>

    <!-- 소스 생성기 필수 설정 -->
    <EnforceExtendedAnalyzerRules>true</EnforceExtendedAnalyzerRules>
    <IsRoslynComponent>true</IsRoslynComponent>

    <!-- 패키지 정보 -->
    <PackageId>MyCompany.SourceGenerator</PackageId>
    <Version>1.0.0</Version>
    <Authors>Your Name</Authors>
    <Description>Source generator for ...</Description>
  </PropertyGroup>

  <ItemGroup>
    <!-- Roslyn API -->
    <PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="4.8.0" PrivateAssets="all" />
    <PackageReference Include="Microsoft.CodeAnalysis.Analyzers" Version="3.3.4" PrivateAssets="all" />
  </ItemGroup>

  <ItemGroup>
    <!-- 소스 생성기로 패키징 -->
    <None Include="$(OutputPath)\$(AssemblyName).dll" Pack="true" PackagePath="analyzers/dotnet/cs" Visible="false" />
  </ItemGroup>

</Project>
```

### 핵심 설정 설명

| 설정 | 설명 |
|------|------|
| `TargetFramework` | `netstandard2.0` - 최대 호환성 |
| `EnforceExtendedAnalyzerRules` | 분석기/생성기 규칙 강제 |
| `IsRoslynComponent` | Roslyn 컴포넌트임을 명시 |
| `PrivateAssets="all"` | 의존성이 소비자에게 전파되지 않음 |

---

## 2. 마커 속성 정의

### Post-Initialization으로 속성 생성

```csharp
[Generator(LanguageNames.CSharp)]
public class EntityIdGenerator : IIncrementalGenerator
{
    // 속성 정의 (소스 코드)
    private const string EntityIdAttribute = """
        // <auto-generated/>
        #nullable enable

        namespace MyCompany.SourceGenerator;

        /// <summary>
        /// Entity Id로 생성할 타입에 적용합니다.
        /// </summary>
        [global::System.AttributeUsage(
            global::System.AttributeTargets.Struct,
            AllowMultiple = false,
            Inherited = false)]
        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(
            Justification = "Generated by source generator.")]
        public sealed class EntityIdAttribute : global::System.Attribute;
        """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1단계: 속성 생성 (컴파일 초기에 한 번)
        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddSource(
                hintName: "EntityIdAttribute.g.cs",
                sourceText: SourceText.From(EntityIdAttribute, Encoding.UTF8)));

        // 2단계: 속성이 붙은 타입 처리
        // ...
    }
}
```

### 왜 Post-Initialization인가?

```
컴파일 시작
    │
    ▼
┌──────────────────────────────────────┐
│ RegisterPostInitializationOutput     │  ← 1단계: 속성 정의 생성
│ - EntityIdAttribute.g.cs 생성        │
└──────────────────────────────────────┘
    │
    ▼
┌──────────────────────────────────────┐
│ 사용자 코드 파싱                      │  ← 사용자가 [EntityId] 사용 가능
│ - [EntityId] 속성 인식                │
└──────────────────────────────────────┘
    │
    ▼
┌──────────────────────────────────────┐
│ ForAttributeWithMetadataName         │  ← 2단계: 속성 대상 코드 생성
│ - EntityId 타입 생성                  │
└──────────────────────────────────────┘
    │
    ▼
컴파일 완료
```

---

## 3. 심볼 분석 전략

### 분석할 정보 결정

```csharp
// 예: Entity Id 생성기에서 필요한 정보
// 입력:
[EntityId]
public readonly partial record struct ProductId;

// 추출할 정보:
// - 타입 이름: ProductId
// - 네임스페이스: MyApp.Domain
// - 한정자: readonly partial record struct
// - 기존 인터페이스: 없음
```

### ForAttributeWithMetadataName 사용

```csharp
public void Initialize(IncrementalGeneratorInitializationContext context)
{
    // Post-initialization...

    var provider = context.SyntaxProvider
        .ForAttributeWithMetadataName(
            fullyQualifiedMetadataName: "MyCompany.SourceGenerator.EntityIdAttribute",
            predicate: static (node, _) => node is StructDeclarationSyntax,
            transform: static (ctx, _) => MapToEntityIdInfo(ctx))
        .Where(static x => x is not null);

    context.RegisterSourceOutput(provider, Execute);
}

private static EntityIdInfo? MapToEntityIdInfo(
    GeneratorAttributeSyntaxContext context)
{
    if (context.TargetSymbol is not INamedTypeSymbol typeSymbol)
        return null;

    return new EntityIdInfo(
        TypeName: typeSymbol.Name,
        Namespace: typeSymbol.ContainingNamespace.ToDisplayString(),
        IsReadOnly: typeSymbol.IsReadOnly);
}
```

---

## 4. 메타데이터 클래스 설계

### record로 불변 데이터 구조 정의

```csharp
// 추출한 정보를 담는 데이터 클래스
public sealed record EntityIdInfo(
    string TypeName,
    string Namespace,
    bool IsReadOnly);

// 복잡한 경우 중첩 record 사용
public sealed record ValidationInfo(
    string TypeName,
    string Namespace,
    IReadOnlyList<PropertyValidation> Properties);

public sealed record PropertyValidation(
    string PropertyName,
    string PropertyType,
    IReadOnlyList<ValidationRule> Rules);

public sealed record ValidationRule(
    string RuleName,
    IReadOnlyDictionary<string, object?> Arguments);
```

### 왜 record인가?

```csharp
// ✅ record 장점
// 1. 불변성 - 증분 캐싱에 필수
// 2. 값 동등성 - Equals/GetHashCode 자동 생성
// 3. 간결함 - 적은 코드

public sealed record EntityIdInfo(string TypeName, string Namespace);

// ❌ class로 구현 시 (장황함)
public sealed class EntityIdInfo : IEquatable<EntityIdInfo>
{
    public string TypeName { get; }
    public string Namespace { get; }

    public EntityIdInfo(string typeName, string @namespace)
    {
        TypeName = typeName;
        Namespace = @namespace;
    }

    public bool Equals(EntityIdInfo? other) { /* ... */ }
    public override bool Equals(object? obj) { /* ... */ }
    public override int GetHashCode() { /* ... */ }
}
```

---

## 5. 코드 생성 템플릿 설계

### 생성할 코드 구조 결정

```csharp
// 목표: 이런 코드가 생성되어야 함
[DebuggerDisplay("{ToString()}")]
public readonly partial record struct ProductId : IEntityId<ProductId>, IComparable<ProductId>
{
    public Ulid Value { get; }

    private ProductId(Ulid value) => Value = value;

    public static ProductId New() => new(Ulid.NewUlid());
    public static ProductId Create(Ulid value) => new(value);
    public static ProductId Empty => new(Ulid.Empty);

    public int CompareTo(ProductId other) => Value.CompareTo(other.Value);

    public static bool operator >(ProductId left, ProductId right)
        => left.CompareTo(right) > 0;
    // ...

    public override string ToString() => Value.ToString();
}
```

### StringBuilder로 생성

```csharp
private static string GenerateEntityIdSource(EntityIdInfo info)
{
    var sb = new StringBuilder();

    sb.AppendLine("// <auto-generated/>");
    sb.AppendLine("#nullable enable");
    sb.AppendLine();
    sb.AppendLine("using System;");
    sb.AppendLine("using System.Diagnostics;");
    sb.AppendLine();
    sb.AppendLine($"namespace {info.Namespace};");
    sb.AppendLine();
    sb.AppendLine($"[DebuggerDisplay(\"{{ToString()}}\")]");
    sb.AppendLine($"public readonly partial record struct {info.TypeName} : IEntityId<{info.TypeName}>, IComparable<{info.TypeName}>");
    sb.AppendLine("{");
    sb.AppendLine("    public Ulid Value { get; }");
    sb.AppendLine();
    sb.AppendLine($"    private {info.TypeName}(Ulid value) => Value = value;");
    sb.AppendLine();
    sb.AppendLine($"    public static {info.TypeName} New() => new(Ulid.NewUlid());");
    sb.AppendLine($"    public static {info.TypeName} Create(Ulid value) => new(value);");
    sb.AppendLine($"    public static {info.TypeName} Empty => new(Ulid.Empty);");
    // ...
    sb.AppendLine("}");

    return sb.ToString();
}
```

---

## 6. 단위 테스트 작성

### 테스트 프로젝트 설정

```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="4.8.0" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.11.0" />
    <PackageReference Include="xunit" Version="2.9.0" />
    <PackageReference Include="Verify.Xunit" Version="26.6.0" />
    <PackageReference Include="Shouldly" Version="4.2.1" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\MyCompany.SourceGenerator\MyCompany.SourceGenerator.csproj" />
  </ItemGroup>

</Project>
```

### Verify 스냅샷 테스트

```csharp
public sealed class EntityIdGeneratorTests
{
    private readonly EntityIdGenerator _sut = new();

    [Fact]
    public Task EntityIdGenerator_ShouldGenerate_BasicEntityId()
    {
        // Arrange
        string input = """
            using MyCompany.SourceGenerator;

            namespace TestNamespace;

            [EntityId]
            public readonly partial record struct ProductId;
            """;

        // Act
        string? actual = _sut.Generate(input);

        // Assert
        return Verify(actual);
    }
}
```

### 테스트 러너 구현

```csharp
public static class SourceGeneratorTestRunner
{
    private static readonly Type[] RequiredTypes = [
        typeof(object),  // System.Runtime
    ];

    public static string? Generate<TGenerator>(
        this TGenerator generator,
        string sourceCode)
        where TGenerator : IIncrementalGenerator, new()
    {
        // 1. 구문 트리 생성
        var syntaxTree = CSharpSyntaxTree.ParseText(sourceCode);

        // 2. 참조 어셈블리 수집
        var references = RequiredTypes
            .Select(t => t.Assembly.Location)
            .Distinct()
            .Select(loc => MetadataReference.CreateFromFile(loc))
            .ToList();

        // 3. 컴파일레이션 생성
        var compilation = CSharpCompilation.Create(
            assemblyName: "TestAssembly",
            syntaxTrees: [syntaxTree],
            references: references,
            options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

        // 4. 생성기 실행
        var driver = CSharpGeneratorDriver.Create(generator);
        driver = (CSharpGeneratorDriver)driver.RunGeneratorsAndUpdateCompilation(
            compilation,
            out var outputCompilation,
            out var diagnostics);

        // 5. 진단 검증
        var errors = outputCompilation.GetDiagnostics()
            .Where(d => d.Severity == DiagnosticSeverity.Error)
            .ToList();

        errors.ShouldBeEmpty();

        // 6. 생성된 코드 반환
        var result = driver.GetRunResult();
        return result.GeneratedTrees
            .Select(t => t.GetText().ToString())
            .LastOrDefault();  // 마지막 생성 파일 (속성 제외)
    }
}
```

---

## 7. 패키징 및 배포

### NuGet 패키지 생성

```bash
# Release 구성으로 빌드 (중요!)
dotnet pack -c Release -o ./packages

# 로컬 피드에 추가
dotnet nuget push ./packages/MyCompany.SourceGenerator.1.0.0.nupkg \
    --source ./local-feed
```

### 소비자 프로젝트에서 사용

```xml
<ItemGroup>
  <!-- 분석기/생성기로 참조 -->
  <PackageReference Include="MyCompany.SourceGenerator" Version="1.0.0"
                    OutputItemType="Analyzer"
                    ReferenceOutputAssembly="false" />
</ItemGroup>
```

---

## 개발 체크리스트

```markdown
## 소스 생성기 개발 체크리스트

### 프로젝트 설정
- [ ] TargetFramework: netstandard2.0
- [ ] EnforceExtendedAnalyzerRules: true
- [ ] IsRoslynComponent: true
- [ ] Microsoft.CodeAnalysis.CSharp 참조

### 구현
- [ ] IIncrementalGenerator 구현
- [ ] [Generator] 속성 적용
- [ ] 마커 속성 Post-Initialization으로 생성
- [ ] ForAttributeWithMetadataName으로 대상 필터링
- [ ] 메타데이터 record 클래스 정의
- [ ] 코드 생성 템플릿 작성

### 테스트
- [ ] Verify 스냅샷 테스트 작성
- [ ] 경계 케이스 테스트 추가
- [ ] 에러 케이스 테스트 추가

### 품질
- [ ] 생성 코드에 // <auto-generated/> 헤더
- [ ] #nullable enable 포함
- [ ] ExcludeFromCodeCoverage 속성
- [ ] 결정적 출력 (동일 입력 → 동일 출력)

### 배포
- [ ] dotnet pack -c Release
- [ ] 버전 번호 업데이트
- [ ] CHANGELOG 작성
```

---

## 요약

| 단계 | 핵심 작업 |
|------|----------|
| 1. 프로젝트 설정 | netstandard2.0, Roslyn 패키지 참조 |
| 2. 속성 정의 | Post-Initialization으로 마커 속성 생성 |
| 3. 심볼 분석 | ForAttributeWithMetadataName으로 대상 필터링 |
| 4. 메타데이터 | record로 불변 데이터 구조 정의 |
| 5. 코드 생성 | StringBuilder + Raw String Literals |
| 6. 테스트 | Verify 스냅샷 테스트 |
| 7. 배포 | dotnet pack -c Release |

---

## 다음 단계

다음 섹션에서는 DDD Entity Id 생성기를 실제로 구현합니다.

➡️ [02. Entity Id 생성기](02-entity-id-generator.md)
