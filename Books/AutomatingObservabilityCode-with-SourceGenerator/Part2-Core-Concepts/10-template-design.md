# 템플릿 설계

## 학습 목표

- 코드 생성 템플릿 구조화
- 고정 부분과 동적 부분 분리
- 관찰 가능성 파이프라인 템플릿 이해

---

## 템플릿 설계 원칙

### 1. 고정 부분과 동적 부분 분리

```
생성되는 코드 구조
=================

[고정] 헤더 (auto-generated 주석)
[고정] using 문
[동적] 네임스페이스
[동적] 클래스 선언
[고정] 필드 패턴 (타입만 동적)
[고정] 생성자 패턴 (파라미터만 동적)
[동적] 메서드들 (시그니처와 호출만 동적)
[고정] 로깅 메서드 패턴
```

### 2. 계층적 생성

```
GeneratePipelineClassSource()
    ├── Header (상수)
    ├── Using 문 (상수)
    ├── Namespace (동적)
    ├── Class 선언 (동적)
    │   ├── GenerateFields()
    │   ├── GenerateConstructor()
    │   ├── GenerateHelperMethods()
    │   └── GenerateMethod() (각 메서드)
    │       ├── 시그니처 생성
    │       ├── 로깅 호출 생성
    │       └── 실제 호출 생성
    └── GenerateLoggingMethods()
```

---

## 헤더 템플릿

### Constants.cs

```csharp
namespace Functorium.Adapters.SourceGenerator.Abstractions;

public static class Constants
{
    /// <summary>
    /// 생성된 코드의 공통 헤더
    /// </summary>
    public const string Header = """
        // <auto-generated/>
        // This code was generated by AdapterPipelineGenerator.
        // Do not modify this file directly.
        // Any changes will be overwritten when the code is regenerated.

        #nullable enable
        """;
}
```

### 헤더의 역할

```
헤더 구성 요소
=============

1. // <auto-generated/>
   - IDE가 생성된 코드임을 인식
   - 일부 분석기 경고 비활성화

2. 생성기 정보
   - 어떤 도구로 생성되었는지 표시
   - 문제 발생 시 추적 용이

3. 수정 금지 경고
   - 개발자가 직접 수정하지 않도록 안내

4. #nullable enable
   - Nullable 참조 타입 활성화
   - 생성된 코드의 일관성 보장
```

---

## 클래스 템플릿

### 기본 구조

```csharp
private static string GeneratePipelineClassSource(
    PipelineClassInfo classInfo,
    StringBuilder sb)
{
    // 1. 헤더
    sb.Append(Header)
      .AppendLine();

    // 2. Using 문
    sb.AppendLine("using Functorium.Abstractions;")
      .AppendLine("using Functorium.Applications.Observabilities;")
      .AppendLine()
      .AppendLine("using LanguageExt;")
      .AppendLine("using Microsoft.Extensions.Logging;")
      .AppendLine("using System.Diagnostics;")
      .AppendLine()
      .AppendLine("using ObservabilityFields = Functorium.Adapters.Observabilities.ObservabilityFields;")
      .AppendLine();

    // 3. 네임스페이스 (동적)
    sb.AppendLine($"namespace {classInfo.Namespace};")
      .AppendLine();

    // 4. 클래스 선언 (동적)
    sb.AppendLine($"public class {classInfo.ClassName}Pipeline : {classInfo.ClassName}")
      .AppendLine("{");

    // 5. 필드
    GenerateFields(sb, classInfo);

    // 6. 생성자
    GenerateConstructor(sb, classInfo);

    // 7. 헬퍼 메서드
    GenerateHelperMethods(sb, classInfo);

    // 8. 각 메서드
    foreach (var method in classInfo.Methods)
    {
        GenerateMethod(sb, classInfo, method);
    }

    // 9. 클래스 닫기
    sb.AppendLine("}");

    // 10. 로깅 확장 클래스
    GenerateLoggingExtensions(sb, classInfo);

    return sb.ToString();
}
```

---

## 필드 템플릿

```csharp
private static void GenerateFields(StringBuilder sb, PipelineClassInfo classInfo)
{
    // 관찰 가능성 필드
    sb.AppendLine("    private readonly ActivityContext _parentContext;")
      .AppendLine()
      .AppendLine($"    private readonly ILogger<{classInfo.ClassName}Pipeline> _logger;")
      .AppendLine("    private readonly IAdapterTrace _adapterTrace;")
      .AppendLine("    private readonly IAdapterMetric _adapterMetric;")
      .AppendLine();

    // 상수
    sb.AppendLine($"    private const string RequestHandler = nameof({classInfo.ClassName});")
      .AppendLine();

    // 로깅 레벨 캐시 (성능 최적화)
    sb.AppendLine("    private readonly bool _isDebugEnabled;")
      .AppendLine("    private readonly bool _isInformationEnabled;")
      .AppendLine("    private readonly bool _isWarningEnabled;")
      .AppendLine("    private readonly bool _isErrorEnabled;")
      .AppendLine();
}
```

---

## 생성자 템플릿

```csharp
private static void GenerateConstructor(StringBuilder sb, PipelineClassInfo classInfo)
{
    // 생성자 시작
    sb.Append($"    public {classInfo.ClassName}Pipeline(")
      .AppendLine()
      .AppendLine("        ActivityContext parentContext,")
      .AppendLine($"        ILogger<{classInfo.ClassName}Pipeline> logger,")
      .AppendLine("        IAdapterTrace adapterTrace,")
      .Append("        IAdapterMetric adapterMetric");

    // 부모 클래스 파라미터 (동적)
    string baseParams = GenerateBaseConstructorParameters(
        classInfo.BaseConstructorParameters);
    if (!string.IsNullOrEmpty(baseParams))
    {
        sb.Append(baseParams);
    }

    sb.Append(")");

    // 부모 생성자 호출 (동적)
    string baseCall = GenerateBaseConstructorCall(
        classInfo.BaseConstructorParameters);
    if (!string.IsNullOrEmpty(baseCall))
    {
        sb.AppendLine()
          .Append(baseCall);
    }

    // 생성자 본문
    sb.AppendLine()
      .AppendLine("    {")
      .AppendLine("        global::System.ArgumentNullException.ThrowIfNull(adapterTrace);")
      .AppendLine("        global::System.ArgumentNullException.ThrowIfNull(adapterMetric);")
      .AppendLine()
      .AppendLine("        _parentContext = parentContext;")
      .AppendLine("        _logger = logger;")
      .AppendLine("        _adapterTrace = adapterTrace;")
      .AppendLine("        _adapterMetric = adapterMetric;")
      .AppendLine()
      .AppendLine("        _isDebugEnabled = logger.IsEnabled(LogLevel.Debug);")
      .AppendLine("        _isInformationEnabled = logger.IsEnabled(LogLevel.Information);")
      .AppendLine("        _isWarningEnabled = logger.IsEnabled(LogLevel.Warning);")
      .AppendLine("        _isErrorEnabled = logger.IsEnabled(LogLevel.Error);")
      .AppendLine("    }")
      .AppendLine();
}
```

---

## 메서드 템플릿

### 구조

```csharp
private static void GenerateMethod(
    StringBuilder sb,
    PipelineClassInfo classInfo,
    MethodInfo method)
{
    // 1. 메서드 시그니처
    string parameters = GenerateParameterList(method.Parameters);
    sb.AppendLine($"    public new {method.ReturnType} {method.Name}({parameters})")
      .AppendLine("    {");

    // 2. 시작 시간 기록
    sb.AppendLine("        long startTimestamp = global::System.Diagnostics.Stopwatch.GetTimestamp();")
      .AppendLine();

    // 3. ExecuteWithActivity 호출
    sb.AppendLine("        return ExecuteWithActivity(")
      .AppendLine("            RequestHandler,")
      .AppendLine($"            nameof({method.Name}),");

    // 4. 실제 메서드 호출 (동적)
    string arguments = GenerateArgumentList(method.Parameters);
    sb.AppendLine($"            FinTToIO(base.{method.Name}({arguments})),");

    // 5. 로깅 람다 (동적)
    GenerateLoggingLambda(sb, method);

    sb.AppendLine("            startTimestamp);")
      .AppendLine("    }")
      .AppendLine();
}
```

### 생성 결과 예시

```csharp
// 생성된 메서드
public new FinT<IO, User> GetUserAsync(int userId)
{
    long startTimestamp = global::System.Diagnostics.Stopwatch.GetTimestamp();

    return ExecuteWithActivity(
        RequestHandler,
        nameof(GetUserAsync),
        FinTToIO(base.GetUserAsync(userId)),
        () => LogGetUserAsyncRequest(userId),
        LogGetUserAsyncResponseSuccess,
        LogGetUserAsyncResponseFailure,
        startTimestamp);
}
```

---

## 로깅 메서드 템플릿

### LoggerMessage.Define 패턴

```csharp
private static void GenerateLoggingMethods(
    StringBuilder sb,
    PipelineClassInfo classInfo,
    MethodInfo method)
{
    int paramCount = method.Parameters.Count;

    // 기본 파라미터 4개 + 메서드 파라미터
    // LoggerMessage.Define은 최대 6개 파라미터만 지원

    if (paramCount <= 2)
    {
        // 고성능 로깅 (LoggerMessage.Define 사용)
        GenerateHighPerformanceLogging(sb, classInfo, method);
    }
    else
    {
        // 폴백 로깅 (일반 로깅 사용)
        GenerateFallbackLogging(sb, classInfo, method);
    }
}
```

### 생성 결과 예시

```csharp
internal static class UserRepositoryPipelineLoggers
{
    // 요청 로깅 (고성능)
    private static readonly Action<ILogger, int, Exception?> s_getUserAsyncRequest =
        LoggerMessage.Define<int>(
            LogLevel.Information,
            new EventId(1001, "AdapterRequest"),
            "[Adapter] Request: UserRepository.GetUserAsync(userId={userId})");

    public static void GetUserAsyncRequest(ILogger logger, int userId)
    {
        if (logger.IsEnabled(LogLevel.Information))
        {
            s_getUserAsyncRequest(logger, userId, null);
        }
    }

    // 응답 로깅 (고성능)
    private static readonly Action<ILogger, string, string, double, Exception?> s_getUserAsyncResponseSuccess =
        LoggerMessage.Define<string, string, double>(
            LogLevel.Information,
            new EventId(1002, "AdapterResponse"),
            "[Adapter] Response: {RequestHandler}.{Method} completed in {ElapsedMs}ms");

    public static void GetUserAsyncResponseSuccess(
        ILogger logger,
        string requestHandler,
        string method,
        double elapsedMs)
    {
        if (logger.IsEnabled(LogLevel.Information))
        {
            s_getUserAsyncResponseSuccess(logger, requestHandler, method, elapsedMs, null);
        }
    }
}
```

---

## 요약

| 템플릿 부분 | 고정/동적 | 설명 |
|-------------|-----------|------|
| 헤더 | 고정 | auto-generated 주석 |
| Using 문 | 고정 | 필요한 네임스페이스 |
| 네임스페이스 | 동적 | 원본 클래스와 동일 |
| 클래스 선언 | 동적 | 원본 + Pipeline 접미사 |
| 필드 | 패턴 | 타입만 동적 |
| 생성자 | 패턴 | 파라미터만 동적 |
| 메서드 | 패턴 | 시그니처, 호출만 동적 |
| 로깅 | 패턴 | 파라미터 수에 따라 분기 |

---

## 다음 단계

다음 섹션에서는 네임스페이스 처리를 학습합니다.

➡️ [03. 네임스페이스 처리](03-namespace-handling.md)
