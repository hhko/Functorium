# EF Core 값 변환기 생성기

## 학습 목표

- EF Core ValueConverter의 역할 이해
- Value Object와 Entity Id를 DB에 저장하는 방법 습득
- 생성자 파라미터 분석을 통한 변환 로직 자동 생성

---

## EF Core ValueConverter란?

### 문제: Value Object를 DB에 저장하기

```csharp
// Domain Model
public record Email(string Value);
public record Money(decimal Amount, string Currency);

public class Customer
{
    public CustomerId Id { get; set; }
    public Email Email { get; set; }  // ❌ EF Core가 저장 방법을 모름
    public Money Balance { get; set; }  // ❌ 복합 타입 저장 불가
}
```

### 해결: ValueConverter

```csharp
// EF Core ValueConverter
public class EmailValueConverter : ValueConverter<Email, string>
{
    public EmailValueConverter()
        : base(
            v => v.Value,           // Email → string (저장)
            v => new Email(v))      // string → Email (조회)
    { }
}

// DbContext 설정
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Customer>()
        .Property(c => c.Email)
        .HasConversion<EmailValueConverter>();
}
```

---

## 목표: 자동 생성할 코드

### 입력: Value Object

```csharp
using MyCompany.SourceGenerator;

namespace MyApp.Domain;

[ValueConverter]
public record Email(string Value);
```

### 생성 결과

```csharp
// <auto-generated/>
#nullable enable

using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

namespace MyApp.Domain;

/// <summary>
/// Email을 string으로 변환하는 EF Core ValueConverter
/// </summary>
[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(
    Justification = "Generated by source generator.")]
public sealed class EmailValueConverter : ValueConverter<Email, string>
{
    public EmailValueConverter()
        : base(
            v => v.Value,
            v => new Email(v))
    { }
}
```

### 입력: Entity Id (Ulid 기반)

```csharp
[EntityId]
[ValueConverter]  // ValueConverter도 함께 생성
public readonly partial record struct ProductId;
```

### 생성 결과

```csharp
// <auto-generated/>
#nullable enable

using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

namespace MyApp.Domain;

/// <summary>
/// ProductId를 byte[]로 변환하는 EF Core ValueConverter
/// </summary>
[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(
    Justification = "Generated by source generator.")]
public sealed class ProductIdValueConverter : ValueConverter<ProductId, byte[]>
{
    public ProductIdValueConverter()
        : base(
            v => v.Value.ToByteArray(),
            v => ProductId.Create(new global::Cysharp.Serialization.Ulid(v)))
    { }
}
```

---

## 저장 형식 선택

### Ulid 저장 옵션

| 형식 | 크기 | 장점 | 단점 |
|------|------|------|------|
| `byte[]` | 16 bytes | 공간 효율, 빠른 비교 | 읽기 어려움 |
| `string` | 26 chars | 가독성 | 공간 비효율 |

```csharp
// byte[] 저장 (권장)
public class ProductIdValueConverter : ValueConverter<ProductId, byte[]>
{
    public ProductIdValueConverter()
        : base(
            v => v.Value.ToByteArray(),
            v => ProductId.Create(new Ulid(v)))
    { }
}

// string 저장 (디버깅용)
public class ProductIdStringValueConverter : ValueConverter<ProductId, string>
{
    public ProductIdStringValueConverter()
        : base(
            v => v.Value.ToString(),
            v => ProductId.Create(Ulid.Parse(v)))
    { }
}
```

---

## 구현

### 1. 메타데이터 클래스

```csharp
// ValueConverterInfo.cs
namespace MyCompany.SourceGenerator;

/// <summary>
/// ValueConverter 생성에 필요한 메타데이터
/// </summary>
public sealed record ValueConverterInfo(
    string TypeName,
    string Namespace,
    string ProviderType,           // DB 저장 타입 (string, byte[], int 등)
    string ToProviderExpression,   // Model → Provider 변환 식
    string FromProviderExpression, // Provider → Model 변환 식
    bool IsEntityId);              // EntityId 여부
```

### 2. 마커 속성 정의

```csharp
// ValueConverterAttribute.cs
namespace MyCompany.SourceGenerator;

internal static class ValueConverterAttribute
{
    public const string Source = """
        // <auto-generated/>
        #nullable enable

        namespace MyCompany.SourceGenerator;

        /// <summary>
        /// EF Core ValueConverter를 생성할 타입에 적용합니다.
        /// </summary>
        /// <example>
        /// <code>
        /// [ValueConverter]
        /// public record Email(string Value);
        /// </code>
        /// </example>
        [global::System.AttributeUsage(
            global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct,
            AllowMultiple = false,
            Inherited = false)]
        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(
            Justification = "Generated by source generator.")]
        public sealed class ValueConverterAttribute : global::System.Attribute
        {
            /// <summary>
            /// DB에 저장할 타입입니다. 지정하지 않으면 자동 추론합니다.
            /// </summary>
            public global::System.Type? ProviderType { get; set; }
        }
        """;

    public const string FullyQualifiedName = "MyCompany.SourceGenerator.ValueConverterAttribute";
}
```

### 3. 메인 생성기

```csharp
// ValueConverterGenerator.cs
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MyCompany.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public sealed class ValueConverterGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1단계: 속성 정의 생성
        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddSource(
                hintName: "ValueConverterAttribute.g.cs",
                sourceText: SourceText.From(ValueConverterAttribute.Source, Encoding.UTF8)));

        // 2단계: [ValueConverter] 속성이 붙은 타입 수집
        var provider = RegisterSourceProvider(context);

        // 3단계: 코드 생성
        context.RegisterSourceOutput(provider, Execute);
    }

    private static IncrementalValuesProvider<ValueConverterInfo> RegisterSourceProvider(
        IncrementalGeneratorInitializationContext context)
    {
        return context.SyntaxProvider
            .ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: ValueConverterAttribute.FullyQualifiedName,
                predicate: IsTypeDeclaration,
                transform: MapToValueConverterInfo)
            .Where(static x => x is not null)!;
    }

    private static bool IsTypeDeclaration(SyntaxNode node, CancellationToken _)
    {
        return node is TypeDeclarationSyntax;
    }

    private static ValueConverterInfo? MapToValueConverterInfo(
        GeneratorAttributeSyntaxContext context,
        CancellationToken _)
    {
        if (context.TargetSymbol is not INamedTypeSymbol typeSymbol)
            return null;

        // EntityId 여부 확인
        bool isEntityId = typeSymbol.GetAttributes()
            .Any(a => a.AttributeClass?.Name == "EntityIdAttribute");

        // 생성자 파라미터 분석
        var constructor = typeSymbol.Constructors
            .Where(c => c.DeclaredAccessibility == Accessibility.Public)
            .OrderByDescending(c => c.Parameters.Length)
            .FirstOrDefault();

        if (constructor is null || constructor.Parameters.Length == 0)
        {
            // EntityId인 경우 Ulid 기반 처리
            if (isEntityId)
            {
                return new ValueConverterInfo(
                    TypeName: typeSymbol.Name,
                    Namespace: typeSymbol.ContainingNamespace.ToDisplayString(),
                    ProviderType: "byte[]",
                    ToProviderExpression: "v => v.Value.ToByteArray()",
                    FromProviderExpression: $"v => {typeSymbol.Name}.Create(new global::Cysharp.Serialization.Ulid(v))",
                    IsEntityId: true);
            }
            return null;
        }

        // 단일 파라미터인 경우 (Value Object)
        if (constructor.Parameters.Length == 1)
        {
            var param = constructor.Parameters[0];
            var providerType = GetProviderType(param.Type);

            return new ValueConverterInfo(
                TypeName: typeSymbol.Name,
                Namespace: typeSymbol.ContainingNamespace.ToDisplayString(),
                ProviderType: providerType,
                ToProviderExpression: $"v => v.{ToPascalCase(param.Name)}",
                FromProviderExpression: $"v => new {typeSymbol.Name}(v)",
                IsEntityId: false);
        }

        // 다중 파라미터인 경우 (JSON 직렬화로 처리)
        return new ValueConverterInfo(
            TypeName: typeSymbol.Name,
            Namespace: typeSymbol.ContainingNamespace.ToDisplayString(),
            ProviderType: "string",
            ToProviderExpression: "v => global::System.Text.Json.JsonSerializer.Serialize(v)",
            FromProviderExpression: $"v => global::System.Text.Json.JsonSerializer.Deserialize<{typeSymbol.Name}>(v)!",
            IsEntityId: false);
    }

    private static string GetProviderType(ITypeSymbol type)
    {
        return type.SpecialType switch
        {
            SpecialType.System_String => "string",
            SpecialType.System_Int32 => "int",
            SpecialType.System_Int64 => "long",
            SpecialType.System_Decimal => "decimal",
            SpecialType.System_Double => "double",
            SpecialType.System_Boolean => "bool",
            SpecialType.System_DateTime => "global::System.DateTime",
            _ => type.ToDisplayString()
        };
    }

    private static string ToPascalCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;
        return char.ToUpper(name[0]) + name.Substring(1);
    }

    private static void Execute(
        SourceProductionContext context,
        ValueConverterInfo info)
    {
        var source = GenerateValueConverterSource(info);
        var fileName = $"{info.Namespace.Replace(".", "")}{info.TypeName}ValueConverter.g.cs";

        context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
    }

    private static string GenerateValueConverterSource(ValueConverterInfo info)
    {
        var sb = new StringBuilder();

        // 헤더
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // using 문
        sb.AppendLine("using Microsoft.EntityFrameworkCore.Storage.ValueConversion;");
        sb.AppendLine();

        // 네임스페이스
        sb.AppendLine($"namespace {info.Namespace};");
        sb.AppendLine();

        // 클래스 설명
        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// {info.TypeName}을 {info.ProviderType}로 변환하는 EF Core ValueConverter");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine("[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(");
        sb.AppendLine("    Justification = \"Generated by source generator.\")]");

        // 클래스 선언
        sb.AppendLine($"public sealed class {info.TypeName}ValueConverter : ValueConverter<{info.TypeName}, {info.ProviderType}>");
        sb.AppendLine("{");

        // 생성자
        sb.AppendLine($"    public {info.TypeName}ValueConverter()");
        sb.AppendLine("        : base(");
        sb.AppendLine($"            {info.ToProviderExpression},");
        sb.AppendLine($"            {info.FromProviderExpression})");
        sb.AppendLine("    { }");

        sb.AppendLine("}");

        return sb.ToString();
    }
}
```

---

## DbContext 설정 헬퍼 생성

### 자동 등록 확장 메서드

```csharp
// 입력: 여러 ValueConverter가 있는 프로젝트

// 자동 생성
public static class ValueConverterExtensions
{
    public static void ApplyValueConverters(this ModelBuilder modelBuilder)
    {
        // Email
        modelBuilder.Properties<Email>()
            .HaveConversion<EmailValueConverter>();

        // ProductId
        modelBuilder.Properties<ProductId>()
            .HaveConversion<ProductIdValueConverter>();

        // CustomerId
        modelBuilder.Properties<CustomerId>()
            .HaveConversion<CustomerIdValueConverter>();
    }
}
```

### DbContext에서 사용

```csharp
public class AppDbContext : DbContext
{
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // 한 줄로 모든 ValueConverter 등록
        modelBuilder.ApplyValueConverters();
    }
}
```

---

## 테스트

### Value Object 변환 테스트

```csharp
[Fact]
public Task ValueConverterGenerator_ShouldGenerate_ForSimpleValueObject()
{
    // Arrange
    string input = """
        using MyCompany.SourceGenerator;

        namespace TestNamespace;

        [ValueConverter]
        public record Email(string Value);
        """;

    // Act
    string? actual = _sut.Generate(input);

    // Assert
    return Verify(actual);
}
```

### Entity Id 변환 테스트

```csharp
[Fact]
public Task ValueConverterGenerator_ShouldGenerate_ForEntityId()
{
    // Arrange
    string input = """
        using MyCompany.SourceGenerator;

        namespace TestNamespace;

        [EntityId]
        [ValueConverter]
        public readonly partial record struct ProductId;
        """;

    // Act
    string? actual = _sut.Generate(input);

    // Assert
    return Verify(actual);
}
```

### 복합 Value Object 테스트

```csharp
[Fact]
public Task ValueConverterGenerator_ShouldGenerate_ForComplexValueObject()
{
    // Arrange
    string input = """
        using MyCompany.SourceGenerator;

        namespace TestNamespace;

        [ValueConverter]
        public record Money(decimal Amount, string Currency);
        """;

    // Act
    string? actual = _sut.Generate(input);

    // Assert
    return Verify(actual);
}
```

---

## 사용 예시

### 도메인 모델

```csharp
// Domain/ValueObjects/Email.cs
[ValueConverter]
public record Email(string Value)
{
    public static Email Create(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException("Email cannot be empty");

        if (!value.Contains('@'))
            throw new ArgumentException("Invalid email format");

        return new Email(value.ToLowerInvariant());
    }
}

// Domain/ValueObjects/Money.cs
[ValueConverter]
public record Money(decimal Amount, string Currency)
{
    public static Money Zero(string currency) => new(0m, currency);

    public Money Add(Money other)
    {
        if (Currency != other.Currency)
            throw new InvalidOperationException("Cannot add money with different currencies");

        return new Money(Amount + other.Amount, Currency);
    }
}
```

### Entity

```csharp
public class Order
{
    public OrderId Id { get; private set; }
    public CustomerId CustomerId { get; private set; }
    public Email CustomerEmail { get; private set; }
    public Money TotalAmount { get; private set; }
}
```

### DbContext 설정

```csharp
public class AppDbContext : DbContext
{
    public DbSet<Order> Orders => Set<Order>();

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // 자동 생성된 확장 메서드 사용
        modelBuilder.ApplyValueConverters();

        modelBuilder.Entity<Order>(entity =>
        {
            entity.HasKey(e => e.Id);

            // ValueConverter가 자동 적용됨
            entity.Property(e => e.Id);
            entity.Property(e => e.CustomerId);
            entity.Property(e => e.CustomerEmail);
            entity.Property(e => e.TotalAmount);
        });
    }
}
```

---

## 고급: Dapper 지원

### TypeHandler 생성

```csharp
// Dapper용 TypeHandler도 함께 생성
public sealed class ProductIdTypeHandler : SqlMapper.TypeHandler<ProductId>
{
    public override ProductId Parse(object value)
    {
        return value switch
        {
            byte[] bytes => ProductId.Create(new Ulid(bytes)),
            string str => ProductId.Create(Ulid.Parse(str)),
            _ => throw new InvalidCastException($"Cannot convert {value.GetType()} to ProductId")
        };
    }

    public override void SetValue(IDbDataParameter parameter, ProductId value)
    {
        parameter.Value = value.Value.ToByteArray();
        parameter.DbType = DbType.Binary;
    }
}
```

---

## 요약

| 항목 | 설명 |
|------|------|
| **목적** | Value Object, Entity Id를 DB에 저장하기 위한 ValueConverter 자동 생성 |
| **대상** | `[ValueConverter]` 속성이 붙은 record/class |
| **분석** | 생성자 파라미터로 변환 로직 추론 |
| **저장 형식** | 단일 파라미터 → 해당 타입, 다중 → JSON |
| **Entity Id** | Ulid → byte[] (16 bytes) |

---

## 다음 단계

다음 섹션에서는 FluentValidation 규칙을 자동 생성하는 Validation 생성기를 구현합니다.

➡️ [04. Validation 생성기](04-validation-generator.md)
