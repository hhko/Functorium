# 1장: 기본 나눗셈에서 시작하기 🟢

> **Part 1: 값 객체 개념 이해** | [← 목차로](../../../README.md) | [다음: 2장 방어적 프로그래밍 →](../../02-Defensive-Programming/DefensiveProgramming/README.md)

---

## 개요

모든 학습은 가장 기본적인 것에서 시작합니다. 이 단계에서는 누구나 처음 프로그래밍을 배울 때 만들어보는 **나눗셈 함수**를 출발점으로 삼아, 값 객체의 필요성을 자연스럽게 이해할 수 있도록 구성했습니다.

> **단순한 나눗셈 함수 하나가 어떻게 도메인을 표현하는 타입으로 진화하는지 함께 살펴봅시다.**

## 학습 목표

### **핵심 학습 목표**
1. **기본 나눗셈 함수의 문제점 인식**
   - `Divide(10, 0)` 호출 시 `DivideByZeroException` 발생 확인
   - 예외 기반 오류 처리의 한계와 위험성 이해
   - 프로그램 실행 중 갑작스러운 비정상 종료 가능성의 문제점 파악

2. **도메인 규칙의 부재 인식**
   - "0으로 나눌 수 없다"는 수학적 규칙이 코드에 표현되지 않음
   - 단순한 `int` 타입으로는 도메인 제약 조건을 표현할 수 없음
   - 비즈니스 규칙이 코드에 드러나지 않는 문제점 이해

### **실습을 통해 확인할 내용**
- **정상 케이스**: `Divide(10, 2)` → `5` 반환
- **예외 케이스**: `Divide(10, 0)` → `DivideByZeroException` 발생
- **예외 처리**: `try-catch` 블록을 통한 예외 처리 방법

## 왜 필요한가?

프로그래밍을 처음 배울 때 가장 기본적인 나눗셈 함수를 만들어보는 것은 자연스러운 시작점입니다. 하지만 실제로 이 함수를 사용해보면 **예상치 못한 문제가 발생**합니다.

```csharp
public int Divide(int numerator, int denominator)
{
    return numerator / denominator;
}
```

**첫 번째 문제는 예외 기반 오류 처리입니다.** 0으로 나누기를 시도하면 `DivideByZeroException`이 발생하여 프로그램이 갑자기 중단됩니다. 이는 마치 **시스템 리소스 부족**이나 **네트워크 연결 실패**와 같은 예외적인 상황이 아니라, **예상 가능한 도메인 규칙 위반**임에도 불구하고 예외를 발생시키는 것입니다.

**두 번째 문제는 부작용(Side effect)입니다.** 함수가 예외를 발생시켜 프로그램의 흐름을 중단시키는 것은 **함수형 프로그래밍의 순수성 원칙**을 위반합니다. 마치 **참조 투명성(Referential Transparency)**을 깨뜨리는 것과 같습니다.

**세 번째 문제는 도메인 규칙이 코드에 드러나지 않는다는 점입니다.** "0으로 나눌 수 없다"는 수학적 규칙이 단순한 `int` 타입으로는 표현되지 않아서, 코드를 읽는 사람이 이 제약을 파악하기 어렵습니다. 이는 **도메인 주도 설계(DDD)** 관점에서 도메인 개념이 코드에 명확하게 반영되지 않는 문제입니다.

이러한 문제들을 해결하기 위해 값 객체(Value Object)라는 개념을 도입해야 합니다. 값 객체를 사용하면 예상 가능한 실패를 명시적으로 처리하고, 도메인 규칙을 코드에 명확하게 표현할 수 있습니다.

## 핵심 개념

이 프로젝트의 핵심은 크게 세 가지 개념으로 나눌 수 있습니다. 각각이 어떻게 작동하는지 쉽게 설명해드리겠습니다.

### 순수 함수(Pure Function)

순수 함수는 마치 수학 공식처럼 예측 가능하게 동작하는 함수입니다. 순수 함수는 **함수형 프로그래밍의 핵심 원칙**을 따르는 함수입니다. 

**핵심 아이디어는 "동일한 입력에 대해 항상 동일한 출력을 반환하고, 부작용이 없다"는 것입니다.** 이는 **참조 투명성(Referential Transparency)**을 보장하며, 함수 호출을 그 결과값으로 대체할 수 있게 만듭니다.

예를 들어, 기본 나눗셈 함수를 생각해보세요. 이 함수는 0으로 나누기를 시도하면 예외를 발생시켜 프로그램을 중단시킵니다. 이는 **부작용(Side Effect)**을 발생시키는 것으로, 함수형 프로그래밍의 순수성 원칙을 위반합니다.

```csharp
// 문제가 있는 함수 (순수하지 않음) - 예외 발생으로 프로그램 중단
public int Divide(int x, int y)
{
    // y가 0이면 예외 발생! (부작용)
    return x / y;
}

// 개선된 함수 (순수 함수) - 예외 없이 안전한 연산
public int Divide(int x, Denominator y)
{
    // y는 항상 유효함을 보장 (부작용 없음)
    return x / y.Value;
}
```

이렇게 개선하면 함수가 **예측 가능하게 동작**하고, **예외로 인한 프로그램 중단을 방지**할 수 있습니다. 이는 **함수형 프로그래밍의 합성성(Composability)**을 가능하게 만듭니다.

### 예외 vs 도메인 타입

**핵심 아이디어는 "예외는 예외적인 상황을 위한 것이지, 예상 가능한 실패를 위한 것이 아니다"는 것입니다.**

예외는 **시스템 레벨의 오류**나 **예상치 못한 외부 요인**으로 인한 실패에만 사용해야 합니다. 이는 **방어적 프로그래밍(Defensive Programming)**의 기본 원칙입니다.

```csharp
// 예외 사용 (부적절) - 예상 가능한 실패를 예외로 처리
var result = Divide(10, 0);  // 런타임에서 예외 발생!

// 도메인 타입 사용 (적절) - 컴파일 타임에 오류 방지
var result = Divide(10, new Denominator(2));  // 안전한 연산
```

이렇게 하면 **컴파일러가 컴파일 시점에 잘못된 사용을 방지**할 수 있어서, 런타임에 예상치 못한 오류가 발생할 가능성을 줄일 수 있습니다. 이는 **타입 안전성(Type Safety)**을 통한 **조기 오류 발견(Early Error Detection)**의 핵심입니다.

### 타입 안전성과 설계 시점의 차이

**핵심 아이디어는 "타입 시스템이 실패 처리를 강제하여 개발자가 실수를 방지할 수 있다"는 것입니다.**

예외를 사용하는 방식에서는 개발자가 "0으로 나누면 예외가 발생할 수 있다"는 것을 기억해야 합니다. 하지만 도메인 타입을 사용하면 **타입 시스템이 자동으로 이런 제약을 강제**합니다.

```csharp
// 예외 방식 - 개발자가 기억해야 함 (깜빡할 수 있음)
public int Divide(int x, int y) { return x / y; }

// 도메인 타입 방식 - 타입 시스템이 강제함 (깜빡할 수 없음)
public int Divide(int x, Denominator y) { return x / y.Value; }
```

이렇게 하면 **설계 단계에서 실패 시나리오를 명시적으로 고려하도록 강요**함으로써, 더 견고하고 예측 가능한 코드를 작성할 수 있습니다. 이는 **컴파일 타임 검증(Compile-time Validation)**을 통한 **오류 방지(Error Prevention)**의 핵심입니다.

## 실전 지침

### 예상 출력
```
=== 기본 나눗셈 함수 ===

정상 케이스:
10 / 2 = 5

예외 케이스:
10 / 0 = System.DivideByZeroException: Attempted to divide by zero.
   at BasicDivide.MathOperations.Divide(Int32 numerator, Int32 denominator) in ...\MathOperations.cs:line 16
   at BasicDivide.Program.DemonstrateExceptionalDivide() in ...\Program.cs:line 43
```

## 프로젝트 설명

### 프로젝트 구조
```
BasicDivide/                        # 메인 프로젝트
├── Program.cs                      # 메인 실행 파일
├── MathOperations.cs               # 나눗셈 함수 구현
├── BasicDivide.csproj              # 프로젝트 파일
└── README.md                       # 메인 문서
```

### 핵심 코드

#### MathOperations.cs
```csharp
public static class MathOperations
{
    // 문제가 있는 기본 나눗셈 함수
    public static int Divide(int numerator, int denominator)
    {
        // denominator가 0이면 예외 발생!
        return numerator / denominator;
    }
}
```

#### Program.cs
```csharp
class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("=== 기본 나눗셈 함수 테스트 ===\n");

        // 정상 케이스
        Console.WriteLine("정상 케이스:");
        try
        {
            var result = MathOperations.Divide(10, 2);
            Console.WriteLine($"10 / 2 = {result}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"예외 발생: {ex.Message}");
        }

        Console.WriteLine();

        // 예외 케이스
        Console.WriteLine("예외 케이스:");
        try
        {
            var result = MathOperations.Divide(10, 0);
            Console.WriteLine($"10 / 0 = {result}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"10 / 0 = {ex}");
        }
    }
}
```

## 한눈에 보는 정리

### 기본 나눗셈 함수의 문제점
| 문제점 | 설명 | 영향 |
|--------|------|------|
| **예외 기반 오류 처리** | 예상 가능한 실패를 예외로 처리하여 프로그램 흐름 중단 | 프로그램 안정성 저하 |
| **부작용** | 예외를 발생시켜 프로그램 흐름을 중단 | 예측 불가능한 동작 |
| **호출자 책임** | 함수를 사용하는 쪽에서 예외 처리를 해야 함 | 사용 복잡성 증가 |
| **도메인 표현 부족** | 비즈니스 규칙이 코드에 드러나지 않음 | 코드 가독성 저하 |
| **타입 안전성 부족** | 컴파일 타임에 유효하지 않은 입력을 검증할 수 없음 | 런타임 오류 위험 |

### 예외 vs 도메인 타입 비교
| 구분 | 예외 | 도메인 타입 |
|------|------------------|------------------|
| **발견 시점** | 런타임 | 컴파일 타임 |
| **디버깅 비용** | 높음 (실행 → 에러 → 분석 → 수정) | 낮음 (명시적 실패 처리) |
| **배포 위험** | 높음 (테스트에서 놓칠 수 있음) | 낮음 (예외로 인한 중단 없음) |
| **개발자 경험** | 나쁨 (갑작스러운 중단) | 좋음 (예측 가능한 처리) |

### 개선 방향
1. **순수 함수로 전환**: 예외 대신 명시적인 결과 타입 사용
2. **도메인 타입 도입**: "0이 아닌 정수"를 표현하는 타입 생성
3. **타입 안전성 확보**: 런타임에서 안전한 실패 처리

## FAQ

### Q1: 왜 나눗셈 함수로 시작하나요?
**A**: 나눗셈은 누구나 이해하기 쉬운 수학적 개념이며, 0으로 나누기라는 명확한 제약 조건이 있어서 값 객체의 필요성을 자연스럽게 보여줄 수 있습니다.

### Q2: 예외가 항상 나쁜 것은 아닌가요?
**A**: 예외는 **예외적인 상황**을 처리하기 위한 것이지, **예상 가능한 실패**를 처리하기 위한 것이 아닙니다. 0으로 나누기는 예상 가능한 실패이므로 예외보다는 명시적인 처리가 더 적합합니다.

**예외적인 상황 (예외 사용 적절)**: 파일이 갑자기 삭제되었거나, 네트워크 연결이 끊어졌거나, 시스템 메모리가 부족한 경우 등 예상치 못한 시스템 오류나 외부 요인으로 인한 실패입니다.

**예상 가능한 실패 (예외 사용 부적절)**: 사용자가 0을 입력하거나, 잘못된 이메일 형식을 입력하거나, 음수 나이를 입력하는 경우 등 비즈니스 규칙 위반이나 사용자 입력 오류로 인한 실패입니다.

### Q3: 이 문제를 어떻게 해결할 수 있나요?
**A**: 다음 단계들에서 점진적으로 해결 방법을 배우게 됩니다:

1. **방어적 프로그래밍**: 사전 검증을 통한 예외 방지 (02-Exception-Handling)
2. **함수형 결과 타입**: 예외 대신 명시적인 결과 타입 사용 (03-Functional-Result)
3. **값 객체 도입**: "0이 아닌 정수"를 표현하는 도메인 타입 생성 (04-Always-Valid)
4. **타입 안전성 확보**: 컴파일 타임에 유효성 검증

이러한 단계적 접근을 통해 예외 기반 함수에서 순수 함수로, 그리고 도메인 타입을 활용한 타입 안전한 함수로 진화하는 과정을 체험하게 됩니다.

### Q4: 실제 프로젝트에서 이런 문제가 자주 발생하나요?
**A**: 네, 매우 자주 발생합니다. 실제 프로젝트에서는 다음과 같은 상황에서 비슷한 문제가 발생합니다:

**입력 검증**: 이메일 주소, 전화번호, 비밀번호, 사용자 이름, 나이, 금액 등 단순한 문자열이나 숫자에 비즈니스 규칙이 적용되는 경우가 많습니다.

**도메인 규칙**: "나이는 음수가 될 수 없다", "이메일은 올바른 형식이어야 한다", "비밀번호는 최소 8자 이상이어야 한다" 등의 비즈니스 규칙이 단순한 타입으로는 표현되지 않는 경우가 많습니다.

**현재 대부분의 프로젝트**: 이러한 상황을 방어적 프로그래밍이나 예외 처리로 해결하고 있어서, 런타임에서 예상치 못한 오류가 발생하거나 프로그램이 중단되는 경우가 많습니다.

### Q5: 도메인 타입이 예외보다 좋은 이유가 뭔가요?
**A**: 도메인 타입은 **예상 가능한 실패를 명시적 설계를 통해 해결하도록 구현하게 됩니다**. 

예외는 예외가 발생했을 때 예외 처리를 깜빡하고 생략할 경우 프로그램을 중단시키지만, 컴파일 타임에 컴파일러가 이런 누락을 도와주지 못합니다.

예를 들어, `Divide(10, 0)`의 경우:
- **예외**: "0으로 나누면 예외가 발생할 수 있다"는 것을 잊고 넘어갈 수 있음(프로그램 비정상 종료)
- **도메인 타입**: `Denominator` 타입을 설계할 때 "0이 아닌 값만 허용한다"는 제약을 명시적으로 구현해야 함(컴파일러의 도움)

이렇게 **설계 단계에서 실패 시나리오를 명시적으로 고려하도록 강요**함으로써, 더 견고하고 예측 가능한 코드를 작성할 수 있습니다.

**핵심 차이점:**
- **예외**: 런타임에서 발견되는 문제 (늦은 발견)
- **도메인 타입**: 컴파일 타임에서 발견되는 문제 (조기 발견)
- **예외**: 개발자가 기억해야 하는 제약 (깜빡할 수 있음)
- **도메인 타입**: 타입 시스템이 강제하는 제약 (깜빡할 수 없음)

### Q6: 모든 예외를 안전하게 처리할 수 있나요?
**A**: 아니요, 모든 예외를 안전하게 처리할 수는 없습니다. 하지만 **예상 가능한 실패**는 타입 시스템과 컴파일러를 통해 런타임에서 안전하게 처리할 수 있습니다. 예외는 정말 **예외적인 상황**(메모리 부족, 네트워크 오류 등)에만 사용해야 합니다.

**예상 가능한 실패 (타입 시스템으로 해결 가능):**
- 사용자 입력 오류 (잘못된 이메일, 음수 나이 등)
- 비즈니스 규칙 위반 (0으로 나누기, 잘못된 날짜 등)
- 도메인 제약 조건 (최대값 초과, 최소값 미달 등)

**예외적인 상황 (예외 사용 필요):**
- 시스템 리소스 부족 (메모리 부족, 디스크 공간 부족)
- 외부 시스템 오류 (네트워크 연결 실패, 데이터베이스 연결 실패)
- 예상치 못한 시스템 오류 (파일 삭제, 권한 부족)

### Q7: 이 단계에서 배운 내용이 실제로 도움이 되나요?
**A**: 네, 이 단계에서 배운 내용은 실제 프로젝트에서 매우 유용합니다.

**실제 활용성**: 예외와 예상 가능한 실패의 구분은 모든 프로젝트에서 중요한 설계 원칙입니다. 현재 대부분의 프로젝트에서는 예상 가능한 실패를 예외로 처리하고 있어서, 런타임에서 예상치 못한 오류가 발생하거나 프로그램이 중단되는 경우가 많습니다.

**개선의 필요성**: 사용자 입력 검증, 데이터 검증, 비즈니스 규칙 검증 등에서 예상 가능한 실패를 예외로 처리하는 것은 설계상 적절하지 않습니다. 이러한 상황들에서는 도메인 타입이나 함수형 결과 타입이 더 적합합니다.

**다음 단계 준비**: 이 단계에서 문제를 명확히 인식함으로써, 다음 단계들에서 배우게 될 해결 방법들의 필요성과 장점을 더 잘 이해할 수 있게 됩니다.

### Q8: 순수 함수와 부작용에 대해 더 자세히 설명해주세요.
**A**: 순수 함수와 부작용은 함수형 프로그래밍의 핵심 개념입니다.

**순수 함수 (Pure Function):**
- **동일한 입력에 대해 항상 동일한 출력**: 같은 매개변수로 호출하면 항상 같은 결과를 반환
- **부작용 없음**: 함수 외부의 상태를 변경하지 않음
- **참조 투명성**: 함수 호출을 그 결과값으로 대체 가능

**부작용 (Side Effect):**
- **상태 변경**: 전역 변수, 객체 상태, 파일 시스템 변경
- **예외 발생**: 프로그램 흐름을 중단시키는 예외
- **외부 통신**: 네트워크 요청, 데이터베이스 접근

**예시:**
```csharp
// 부작용이 있는 함수 (순수하지 않음)
public int Divide(int x, int y)
{
    // 부작용: 예외 발생
    if (y == 0)
        throw new DivideByZeroException();

    return x / y;
}

// 순수 함수 (개선된 함수)
public int Divide(int x, Denominator y)
{
    // 부작용 없음: y는 항상 유효함을 보장
    return x / y.Value;
}
```

순수 함수는 테스트하기 쉽고, 예측 가능하며, 조합하기 쉬운 장점이 있습니다.
