# 5ì¥: ì—°ì‚°ì ì˜¤ë²„ë¡œë”©ì„ í†µí•œ ìì—°ìŠ¤ëŸ¬ìš´ ë‚˜ëˆ—ì…ˆ ì—°ì‚°í•˜ê¸° ğŸŸ¡

> **Part 1: ê°’ ê°ì²´ ê°œë… ì´í•´** | [â† ì´ì „: 4ì¥ í•­ìƒ ìœ íš¨í•œ íƒ€ì…](../../04-Always-Valid/AlwaysValid/README.md) | [ëª©ì°¨](../../../README.md) | [ë‹¤ìŒ: 6ì¥ LINQ í‘œí˜„ì‹ â†’](../../06-Linq-Expression/LinqExpression/README.md)

---

## ëª©ì°¨
- [ê°œìš”](#ê°œìš”)
- [í•™ìŠµ ëª©í‘œ](#í•™ìŠµ-ëª©í‘œ)
- [ì™œ í•„ìš”í•œê°€?](#ì™œ-í•„ìš”í•œê°€)
- [í•µì‹¬ ê°œë…](#í•µì‹¬-ê°œë…)
- [ì‹¤ì „ ì§€ì¹¨](#ì‹¤ì „-ì§€ì¹¨)
- [í”„ë¡œì íŠ¸ ì„¤ëª…](#í”„ë¡œì íŠ¸-ì„¤ëª…)
- [í•œëˆˆì— ë³´ëŠ” ì •ë¦¬](#í•œëˆˆì—-ë³´ëŠ”-ì •ë¦¬)
- [FAQ](#faq)

## ê°œìš”

ì´ í”„ë¡œì íŠ¸ëŠ” ì—°ì‚°ì ì˜¤ë²„ë¡œë”©ì„ í™œìš©í•˜ì—¬ ê°’ ê°ì²´ë¥¼ ë”ìš± ìì—°ìŠ¤ëŸ½ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ ë§Œë“œëŠ” ë°©ë²•ì„ ë³´ì—¬ì¤ë‹ˆë‹¤. ì´ì „ ë‹¨ê³„ì—ì„œ `.Value` ì†ì„±ì„ í†µí•´ ë‚´ë¶€ ê°’ì— ì ‘ê·¼í•´ì•¼ í–ˆë˜ ì œì•½ì„ ì œê±°í•˜ê³ , ë„ë©”ì¸ ì–¸ì–´ë¥¼ ë”ìš± ì§ê´€ì ìœ¼ë¡œ í‘œí˜„í•  ìˆ˜ ìˆê²Œ ë©ë‹ˆë‹¤.

## í•™ìŠµ ëª©í‘œ

### **í•µì‹¬ í•™ìŠµ ëª©í‘œ**
1. **ì—°ì‚°ì ì˜¤ë²„ë¡œë”© êµ¬í˜„**: C#ì—ì„œ ì‚¬ìš©ì ì •ì˜ íƒ€ì…ì— ëŒ€í•œ ì—°ì‚°ì ì˜¤ë²„ë¡œë”©ì„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤
2. **ìì—°ìŠ¤ëŸ¬ìš´ ë„ë©”ì¸ ì–¸ì–´**: ê°’ ê°ì²´ë¥¼ ì‚¬ìš©í•  ë•Œ `.Value` ì—†ì´ë„ ìì—°ìŠ¤ëŸ¬ìš´ ì—°ì‚°ì´ ê°€ëŠ¥í•˜ë„ë¡ ë§Œë“¤ ìˆ˜ ìˆë‹¤
3. **ë³€í™˜ ì—°ì‚°ì í™œìš©**: ëª…ì‹œì  ë³€í™˜ ì—°ì‚°ìë¥¼ í†µí•´ íƒ€ì… ê°„ ìì—°ìŠ¤ëŸ¬ìš´ ë³€í™˜ì„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤

### **ì‹¤ìŠµì„ í†µí•´ í™•ì¸í•  ë‚´ìš©**
- **ìì—°ìŠ¤ëŸ¬ìš´ ë‚˜ëˆ—ì…ˆ**: `15 / denominator` í˜•íƒœë¡œ ì§ê´€ì ì¸ ì—°ì‚°
- **íƒ€ì… ë³€í™˜**: `(Denominator)15` í˜•íƒœì˜ ëª…ì‹œì  ë³€í™˜ê³¼ `int value = (int)denominator` í˜•íƒœì˜ ëª…ì‹œì  ë³€í™˜
- **ê°œì„ ëœ ì‚¬ìš©ì„±**: ì´ì „ ë‹¨ê³„ ëŒ€ë¹„ `.Value` ì†ì„± ì ‘ê·¼ ë¶ˆí•„ìš”

## ì™œ í•„ìš”í•œê°€?

ì´ì „ ë‹¨ê³„ì¸ `04-Always-Valid`ì—ì„œëŠ” ê°’ ê°ì²´ë¥¼ ë„ì…í•˜ì—¬ ì»´íŒŒì¼ íƒ€ì„ì— ìœ íš¨ì„±ì„ ë³´ì¥í•  ìˆ˜ ìˆê²Œ ë˜ì—ˆì§€ë§Œ, ì—¬ì „íˆ `.Value` ì†ì„±ì„ í†µí•´ ë‚´ë¶€ ê°’ì— ì ‘ê·¼í•´ì•¼ í•œë‹¤ëŠ” ì œì•½ì´ ìˆì—ˆìŠµë‹ˆë‹¤. ì´ì œ ê·¸ ì œì•½ì„ ì™„ì „íˆ ì œê±°í•´ë³´ê² ìŠµë‹ˆë‹¤.

**ì²« ë²ˆì§¸ ë¬¸ì œëŠ” ì½”ë“œ ê°€ë…ì„±ì´ ë–¨ì–´ì§„ë‹¤ëŠ” ì ì…ë‹ˆë‹¤.** `numerator / denominator.Value`ì™€ ê°™ì€ í˜•íƒœëŠ” ë§ˆì¹˜ ìˆ˜í•™ ë¬¸ì œë¥¼ í’€ ë•Œ "15 ë‚˜ëˆ„ê¸° 5ì˜ ê°’"ì´ë¼ê³  í‘œí˜„í•˜ëŠ” ê²ƒê³¼ ê°™ì•„ì„œ, ìì—°ìŠ¤ëŸ½ì§€ ì•ŠìŠµë‹ˆë‹¤. ì´ëŠ” **ë„ë©”ì¸ ì–¸ì–´(Domain Language)**ì™€ **í”„ë¡œê·¸ë˜ë° ì–¸ì–´** ê°„ì˜ ë¶ˆì¼ì¹˜ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.

**ë‘ ë²ˆì§¸ ë¬¸ì œëŠ” ë„ë©”ì¸ ì–¸ì–´ê°€ ë¶€ìì—°ìŠ¤ëŸ½ë‹¤ëŠ” ì ì…ë‹ˆë‹¤.** ìˆ˜í•™ì—ì„œëŠ” "15 Ã· 5"ë¼ê³  í‘œí˜„í•˜ì§€ë§Œ, ì½”ë“œì—ì„œëŠ” "15 / denominator.Value"ë¼ê³  í‘œí˜„í•´ì•¼ í•´ì„œ, ë„ë©”ì¸ ì „ë¬¸ê°€ê°€ ì½”ë“œë¥¼ ì½ê¸° ì–´ë µìŠµë‹ˆë‹¤. ì´ëŠ” **ë„ë©”ì¸ ì£¼ë„ ì„¤ê³„(DDD)**ì˜ **ê³µí†µ ì–¸ì–´(Ubiquitous Language)** ì›ì¹™ì„ ìœ„ë°˜í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.

**ì„¸ ë²ˆì§¸ ë¬¸ì œëŠ” ì‚¬ìš©ì„±ì´ ì œí•œëœë‹¤ëŠ” ì ì…ë‹ˆë‹¤.** ê°’ ê°ì²´ë¥¼ ì‚¬ìš©í•  ë•Œë§ˆë‹¤ `.Value` ì†ì„±ì— ì ‘ê·¼í•´ì•¼ í•˜ë¯€ë¡œ, ì½”ë“œê°€ ë³µì¡í•´ì§€ê³  ì‹¤ìˆ˜í•  ê°€ëŠ¥ì„±ì´ ë†’ì•„ì§‘ë‹ˆë‹¤. ì´ëŠ” **ìº¡ìŠí™”(Encapsulation)**ì˜ ì¥ì ì„ ì œëŒ€ë¡œ í™œìš©í•˜ì§€ ëª»í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.

ì´ëŸ¬í•œ ë¬¸ì œë“¤ì„ í•´ê²°í•˜ê¸° ìœ„í•´ **ì—°ì‚°ì ì˜¤ë²„ë¡œë”©(Operator Overloading)**ì„ ë„ì…í–ˆìŠµë‹ˆë‹¤. ì—°ì‚°ì ì˜¤ë²„ë¡œë”©ì„ ì‚¬ìš©í•˜ë©´ `15 / denominator`ì™€ ê°™ì€ ìì—°ìŠ¤ëŸ¬ìš´ ìˆ˜í•™ì  í‘œí˜„ì„ ì½”ë“œì—ì„œë„ ì‚¬ìš©í•  ìˆ˜ ìˆê³ , ë„ë©”ì¸ ì–¸ì–´ë¥¼ ë”ìš± ì§ê´€ì ìœ¼ë¡œ í‘œí˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## í•µì‹¬ ê°œë…

ì´ í”„ë¡œì íŠ¸ì˜ í•µì‹¬ì€ í¬ê²Œ ì„¸ ê°€ì§€ ê°œë…ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê°ê°ì´ ì–´ë–»ê²Œ ì‘ë™í•˜ëŠ”ì§€ ì‰½ê²Œ ì„¤ëª…í•´ë“œë¦¬ê² ìŠµë‹ˆë‹¤.

### ì—°ì‚°ì ì˜¤ë²„ë¡œë”©

ì—°ì‚°ì ì˜¤ë²„ë¡œë”©ì€ **ê¸°ì¡´ ì—°ì‚°ìì˜ ë™ì‘ì„ ì‚¬ìš©ì ì •ì˜ íƒ€ì…ì— ë§ê²Œ ì¬ì •ì˜**í•˜ëŠ” C#ì˜ ê°•ë ¥í•œ ê¸°ëŠ¥ì…ë‹ˆë‹¤.

**í•µì‹¬ ì•„ì´ë””ì–´ëŠ” "ê¸°ì¡´ ì—°ì‚°ìì˜ ë™ì‘ì„ ìš°ë¦¬ê°€ ë§Œë“  íƒ€ì…ì— ë§ê²Œ ì¬ì •ì˜í•˜ëŠ” ê²ƒ"ì…ë‹ˆë‹¤.** ì´ëŠ” **ë‹¤í˜•ì„±(Polymorphism)**ì˜ í•œ í˜•íƒœë¡œ, **ë„ë©”ì¸ íŠ¹í™” ì—°ì‚°(Domain-Specific Operations)**ì„ êµ¬í˜„í•  ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤.

ì˜ˆë¥¼ ë“¤ì–´, ë‚˜ëˆ—ì…ˆ ì—°ì‚°ìë¥¼ ìƒê°í•´ë³´ì„¸ìš”. ì´ì „ì—ëŠ” `numerator / denominator.Value`ì™€ ê°™ì´ `.Value` ì†ì„±ì— ì ‘ê·¼í•´ì•¼ í–ˆì§€ë§Œ, ì´ì œëŠ” `numerator / denominator`ì™€ ê°™ì´ ìì—°ìŠ¤ëŸ½ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```csharp
// ì´ì „ ë°©ì‹ (ë¬¸ì œê°€ ìˆëŠ” ë°©ì‹) - .Value ì†ì„± ì ‘ê·¼ í•„ìš”
public static int Divide(int numerator, Denominator denominator)
{
    return numerator / denominator.Value;  // .Value í•„ìš”
}

// ê°œì„ ëœ ë°©ì‹ (ì—°ì‚°ì ì˜¤ë²„ë¡œë”©) - ìì—°ìŠ¤ëŸ¬ìš´ ì—°ì‚°
public static int operator /(int numerator, Denominator denominator)
{
    return numerator / denominator._value;  // .Value ë¶ˆí•„ìš”
}
```

ì´ë ‡ê²Œ ê°œì„ í•˜ë©´ ì½”ë“œê°€ **ìˆ˜í•™ì  í‘œí˜„ê³¼ ë™ì¼**í•˜ê²Œ ë˜ì–´ì„œ, ë„ë©”ì¸ ì „ë¬¸ê°€ë„ ì‰½ê²Œ ì´í•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” **ë„ë©”ì¸ ì£¼ë„ ì„¤ê³„(DDD)**ì˜ **ê³µí†µ ì–¸ì–´(Ubiquitous Language)** ì›ì¹™ì„ êµ¬í˜„í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.

### ë³€í™˜ ì—°ì‚°ì

**í•µì‹¬ ì•„ì´ë””ì–´ëŠ” "íƒ€ì… ê°„ì˜ ìì—°ìŠ¤ëŸ¬ìš´ ë³€í™˜ì„ ì•ˆì „í•˜ê²Œ êµ¬í˜„í•˜ëŠ” ê²ƒ"ì…ë‹ˆë‹¤.**

ë³€í™˜ ì—°ì‚°ìëŠ” **íƒ€ì… ê°„ì˜ ì•ˆì „í•œ ë³€í™˜**ì„ êµ¬í˜„í•˜ëŠ” C#ì˜ ê¸°ëŠ¥ì…ë‹ˆë‹¤. ì´ëŠ” **ëª…ì‹œì  ë³€í™˜(Explicit Conversion)**ê³¼ **ì•”ì‹œì  ë³€í™˜(Implicit Conversion)**ì„ í†µí•´ **íƒ€ì… ì•ˆì „ì„±(Type Safety)**ì„ ë³´ì¥í•©ë‹ˆë‹¤.

```csharp
// ëª…ì‹œì  ë³€í™˜ - ì•ˆì „í•œ ë³€í™˜
public static explicit operator Denominator(int value)
{
    return Denominator.Create(value).Match(
        Succ: x => x,
        Fail: _ => throw new InvalidCastException("0ì€ Denominatorë¡œ ë³€í™˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
    );
}

// ëª…ì‹œì  ë³€í™˜ - ìë™ ë³€í™˜
public static explicit operator int(Denominator denominator)
{
    return denominator._value;  // ì•ˆì „í•œ ë³€í™˜
}
```

ì´ë ‡ê²Œ í•˜ë©´ **ì»´íŒŒì¼ëŸ¬ê°€ ì»´íŒŒì¼ ì‹œì ì— íƒ€ì… ë³€í™˜ì„ ê²€ì¦**í•  ìˆ˜ ìˆì–´ì„œ, ëŸ°íƒ€ì„ì— ì˜ˆìƒì¹˜ ëª»í•œ íƒ€ì… ì—ëŸ¬ê°€ ë°œìƒí•  ê°€ëŠ¥ì„±ì„ ì¤„ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” **íƒ€ì… ì•ˆì „ì„±(Type Safety)**ì„ í†µí•œ **ì¡°ê¸° ì˜¤ë¥˜ ë°œê²¬(Early Error Detection)**ì˜ í•µì‹¬ì…ë‹ˆë‹¤.

### ë„ë©”ì¸ ì–¸ì–´ì˜ ìì—°ìŠ¤ëŸ¬ìš´ í‘œí˜„

**í•µì‹¬ ì•„ì´ë””ì–´ëŠ” "ì½”ë“œê°€ ë„ë©”ì¸ ì „ë¬¸ê°€ì˜ ì–¸ì–´ì™€ ì¼ì¹˜í•˜ë„ë¡ ë§Œë“œëŠ” ê²ƒ"ì…ë‹ˆë‹¤.**

ë„ë©”ì¸ ì–¸ì–´ëŠ” **ë„ë©”ì¸ ì£¼ë„ ì„¤ê³„(DDD)**ì˜ í•µì‹¬ ì›ì¹™ì¸ **ê³µí†µ ì–¸ì–´(Ubiquitous Language)**ë¥¼ êµ¬í˜„í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ìˆ˜í•™ì—ì„œëŠ” "15 Ã· 5 = 3"ì´ë¼ê³  í‘œí˜„í•˜ë¯€ë¡œ, ì½”ë“œì—ì„œë„ `15 / denominator`ì™€ ê°™ì´ í‘œí˜„í•  ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.

```csharp
// ì´ì „ ë°©ì‹ - ë„ë©”ì¸ ì–¸ì–´ì™€ ë‹¤ë¦„
var result = numerator / denominator.Value;  // "15 ë‚˜ëˆ„ê¸° 5ì˜ ê°’"

// ê°œì„ ëœ ë°©ì‹ - ë„ë©”ì¸ ì–¸ì–´ì™€ ì¼ì¹˜
var result = numerator / denominator;        // "15 ë‚˜ëˆ„ê¸° 5"
```

ì´ë ‡ê²Œ í•˜ë©´ ì½”ë“œë¥¼ ì½ëŠ” ì‚¬ëŒì´ **ë„ë©”ì¸ ê°œë…ì„ ë” ì‰½ê²Œ ì´í•´**í•  ìˆ˜ ìˆê³ , **ì½”ë“œì˜ ì˜ë„ê°€ ë” ëª…í™•**í•´ì§‘ë‹ˆë‹¤. ì´ëŠ” **ë„ë©”ì¸ ì „ë¬¸ê°€ì™€ ê°œë°œì ê°„ì˜ ì†Œí†µ**ì„ ì›í™œí•˜ê²Œ ë§Œë“œëŠ” í•µì‹¬ ìš”ì†Œì…ë‹ˆë‹¤.

## ì‹¤ì „ ì§€ì¹¨

### ì˜ˆìƒ ì¶œë ¥
```
=== ì—°ì‚°ì ì˜¤ë²„ë¡œë”©ì„ í†µí•œ ìì—°ìŠ¤ëŸ¬ìš´ ë‚˜ëˆ—ì…ˆ ì—°ì‚° ===

1. í•µì‹¬ ê°œì„ ì‚¬í•­: ìì—°ìŠ¤ëŸ¬ìš´ ë‚˜ëˆ—ì…ˆ ì—°ì‚°
  Before (04-Always-Valid): numerator / denominator.Value
  After  (05-Operator-Overloading): numerator / denominator
  15 / OperatorOverloading.ValueObjects.Denominator = 3
  15 / OperatorOverloading.ValueObjects.Denominator = 3 (ì§ì ‘ ì—°ì‚°ì)

2. ë³€í™˜ ì—°ì‚°ì:
  intì—ì„œ Denominatorë¡œ ë³€í™˜:
    15 -> Denominator: OperatorOverloading.ValueObjects.Denominator
    Denominator -> int: 15
    0 -> Denominator(ë³€í™˜ ì‹¤íŒ¨): 0ì€ Denominatorë¡œ ë³€í™˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤

3. ì—ëŸ¬ ì²˜ë¦¬:
  ì—°ì‚° ì¤‘ ì—ëŸ¬ ì²˜ë¦¬:
    Denominator ìƒì„± ì‹¤íŒ¨: 0ì€ í—ˆìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤
```

### **í•µì‹¬ êµ¬í˜„ í¬ì¸íŠ¸**
1. **ì—°ì‚°ì ì˜¤ë²„ë¡œë”©**: `public static int operator /(int numerator, Denominator denominator)` êµ¬í˜„
2. **ë³€í™˜ ì—°ì‚°ì**: `explicit operator Denominator(int value)`ì™€ `implicit operator int(Denominator value)` êµ¬í˜„
3. **ì—ëŸ¬ ì²˜ë¦¬**: 0ê°’ ë³€í™˜ ì‹œë„ ì‹œ `InvalidCastException` ë°œìƒ

## í”„ë¡œì íŠ¸ ì„¤ëª…

### **í”„ë¡œì íŠ¸ êµ¬ì¡°**
```
OperatorOverloading/                        # ë©”ì¸ í”„ë¡œì íŠ¸
â”œâ”€â”€ Program.cs                              # ë©”ì¸ ì‹¤í–‰ íŒŒì¼
â”œâ”€â”€ MathOperations.cs                       # ì—°ì‚°ì ì˜¤ë²„ë¡œë”© í™œìš© ìˆ˜í•™ ì—°ì‚°
â”œâ”€â”€ ValueObjects/
â”‚   â””â”€â”€ Denominator.cs                      # ì—°ì‚°ì ì˜¤ë²„ë¡œë”©ì´ êµ¬í˜„ëœ ë¶„ëª¨ ê°’ ê°ì²´
â”œâ”€â”€ OperatorOverloading.csproj              # í”„ë¡œì íŠ¸ íŒŒì¼
â””â”€â”€ README.md                               # ë©”ì¸ ë¬¸ì„œ
```

### **í•µì‹¬ ì½”ë“œ**

#### **Denominator í´ë˜ìŠ¤ - ì—°ì‚°ì ì˜¤ë²„ë¡œë”©**
```csharp
public sealed class Denominator
{
    private readonly int _value;

    // í•µì‹¬: intì™€ Denominator ê°„ì˜ ë‚˜ëˆ—ì…ˆ ì—°ì‚°ì
    public static int operator /(int numerator, Denominator denominator) =>
        numerator / denominator._value;

    // ë³€í™˜ ì—°ì‚°ìë“¤
    // ëª…ì‹œì  ë³€í™˜ ì—°ì‚°ì
    public static explicit operator Denominator(int value) =>
        Create(value).Match(
            Succ: x => x,
            Fail: _ => throw new InvalidCastException("0ì€ Denominatorë¡œ ë³€í™˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
        );

    // ëª…ì‹œì  ë³€í™˜ ì—°ì‚°ì
    public static explicit operator int(Denominator value) =>
        value._value;
}
```

#### **MathOperations - ìì—°ìŠ¤ëŸ¬ìš´ ì—°ì‚°**
```csharp
public static class MathOperations
{
    public static int Divide(int numerator, Denominator denominator)
    {
        // í•µì‹¬ ê°œì„ ì‚¬í•­: .Value ì—†ì´ ìì—°ìŠ¤ëŸ¬ìš´ ì—°ì‚°
        return numerator / denominator;
    }
}
```

#### **í…ŒìŠ¤íŠ¸ - ì—°ì‚°ì ë™ì‘ í™•ì¸**
```csharp
// ìì—°ìŠ¤ëŸ¬ìš´ ë‚˜ëˆ—ì…ˆ ì—°ì‚°
int result = MathOperations.Divide(15, denom);
int directResult = 15 / denom;  // ì§ì ‘ ì—°ì‚°ì ì‚¬ìš©

// ë³€í™˜ ì—°ì‚°ì í…ŒìŠ¤íŠ¸
var nonZero = (Denominator)15;  // ëª…ì‹œì  ë³€í™˜: Denominator <- int
int intValue = (int)nonZero;    // ëª…ì‹œì  ë³€í™˜: int         <- Denominator
```

## í•œëˆˆì— ë³´ëŠ” ì •ë¦¬

### **ê°œì„ ì  ë¹„êµ**
| êµ¬ë¶„ | ì´ì „ ë°©ì‹ (04-Always-Valid) | í˜„ì¬ ë°©ì‹ (05-Operator-Overloading) |
|------|------------------------------|-------------------------------------|
| **ì—°ì‚° í‘œí˜„** | `numerator / denominator.Value` | `numerator / denominator` |
| **ê°€ë…ì„±** | `.Value` ì†ì„± ì ‘ê·¼ìœ¼ë¡œ ë³µì¡ | ìì—°ìŠ¤ëŸ¬ìš´ ìˆ˜í•™ì  í‘œí˜„ |
| **ë„ë©”ì¸ ì–¸ì–´** | í”„ë¡œê·¸ë˜ë° ì–¸ì–´ ì¤‘ì‹¬ | ë„ë©”ì¸ ì¤‘ì‹¬ì˜ ì§ê´€ì  í‘œí˜„ |
| **ì‚¬ìš©ì„±** | ë‚´ë¶€ ê°’ ì¶”ì¶œ í•„ìš” | ì§ì ‘ ì—°ì‚° ê°€ëŠ¥ |

### **ì¥ë‹¨ì **
| ì¥ì  | ë‹¨ì  |
|------|------|
| **ìì—°ìŠ¤ëŸ¬ìš´ ë„ë©”ì¸ ì–¸ì–´** | **êµ¬í˜„ ë³µì¡ì„± ì¦ê°€** |
| **í–¥ìƒëœ ê°€ë…ì„±** | **ë””ë²„ê¹… ì‹œ ë‚´ë¶€ ê°’ ì ‘ê·¼ ì œí•œ** |
| **ì§ê´€ì ì¸ ì—°ì‚°** | **ì—°ì‚°ì ì˜ë¯¸ ì¬ì •ì˜ í•„ìš”** |
| **íƒ€ì… ì•ˆì „ì„± ìœ ì§€** | **ì˜ëª»ëœ ì—°ì‚°ì ì˜¤ë²„ë¡œë”© ì‹œ í˜¼ë€** |

### **í•µì‹¬ ê¸°ìˆ **
- **ì—°ì‚°ì ì˜¤ë²„ë¡œë”©**: `/` ì—°ì‚°ì ì¬ì •ì˜
- **ë³€í™˜ ì—°ì‚°ì**: `explicit`/`implicit` ë³€í™˜ ì§€ì›
- **ê°’ ê°ì²´ íŒ¨í„´**: ë¶ˆë³€ì„±ê³¼ ìœ íš¨ì„± ê²€ì¦ ìœ ì§€
- **í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°**: `LanguageExt`ì˜ `Fin<T>` í™œìš©

## FAQ

### Q1: ì—°ì‚°ì ì˜¤ë²„ë¡œë”©ì´ ì„±ëŠ¥ì— ì˜í–¥ì„ ì£¼ë‚˜ìš”?
**A**: ê±°ì˜ ì—†ìŠµë‹ˆë‹¤. ì—°ì‚°ì ì˜¤ë²„ë¡œë”©ì€ ì»´íŒŒì¼ íƒ€ì„ì— ì²˜ë¦¬ë˜ë©°, ëŸ°íƒ€ì„ ì˜¤ë²„í—¤ë“œëŠ” ë¯¸ë¯¸í•©ë‹ˆë‹¤. ì´ëŠ” ë§ˆì¹˜ ë©”ì„œë“œ í˜¸ì¶œê³¼ ë™ì¼í•œ ìˆ˜ì¤€ì˜ ì„±ëŠ¥ì„ ì œê³µí•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

**ì»´íŒŒì¼ íƒ€ì„ ì²˜ë¦¬**ëŠ” ì—°ì‚°ì í˜¸ì¶œì´ ë©”ì„œë“œ í˜¸ì¶œë¡œ ë³€í™˜ë©ë‹ˆë‹¤. ì´ëŠ” ë§ˆì¹˜ ë§¤í¬ë¡œê°€ ì»´íŒŒì¼ ì‹œì ì— ì½”ë“œë¡œ í™•ì¥ë˜ëŠ” ê²ƒì²˜ëŸ¼, ì—°ì‚°ì ì˜¤ë²„ë¡œë”©ë„ ì»´íŒŒì¼ëŸ¬ê°€ ë©”ì„œë“œ í˜¸ì¶œë¡œ ë³€í™˜í•˜ì—¬ ì²˜ë¦¬í•©ë‹ˆë‹¤.

**ì¸ë¼ì¸ ìµœì í™”**ëŠ” JIT ì»´íŒŒì¼ëŸ¬ê°€ ìµœì í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” ë§ˆì¹˜ ì‘ì€ ë©”ì„œë“œë“¤ì´ ì¸ë¼ì¸ìœ¼ë¡œ ìµœì í™”ë˜ëŠ” ê²ƒì²˜ëŸ¼, ì—°ì‚°ì ì˜¤ë²„ë¡œë”© ë©”ì„œë“œë„ ì¸ë¼ì¸ ìµœì í™”ì˜ ëŒ€ìƒì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**ë©”ëª¨ë¦¬ ì˜í–¥**ì€ ì¶”ê°€ì ì¸ ë©”ëª¨ë¦¬ í• ë‹¹ì´ ì—†ìŠµë‹ˆë‹¤. ì´ëŠ” ë§ˆì¹˜ ì¼ë°˜ì ì¸ ë©”ì„œë“œ í˜¸ì¶œì²˜ëŸ¼, ì—°ì‚°ì ì˜¤ë²„ë¡œë”©ë„ ì¶”ê°€ì ì¸ ë©”ëª¨ë¦¬ í• ë‹¹ ì—†ì´ ê¸°ì¡´ ë©”ëª¨ë¦¬ ê³µê°„ì„ í™œìš©í•©ë‹ˆë‹¤.

### Q2: ëª¨ë“  ì—°ì‚°ìì— ëŒ€í•´ ì˜¤ë²„ë¡œë”©ì´ ê°€ëŠ¥í•œê°€ìš”?
**A**: ëŒ€ë¶€ë¶„ì˜ ì—°ì‚°ìì— ëŒ€í•´ ì˜¤ë²„ë¡œë”©ì´ ê°€ëŠ¥í•˜ì§€ë§Œ, ì¼ë¶€ ì œí•œì´ ìˆìŠµë‹ˆë‹¤.

**ì‹¤ì œ ì˜ˆì‹œ:**
```csharp
// ê°€ëŠ¥í•œ ì—°ì‚°ìë“¤
public static T operator +(T a, T b)     // ë§ì…ˆ
public static T operator -(T a, T b)     // ëº„ì…ˆ
public static T operator *(T a, T b)     // ê³±ì…ˆ
public static T operator /(T a, T b)     // ë‚˜ëˆ—ì…ˆ
public static bool operator ==(T a, T b) // ë™ë“± ë¹„êµ
public static bool operator !=(T a, T b) // ë¶€ë“± ë¹„êµ

// ë¶ˆê°€ëŠ¥í•œ ì—°ì‚°ìë“¤
// public static T operator =(T a, T b)  // í• ë‹¹ ì—°ì‚°ì
// public static T operator .(T a, T b)  // ë©¤ë²„ ì ‘ê·¼ ì—°ì‚°ì
```

### Q3: ì—°ì‚°ì ì˜¤ë²„ë¡œë”©ê³¼ ë©”ì„œë“œ ì˜¤ë²„ë¡œë”©ì˜ ì°¨ì´ì ì€?
**A**: ì—°ì‚°ì ì˜¤ë²„ë¡œë”©ì€ ê¸°ì¡´ ì—°ì‚°ìì˜ ë™ì‘ì„ ì¬ì •ì˜í•˜ê³ , ë©”ì„œë“œ ì˜¤ë²„ë¡œë”©ì€ ê°™ì€ ì´ë¦„ì˜ ë©”ì„œë“œë¥¼ ì—¬ëŸ¬ ê°œ ì •ì˜í•©ë‹ˆë‹¤. ì´ëŠ” ë§ˆì¹˜ ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„ê³¼ ë©”ì„œë“œ ì˜¤ë²„ë¡œë”©ì˜ ì°¨ì´ì²˜ëŸ¼, ì„œë¡œ ë‹¤ë¥¸ ëª©ì ê³¼ ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ê°€ì§‘ë‹ˆë‹¤.

**ì—°ì‚°ì ì˜¤ë²„ë¡œë”©**ì€ `+`, `-`, `*`, `/` ë“±ì˜ ì—°ì‚°ì ë™ì‘ì„ ì¬ì •ì˜í•©ë‹ˆë‹¤. ì´ëŠ” ë§ˆì¹˜ ìˆ˜í•™ì  í‘œí˜„ì„ ì½”ë“œì—ì„œ ìì—°ìŠ¤ëŸ½ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•˜ëŠ” ê²ƒì²˜ëŸ¼, ë„ë©”ì¸ íŠ¹í™”ëœ ì—°ì‚°ì„ ì§ê´€ì ìœ¼ë¡œ í‘œí˜„í•  ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤.

**ë©”ì„œë“œ ì˜¤ë²„ë¡œë”©**ì€ ê°™ì€ ì´ë¦„ì˜ ë©”ì„œë“œë¥¼ ë§¤ê°œë³€ìˆ˜ë§Œ ë‹¤ë¥´ê²Œ ì •ì˜í•©ë‹ˆë‹¤. ì´ëŠ” ë§ˆì¹˜ ìƒì„±ì ì˜¤ë²„ë¡œë”©ì²˜ëŸ¼, ë‹¤ì–‘í•œ ë§¤ê°œë³€ìˆ˜ ì¡°í•©ì— ëŒ€í•´ ë™ì¼í•œ ê¸°ëŠ¥ì„ ì œê³µí•˜ëŠ” ë©”ì„œë“œë¥¼ ì •ì˜í•  ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤.

**ì‚¬ìš©ì„±**ì€ ì—°ì‚°ì ì˜¤ë²„ë¡œë”©ì´ ë” ì§ê´€ì ì´ê³  ìì—°ìŠ¤ëŸ½ìŠµë‹ˆë‹¤. ì´ëŠ” ë§ˆì¹˜ LINQì˜ ë©”ì„œë“œ ì²´ì´ë‹ì²˜ëŸ¼, ë„ë©”ì¸ ë¡œì§ì„ ìˆ˜í•™ì  í‘œí˜„ìœ¼ë¡œ ì§ê´€ì ìœ¼ë¡œ ì‘ì„±í•  ìˆ˜ ìˆì–´ ì½”ë“œì˜ ê°€ë…ì„±ì´ í¬ê²Œ í–¥ìƒë©ë‹ˆë‹¤.

**ì‹¤ì œ ì˜ˆì‹œ:**
```csharp
// ì—°ì‚°ì ì˜¤ë²„ë¡œë”©
public static int operator /(int a, Denominator b) => a / b._value;

// ë©”ì„œë“œ ì˜¤ë²„ë¡œë”©
public int Divide(int a) => a / _value;
public int Divide(double a) => (int)(a / _value);
```
