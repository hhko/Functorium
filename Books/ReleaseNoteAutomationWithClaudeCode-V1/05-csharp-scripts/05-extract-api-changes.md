# 5.5 ExtractApiChanges.cs 분석

> 이 절에서는 Public API를 추출하고 변경사항을 감지하는 ExtractApiChanges.cs 스크립트를 분석합니다.

---

## 개요

ExtractApiChanges.cs는 **Phase 2: 데이터 수집**에서 API 관련 데이터를 수집하는 스크립트입니다.

```txt
역할:
├── 프로젝트 빌드 (dotnet publish)
├── DLL에서 Public API 추출
├── Uber 파일 (all-api-changes.txt) 생성
├── API 변경 Git Diff 생성
└── 개별 .api/*.cs 파일 생성
```

---

## 파일 위치

```txt
.release-notes/scripts/ExtractApiChanges.cs
```

---

## 사용법

```bash
cd .release-notes/scripts
dotnet ExtractApiChanges.cs
```

인자가 필요 없습니다. 현재 디렉터리 기준으로 자동 탐색합니다.

---

## 스크립트 구조

### 1. 패키지 참조 및 using

```csharp
#!/usr/bin/env dotnet

#:package System.CommandLine@2.0.1
#:package Spectre.Console@0.54.0

using System;
using System.Collections.Generic;
using System.CommandLine;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Spectre.Console;
```

### 2. CLI 정의 (인자 없음)

```csharp
var rootCommand = new RootCommand("Extract API changes by building current branch");

rootCommand.SetAction(async (parseResult, cancellationToken) =>
{
    await ExtractApiChangesAsync();
    return 0;
});

return await rootCommand.Parse(args).InvokeAsync();
```

---

## 주요 로직

### Step 1: ApiGenerator 확인

API 생성에 필요한 ApiGenerator.cs 존재 확인:

```csharp
AnsiConsole.MarkupLine("[bold]Step 1[/] [dim]Locating ApiGenerator...[/]");
var apiGeneratorPath = Path.Combine(toolsDir, "ApiGenerator.cs");

if (!File.Exists(apiGeneratorPath))
{
    AnsiConsole.MarkupLine("[red]Error:[/] ApiGenerator.cs not found");
    Environment.Exit(1);
}
AnsiConsole.MarkupLine($"   [green]Found[/] [dim]{apiGeneratorPath}[/]");
```

### Step 2: 프로젝트 탐색

분석할 Functorium 프로젝트 파일 탐색:

```csharp
AnsiConsole.MarkupLine("[bold]Step 2[/] [dim]Finding Functorium projects...[/]");
var srcDir = Path.Combine(gitRoot, "Src");

var projectFiles = Directory.GetFiles(srcDir, "*.csproj", SearchOption.AllDirectories)
    .Where(p => !p.Contains(".Tests.") &&
                Path.GetFileName(p).StartsWith("Functorium"))
    .OrderByDescending(p => p)
    .ToList();

AnsiConsole.MarkupLine($"   [green]Found[/] [white]{projectFiles.Count}[/] projects");
```

### Step 3: 프로젝트 빌드 및 API 생성

각 프로젝트를 빌드하고 API를 추출합니다:

```csharp
foreach (var projectFile in projectFiles)
{
    var assemblyName = Path.GetFileNameWithoutExtension(projectFile);
    var publishDir = Path.Combine(projectDir, "bin", "publish");

    await AnsiConsole.Status()
        .Spinner(Spinner.Known.Dots)
        .StartAsync($"Publishing [cyan]{assemblyName}[/]...", async ctx =>
        {
            // 1. 프로젝트 빌드
            var publishResult = await RunProcessAsync(
                "dotnet",
                $"publish \"{projectFile}\" -c Release -o \"{publishDir}\""
            );

            if (publishResult.ExitCode != 0)
            {
                AnsiConsole.MarkupLine($"   [yellow]WARN[/] {assemblyName} - Publish failed");
                return;
            }

            // 2. ApiGenerator로 API 추출
            var dllPath = Path.Combine(publishDir, $"{assemblyName}.dll");
            var apiResult = await RunProcessAsync(
                "dotnet",
                $"\"{apiGeneratorPath}\" \"{dllPath}\" -"
            );

            // 3. API 파일 생성
            if (apiResult.ExitCode == 0 && !string.IsNullOrWhiteSpace(apiResult.Output))
            {
                var content = new StringBuilder();
                content.AppendLine("// <auto-generated>");
                content.AppendLine($"//     Assembly: {assemblyName}");
                content.AppendLine($"//     Generated at: {DateTime.Now}");
                content.AppendLine("// </auto-generated>");
                content.Append(apiResult.Output);

                await File.WriteAllTextAsync(outputFile, content.ToString());
                generatedApiFiles.Add(outputFile);
            }
        });
}
```

### Step 4: Uber 파일 생성

모든 API를 하나의 파일로 합칩니다:

```csharp
AnsiConsole.MarkupLine("[bold]Step 4[/] [dim]Creating Uber API file...[/]");

var uberContent = new StringBuilder();
uberContent.AppendLine("// All API Changes - Uber File");
uberContent.AppendLine($"// Generated: {DateTime.Now}");
uberContent.AppendLine();

foreach (var apiFile in generatedApiFiles)
{
    var assemblyName = Path.GetFileNameWithoutExtension(apiFile);
    uberContent.AppendLine($"// ═══════════════════════════════════════════");
    uberContent.AppendLine($"// Assembly: {assemblyName}");
    uberContent.AppendLine($"// ═══════════════════════════════════════════");
    uberContent.AppendLine();

    var content = await File.ReadAllTextAsync(apiFile);
    uberContent.AppendLine(content);
    uberContent.AppendLine();
}

var uberFilePath = Path.Combine(apiChangesDir, "all-api-changes.txt");
await File.WriteAllTextAsync(uberFilePath, uberContent.ToString());
```

### Step 5: Git Diff 생성

API 변경사항의 Git diff를 생성합니다:

```csharp
AnsiConsole.MarkupLine("[bold]Step 5[/] [dim]Generating API diff...[/]");

var diffResult = await RunProcessAsync(
    "git",
    $"diff HEAD -- \"Src/*/.api/*.cs\""
);

var diffFilePath = Path.Combine(apiChangesDir, "api-changes-diff.txt");
await File.WriteAllTextAsync(diffFilePath, diffResult.Output);

if (string.IsNullOrWhiteSpace(diffResult.Output))
{
    AnsiConsole.MarkupLine("   [dim]No API changes detected[/]");
}
else
{
    AnsiConsole.MarkupLine($"   [green]✓[/] Diff saved to api-changes-diff.txt");
}
```

---

## 출력 파일 구조

```txt
.analysis-output/api-changes-build-current/
├── all-api-changes.txt      # Uber 파일 (모든 API)
├── api-changes-summary.md   # API 요약
└── api-changes-diff.txt     # Git Diff

Src/
├── Functorium/.api/
│   └── Functorium.cs        # Functorium Public API
└── Functorium.Testing/.api/
    └── Functorium.Testing.cs # Testing Public API
```

### Uber 파일 예시

`all-api-changes.txt`:

```csharp
// All API Changes - Uber File
// Generated: 2025-12-19 10:30:00

// ═══════════════════════════════════════════
// Assembly: Functorium
// ═══════════════════════════════════════════

namespace Functorium.Abstractions.Errors
{
    public static class ErrorCodeFactory
    {
        public static LanguageExt.Common.Error Create(string errorCode, string errorCurrentValue, string errorMessage);
        public static LanguageExt.Common.Error Create<T>(string errorCode, T errorCurrentValue, string errorMessage) where T : notnull;
        public static LanguageExt.Common.Error CreateFromException(string errorCode, System.Exception exception);
    }
}

// ═══════════════════════════════════════════
// Assembly: Functorium.Testing
// ═══════════════════════════════════════════

namespace Functorium.Testing.Arrangements.Hosting
{
    public class HostTestFixture<TProgram> : System.IAsyncDisposable where TProgram : class
    {
        public System.Net.Http.HttpClient Client { get; }
        public System.IServiceProvider Services { get; }
    }
}
```

### API Diff 예시

`api-changes-diff.txt`:

```diff
diff --git a/Src/Functorium/.api/Functorium.cs b/Src/Functorium/.api/Functorium.cs
index abc1234..def5678 100644
--- a/Src/Functorium/.api/Functorium.cs
+++ b/Src/Functorium/.api/Functorium.cs
@@ -10,6 +10,7 @@ namespace Functorium.Abstractions.Errors
     public static class ErrorCodeFactory
     {
         public static Error Create(string errorCode, string errorCurrentValue, string errorMessage);
+        public static Error CreateFromException(string errorCode, Exception exception);
     }
 }
```

---

## 주요 함수

### RunProcessAsync

외부 프로세스 실행:

```csharp
static async Task<ProcessResult> RunProcessAsync(string command, string arguments, bool quiet = false)
{
    var process = new Process
    {
        StartInfo = new ProcessStartInfo
        {
            FileName = command,
            Arguments = arguments,
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true
        }
    };

    var output = new StringBuilder();
    var error = new StringBuilder();

    process.OutputDataReceived += (s, e) => { if (e.Data != null) output.AppendLine(e.Data); };
    process.ErrorDataReceived += (s, e) => { if (e.Data != null) error.AppendLine(e.Data); };

    process.Start();
    process.BeginOutputReadLine();
    process.BeginErrorReadLine();
    await process.WaitForExitAsync();

    return new ProcessResult
    {
        ExitCode = process.ExitCode,
        Output = output.ToString(),
        Error = error.ToString()
    };
}
```

### GetCurrentBranchAsync

현재 브랜치 이름 가져오기:

```csharp
static async Task<string> GetCurrentBranchAsync()
{
    var result = await RunProcessAsync("git", "rev-parse --abbrev-ref HEAD", quiet: true);
    return result.Output.Trim();
}
```

---

## 콘솔 출력

```txt
━━━━━━━━━━━━ Extracting API Changes ━━━━━━━━━━━━

╭──────────┬─────────────────────────────╮
│ Property │ Value                       │
├──────────┼─────────────────────────────┤
│ Branch   │ main                        │
│ Output   │ .analysis-output/...        │
│ Timestamp│ 2025-12-19 10:30:00         │
╰──────────┴─────────────────────────────╯

Step 1 Locating ApiGenerator...
   Found .release-notes/scripts/ApiGenerator.cs

Step 2 Finding Functorium projects...
   Found 2 projects

Step 3 Publishing projects and generating API files...
   ✓ Functorium
   ✓ Functorium.Testing

Step 4 Creating Uber API file...
   ✓ all-api-changes.txt (2 assemblies)

Step 5 Generating API diff...
   ✓ Diff saved to api-changes-diff.txt

━━━━━━━━━━━━ API Extraction Complete ━━━━━━━━━━━━
```

---

## ApiGenerator.cs 연동

ExtractApiChanges.cs는 내부적으로 ApiGenerator.cs를 호출합니다:

```txt
ExtractApiChanges.cs
     │
     ├─▶ dotnet publish (프로젝트 빌드)
     │         │
     │         └─▶ bin/publish/Assembly.dll
     │
     └─▶ dotnet ApiGenerator.cs <dll-path>
               │
               └─▶ Public API 텍스트 출력
```

ApiGenerator.cs는 PublicApiGenerator 라이브러리를 사용하여 DLL에서 Public API를 추출합니다.

---

## 오류 처리

### 빌드 실패

```csharp
if (publishResult.ExitCode != 0)
{
    AnsiConsole.MarkupLine($"   [yellow]WARN[/] [dim]{assemblyName}[/] - Publish failed, skipping");
    return;
}
```

### DLL 없음

```csharp
var dllPath = Path.Combine(publishDir, $"{assemblyName}.dll");
if (!File.Exists(dllPath))
{
    AnsiConsole.MarkupLine($"   [yellow]WARN[/] [dim]{assemblyName}[/] - DLL not found");
    return;
}
```

---

## 요약

| 항목 | 설명 |
|------|------|
| 목적 | Public API 추출 및 변경사항 감지 |
| 입력 | 없음 (자동 탐색) |
| 출력 | Uber 파일, API Diff, 개별 .api/*.cs |
| 의존성 | ApiGenerator.cs |
| 패키지 | System.CommandLine, Spectre.Console |

---

## 다음 단계

- [5.6 ApiGenerator.cs 분석](06-api-generator.md)
