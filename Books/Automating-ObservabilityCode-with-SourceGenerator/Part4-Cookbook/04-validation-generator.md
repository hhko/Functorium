# Validation 생성기

## 학습 목표

- DataAnnotations와 FluentValidation의 관계 이해
- Primary Constructor 파라미터의 속성 추출 방법
- 검증 규칙 매핑 및 코드 생성

---

## 왜 Validation 생성기인가?

### 문제: 중복되는 검증 코드

```csharp
// DTO 정의 (DataAnnotations)
public record CreateUserRequest(
    [Required, MaxLength(100)] string Name,
    [Required, EmailAddress] string Email,
    [Range(1, 150)] int Age);

// FluentValidation (수동 작성 필요)
public class CreateUserRequestValidator : AbstractValidator<CreateUserRequest>
{
    public CreateUserRequestValidator()
    {
        // DataAnnotations와 동일한 내용을 다시 작성해야 함
        RuleFor(x => x.Name).NotEmpty().MaximumLength(100);
        RuleFor(x => x.Email).NotEmpty().EmailAddress();
        RuleFor(x => x.Age).InclusiveBetween(1, 150);
    }
}
```

### 해결: 자동 생성

```csharp
// DTO 정의만 하면
[GenerateValidator]
public record CreateUserRequest(
    [Required, MaxLength(100)] string Name,
    [Required, EmailAddress] string Email,
    [Range(1, 150)] int Age);

// Validator가 자동 생성됨!
```

---

## 목표: 자동 생성할 코드

### 입력

```csharp
using MyCompany.SourceGenerator;
using System.ComponentModel.DataAnnotations;

namespace MyApp.Application.Commands;

[GenerateValidator]
public record CreateUserRequest(
    [Required, MaxLength(100)] string Name,
    [Required, EmailAddress] string Email,
    [Range(1, 150)] int Age,
    [Phone] string? PhoneNumber);
```

### 생성 결과

```csharp
// <auto-generated/>
#nullable enable

using FluentValidation;

namespace MyApp.Application.Commands;

/// <summary>
/// CreateUserRequest에 대한 FluentValidation Validator
/// </summary>
[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(
    Justification = "Generated by source generator.")]
public sealed class CreateUserRequestValidator : AbstractValidator<CreateUserRequest>
{
    public CreateUserRequestValidator()
    {
        // Name: Required, MaxLength(100)
        RuleFor(x => x.Name)
            .NotEmpty()
            .MaximumLength(100);

        // Email: Required, EmailAddress
        RuleFor(x => x.Email)
            .NotEmpty()
            .EmailAddress();

        // Age: Range(1, 150)
        RuleFor(x => x.Age)
            .InclusiveBetween(1, 150);

        // PhoneNumber: Phone (nullable)
        RuleFor(x => x.PhoneNumber)
            .Matches(@"^[\d\-\+\(\)\s]+$")
            .When(x => x.PhoneNumber is not null);
    }
}
```

---

## DataAnnotations → FluentValidation 매핑

### 지원하는 속성

| DataAnnotations | FluentValidation | 설명 |
|-----------------|------------------|------|
| `[Required]` | `.NotEmpty()` | 필수 값 |
| `[MaxLength(n)]` | `.MaximumLength(n)` | 최대 길이 |
| `[MinLength(n)]` | `.MinimumLength(n)` | 최소 길이 |
| `[StringLength(max, Min=min)]` | `.Length(min, max)` | 길이 범위 |
| `[Range(min, max)]` | `.InclusiveBetween(min, max)` | 숫자 범위 |
| `[EmailAddress]` | `.EmailAddress()` | 이메일 형식 |
| `[Phone]` | `.Matches(phoneRegex)` | 전화번호 형식 |
| `[Url]` | `.Must(Uri.IsWellFormedUriString)` | URL 형식 |
| `[RegularExpression(pattern)]` | `.Matches(pattern)` | 정규식 |
| `[Compare(otherProperty)]` | `.Equal(x => x.OtherProperty)` | 값 비교 |

---

## 구현

### 1. 메타데이터 클래스

```csharp
// ValidationInfo.cs
namespace MyCompany.SourceGenerator;

/// <summary>
/// Validator 생성에 필요한 메타데이터
/// </summary>
public sealed record ValidationInfo(
    string TypeName,
    string Namespace,
    IReadOnlyList<PropertyValidation> Properties);

public sealed record PropertyValidation(
    string PropertyName,
    string PropertyType,
    bool IsNullable,
    IReadOnlyList<ValidationRule> Rules);

public sealed record ValidationRule(
    ValidationRuleType Type,
    IReadOnlyDictionary<string, object?> Arguments);

public enum ValidationRuleType
{
    Required,
    MaxLength,
    MinLength,
    StringLength,
    Range,
    EmailAddress,
    Phone,
    Url,
    RegularExpression,
    Compare
}
```

### 2. 마커 속성 정의

```csharp
// GenerateValidatorAttribute.cs
namespace MyCompany.SourceGenerator;

internal static class GenerateValidatorAttribute
{
    public const string Source = """
        // <auto-generated/>
        #nullable enable

        namespace MyCompany.SourceGenerator;

        /// <summary>
        /// FluentValidation Validator를 자동 생성합니다.
        /// DataAnnotations 속성을 FluentValidation 규칙으로 변환합니다.
        /// </summary>
        [global::System.AttributeUsage(
            global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct,
            AllowMultiple = false,
            Inherited = false)]
        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(
            Justification = "Generated by source generator.")]
        public sealed class GenerateValidatorAttribute : global::System.Attribute;
        """;

    public const string FullyQualifiedName = "MyCompany.SourceGenerator.GenerateValidatorAttribute";
}
```

### 3. 심볼 분석: Primary Constructor 파라미터 속성 추출

```csharp
// ValidationAnalyzer.cs
private static IReadOnlyList<PropertyValidation> ExtractPropertyValidations(
    INamedTypeSymbol typeSymbol)
{
    var properties = new List<PropertyValidation>();

    // Primary Constructor 파라미터 분석
    var primaryConstructor = typeSymbol.Constructors
        .FirstOrDefault(c => c.Parameters.Length > 0 &&
            c.DeclaringSyntaxReferences.Any(r =>
                r.GetSyntax() is RecordDeclarationSyntax or
                    ClassDeclarationSyntax { ParameterList: not null }));

    if (primaryConstructor is not null)
    {
        foreach (var param in primaryConstructor.Parameters)
        {
            var rules = ExtractValidationRules(param);
            if (rules.Count > 0)
            {
                properties.Add(new PropertyValidation(
                    PropertyName: ToPascalCase(param.Name),
                    PropertyType: param.Type.ToDisplayString(),
                    IsNullable: param.Type.NullableAnnotation == NullableAnnotation.Annotated,
                    Rules: rules));
            }
        }
    }

    // 일반 프로퍼티 분석
    foreach (var property in typeSymbol.GetMembers().OfType<IPropertySymbol>())
    {
        // Primary Constructor로 이미 처리된 경우 스킵
        if (properties.Any(p => p.PropertyName == property.Name))
            continue;

        var rules = ExtractValidationRules(property);
        if (rules.Count > 0)
        {
            properties.Add(new PropertyValidation(
                PropertyName: property.Name,
                PropertyType: property.Type.ToDisplayString(),
                IsNullable: property.Type.NullableAnnotation == NullableAnnotation.Annotated,
                Rules: rules));
        }
    }

    return properties;
}

private static IReadOnlyList<ValidationRule> ExtractValidationRules(ISymbol symbol)
{
    var rules = new List<ValidationRule>();

    foreach (var attribute in symbol.GetAttributes())
    {
        var attrName = attribute.AttributeClass?.Name;

        var rule = attrName switch
        {
            "RequiredAttribute" => new ValidationRule(
                ValidationRuleType.Required,
                new Dictionary<string, object?>()),

            "MaxLengthAttribute" => new ValidationRule(
                ValidationRuleType.MaxLength,
                new Dictionary<string, object?>
                {
                    ["Length"] = attribute.ConstructorArguments[0].Value
                }),

            "MinLengthAttribute" => new ValidationRule(
                ValidationRuleType.MinLength,
                new Dictionary<string, object?>
                {
                    ["Length"] = attribute.ConstructorArguments[0].Value
                }),

            "StringLengthAttribute" => new ValidationRule(
                ValidationRuleType.StringLength,
                new Dictionary<string, object?>
                {
                    ["MaximumLength"] = attribute.ConstructorArguments[0].Value,
                    ["MinimumLength"] = attribute.NamedArguments
                        .FirstOrDefault(a => a.Key == "MinimumLength").Value.Value ?? 0
                }),

            "RangeAttribute" => new ValidationRule(
                ValidationRuleType.Range,
                new Dictionary<string, object?>
                {
                    ["Minimum"] = attribute.ConstructorArguments[0].Value,
                    ["Maximum"] = attribute.ConstructorArguments[1].Value
                }),

            "EmailAddressAttribute" => new ValidationRule(
                ValidationRuleType.EmailAddress,
                new Dictionary<string, object?>()),

            "PhoneAttribute" => new ValidationRule(
                ValidationRuleType.Phone,
                new Dictionary<string, object?>()),

            "UrlAttribute" => new ValidationRule(
                ValidationRuleType.Url,
                new Dictionary<string, object?>()),

            "RegularExpressionAttribute" => new ValidationRule(
                ValidationRuleType.RegularExpression,
                new Dictionary<string, object?>
                {
                    ["Pattern"] = attribute.ConstructorArguments[0].Value
                }),

            "CompareAttribute" => new ValidationRule(
                ValidationRuleType.Compare,
                new Dictionary<string, object?>
                {
                    ["OtherProperty"] = attribute.ConstructorArguments[0].Value
                }),

            _ => null
        };

        if (rule is not null)
            rules.Add(rule);
    }

    return rules;
}
```

### 4. 코드 생성

```csharp
// ValidationCodeGenerator.cs
private static string GenerateValidatorSource(ValidationInfo info)
{
    var sb = new StringBuilder();

    // 헤더
    sb.AppendLine("// <auto-generated/>");
    sb.AppendLine("#nullable enable");
    sb.AppendLine();

    // using 문
    sb.AppendLine("using FluentValidation;");
    sb.AppendLine();

    // 네임스페이스
    sb.AppendLine($"namespace {info.Namespace};");
    sb.AppendLine();

    // 클래스 설명
    sb.AppendLine($"/// <summary>");
    sb.AppendLine($"/// {info.TypeName}에 대한 FluentValidation Validator");
    sb.AppendLine($"/// </summary>");
    sb.AppendLine("[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(");
    sb.AppendLine("    Justification = \"Generated by source generator.\")]");

    // 클래스 선언
    sb.AppendLine($"public sealed class {info.TypeName}Validator : AbstractValidator<{info.TypeName}>");
    sb.AppendLine("{");

    // 생성자
    sb.AppendLine($"    public {info.TypeName}Validator()");
    sb.AppendLine("    {");

    foreach (var property in info.Properties)
    {
        GeneratePropertyRules(sb, property);
    }

    sb.AppendLine("    }");
    sb.AppendLine("}");

    return sb.ToString();
}

private static void GeneratePropertyRules(StringBuilder sb, PropertyValidation property)
{
    // 주석
    var ruleNames = string.Join(", ", property.Rules.Select(r => r.Type.ToString()));
    sb.AppendLine($"        // {property.PropertyName}: {ruleNames}");

    // RuleFor 시작
    sb.Append($"        RuleFor(x => x.{property.PropertyName})");

    foreach (var rule in property.Rules)
    {
        sb.AppendLine();
        sb.Append("            ");
        sb.Append(GenerateRule(rule, property));
    }

    // Nullable 처리
    if (property.IsNullable && !property.Rules.Any(r => r.Type == ValidationRuleType.Required))
    {
        sb.AppendLine();
        sb.Append($"            .When(x => x.{property.PropertyName} is not null)");
    }

    sb.AppendLine(";");
    sb.AppendLine();
}

private static string GenerateRule(ValidationRule rule, PropertyValidation property)
{
    return rule.Type switch
    {
        ValidationRuleType.Required => ".NotEmpty()",

        ValidationRuleType.MaxLength =>
            $".MaximumLength({rule.Arguments["Length"]})",

        ValidationRuleType.MinLength =>
            $".MinimumLength({rule.Arguments["Length"]})",

        ValidationRuleType.StringLength =>
            $".Length({rule.Arguments["MinimumLength"]}, {rule.Arguments["MaximumLength"]})",

        ValidationRuleType.Range =>
            $".InclusiveBetween({rule.Arguments["Minimum"]}, {rule.Arguments["Maximum"]})",

        ValidationRuleType.EmailAddress =>
            ".EmailAddress()",

        ValidationRuleType.Phone =>
            ".Matches(@\"^[\\d\\-\\+\\(\\)\\s]+$\").WithMessage(\"Invalid phone number format\")",

        ValidationRuleType.Url =>
            ".Must(uri => global::System.Uri.IsWellFormedUriString(uri, global::System.UriKind.Absolute)).WithMessage(\"Invalid URL format\")",

        ValidationRuleType.RegularExpression =>
            $".Matches(@\"{rule.Arguments["Pattern"]}\")",

        ValidationRuleType.Compare =>
            $".Equal(x => x.{rule.Arguments["OtherProperty"]})",

        _ => ""
    };
}
```

---

## 고급 기능

### 중첩 객체 검증

```csharp
// 입력
[GenerateValidator]
public record CreateOrderRequest(
    [Required] OrderId OrderId,
    [Required] Address ShippingAddress,  // 중첩 객체
    [Required] List<OrderItem> Items);   // 컬렉션

[GenerateValidator]
public record Address(
    [Required, MaxLength(200)] string Street,
    [Required, MaxLength(100)] string City);

// 생성 결과
public sealed class CreateOrderRequestValidator : AbstractValidator<CreateOrderRequest>
{
    public CreateOrderRequestValidator()
    {
        RuleFor(x => x.OrderId).NotEmpty();

        // 중첩 객체는 해당 Validator 사용
        RuleFor(x => x.ShippingAddress)
            .NotEmpty()
            .SetValidator(new AddressValidator());

        // 컬렉션은 각 항목에 대해 검증
        RuleFor(x => x.Items)
            .NotEmpty()
            .ForEach(item => item.SetValidator(new OrderItemValidator()));
    }
}
```

### 커스텀 검증 규칙

```csharp
// 커스텀 속성 정의
[AttributeUsage(AttributeTargets.Property | AttributeTargets.Parameter)]
public class FutureDateAttribute : ValidationAttribute
{
    public override bool IsValid(object? value)
    {
        if (value is DateTime date)
            return date > DateTime.Now;
        return false;
    }
}

// 사용
[GenerateValidator]
public record CreateEventRequest(
    [Required] string Title,
    [FutureDate] DateTime EventDate);

// 생성 결과 (커스텀 규칙은 Must로 변환)
public sealed class CreateEventRequestValidator : AbstractValidator<CreateEventRequest>
{
    public CreateEventRequestValidator()
    {
        RuleFor(x => x.Title).NotEmpty();

        RuleFor(x => x.EventDate)
            .Must(date => date > global::System.DateTime.Now)
            .WithMessage("Event date must be in the future");
    }
}
```

---

## 테스트

### 기본 검증 테스트

```csharp
[Fact]
public Task ValidationGenerator_ShouldGenerate_BasicValidator()
{
    // Arrange
    string input = """
        using MyCompany.SourceGenerator;
        using System.ComponentModel.DataAnnotations;

        namespace TestNamespace;

        [GenerateValidator]
        public record CreateUserRequest(
            [Required, MaxLength(100)] string Name,
            [Required, EmailAddress] string Email);
        """;

    // Act
    string? actual = _sut.Generate(input);

    // Assert
    return Verify(actual);
}
```

### Range 속성 테스트

```csharp
[Fact]
public Task ValidationGenerator_ShouldGenerate_RangeValidation()
{
    // Arrange
    string input = """
        using MyCompany.SourceGenerator;
        using System.ComponentModel.DataAnnotations;

        namespace TestNamespace;

        [GenerateValidator]
        public record ProductRequest(
            [Required] string Name,
            [Range(0.01, 999999.99)] decimal Price,
            [Range(0, 10000)] int Stock);
        """;

    // Act
    string? actual = _sut.Generate(input);

    // Assert
    return Verify(actual);
}
```

### Nullable 속성 테스트

```csharp
[Fact]
public Task ValidationGenerator_ShouldGenerate_NullableValidation()
{
    // Arrange
    string input = """
        using MyCompany.SourceGenerator;
        using System.ComponentModel.DataAnnotations;

        namespace TestNamespace;

        [GenerateValidator]
        public record UpdateUserRequest(
            [MaxLength(100)] string? Name,
            [EmailAddress] string? Email,
            [Phone] string? PhoneNumber);
        """;

    // Act
    string? actual = _sut.Generate(input);

    // Assert
    return Verify(actual);
}
```

---

## 사용 예시

### ASP.NET Core 통합

```csharp
// Program.cs
builder.Services.AddValidatorsFromAssemblyContaining<CreateUserRequestValidator>();

// 또는 자동 등록 확장 메서드 사용
builder.Services.AddGeneratedValidators();
```

### MediatR 파이프라인과 함께 사용

```csharp
// ValidationBehavior.cs
public sealed class ValidationBehavior<TRequest, TResponse>
    : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
{
    private readonly IEnumerable<IValidator<TRequest>> _validators;

    public ValidationBehavior(IEnumerable<IValidator<TRequest>> validators)
    {
        _validators = validators;
    }

    public async Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken)
    {
        if (_validators.Any())
        {
            var context = new ValidationContext<TRequest>(request);

            var validationResults = await Task.WhenAll(
                _validators.Select(v => v.ValidateAsync(context, cancellationToken)));

            var failures = validationResults
                .SelectMany(r => r.Errors)
                .Where(f => f != null)
                .ToList();

            if (failures.Count != 0)
                throw new ValidationException(failures);
        }

        return await next();
    }
}
```

---

## 요약

| 항목 | 설명 |
|------|------|
| **목적** | DataAnnotations → FluentValidation 자동 변환 |
| **대상** | `[GenerateValidator]` 속성이 붙은 record/class |
| **분석** | Primary Constructor 파라미터 + 프로퍼티 속성 |
| **지원 속성** | Required, MaxLength, MinLength, Range, EmailAddress, Phone, Url, RegularExpression, Compare |
| **고급 기능** | 중첩 객체, 컬렉션, 커스텀 규칙 |

---

## 다음 단계

다음 섹션에서는 새로운 소스 생성기 프로젝트를 시작하기 위한 템플릿을 제공합니다.

➡️ [05. 커스텀 생성기 템플릿](05-custom-generator-template.md)
