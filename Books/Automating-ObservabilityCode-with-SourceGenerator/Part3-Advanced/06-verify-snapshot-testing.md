# Verify 스냅샷 테스트

## 학습 목표

- Verify 라이브러리 이해
- .verified.txt 파일 관리
- 스냅샷 테스트 워크플로우

---

## 스냅샷 테스트란?

**스냅샷 테스트**는 출력 결과를 파일로 저장하고 이후 테스트에서 비교하는 방식입니다.

```
첫 번째 실행
============
입력 → 생성 → 결과 저장 (*.verified.txt)

이후 실행
=========
입력 → 생성 → 저장된 결과와 비교
                  │
                  ├─ 일치 → 테스트 통과
                  │
                  └─ 불일치 → 테스트 실패
                       │
                       └─ *.received.txt 생성 (비교용)
```

---

## Verify 라이브러리

### 설치

```xml
<PackageReference Include="Verify.Xunit" Version="28.9.2" />
```

### 기본 사용법

```csharp
using VerifyXunit;

[UsesVerify]
public class MyTests
{
    [Fact]
    public Task Should_Generate_Expected_Output()
    {
        string result = GenerateSomething();

        return Verify(result);
    }
}
```

### 소스 생성기 테스트에서 사용

```csharp
[Fact]
public Task Should_Generate_PipelineClass()
{
    string input = """
        [GeneratePipeline]
        public class TestAdapter : IAdapter
        {
            public virtual FinT<IO, int> GetValue() => FinT<IO, int>.Succ(42);
        }
        """;

    string? actual = _sut.Generate(input);

    // 생성된 코드를 스냅샷과 비교
    return Verify(actual);
}
```

---

## .verified.txt 파일

### 파일 명명 규칙

```
{TestClassName}.{TestMethodName}.verified.txt

예시:
AdapterPipelineGeneratorTests.AdapterPipelineGenerator_ShouldGenerate_PipelineClass_WithSingleMethod.verified.txt
```

### 파일 내용

```csharp
// AdapterPipelineGeneratorTests.*.verified.txt
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by source generator
//
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

using Functorium.Abstractions;
using Functorium.Applications.Observabilities;

using LanguageExt;
using Microsoft.Extensions.Logging;
using System.Diagnostics;

namespace TestNamespace;

public class TestAdapterPipeline : TestAdapter
{
    private readonly ActivityContext _parentContext;
    private readonly ILogger<TestAdapterPipeline> _logger;
    // ... 생성된 전체 코드
}
```

---

## 테스트 워크플로우

### 1. 새 테스트 작성

```csharp
[Fact]
public Task Should_Generate_NewFeature()
{
    string input = """
        // 새로운 시나리오 입력
        """;

    string? actual = _sut.Generate(input);

    return Verify(actual);
}
```

### 2. 첫 실행 - 실패

```
[xUnit.net 00:00:01.23]     Should_Generate_NewFeature [FAIL]

  Verify returned:
  - Received: ...NewFeature.received.txt
  - Verified: ...NewFeature.verified.txt (not found)
```

### 3. received.txt 검토

```bash
# 생성된 파일 확인
cat Tests/.../Should_Generate_NewFeature.received.txt
```

### 4. 승인 (Approve)

```bash
# received.txt를 verified.txt로 이름 변경
mv *.received.txt *.verified.txt

# 또는 도구 사용
dotnet tool run verify.tool accept
```

### 5. 이후 실행 - 통과

```
[xUnit.net 00:00:01.23]     Should_Generate_NewFeature [PASS]
```

---

## 변경 감지

### 의도적 변경

소스 생성기를 수정하면 출력이 변경됩니다.

```csharp
// 변경 전
sb.AppendLine("    private readonly ActivityContext _parentContext;");

// 변경 후
sb.AppendLine("    private readonly ActivityContext _activityContext;");
```

### 테스트 결과

```
[xUnit.net 00:00:01.23]     Should_Generate_PipelineClass [FAIL]

  Verify mismatch:
  - Received: _activityContext
  - Verified: _parentContext
```

### Diff 도구로 비교

```bash
# diff 도구 사용
diff *.verified.txt *.received.txt

# Visual Studio Code
code --diff *.verified.txt *.received.txt
```

### 변경 승인

```bash
# 의도적 변경이면 새 버전 승인
mv *.received.txt *.verified.txt
```

---

## 소스 제어 통합

### .verified.txt 커밋

```bash
# verified.txt 파일은 반드시 커밋
git add *.verified.txt
git commit -m "test: update verified snapshots"
```

### .received.txt 무시

```gitignore
# .gitignore
*.received.txt
*.received/
```

### CI에서 검증

```yaml
# CI 파이프라인
steps:
  - run: dotnet test
    # 스냅샷 불일치 시 CI 실패
```

---

## 실제 테스트 예시

### 단일 메서드 테스트

```csharp
[Fact]
public Task AdapterPipelineGenerator_ShouldGenerate_PipelineClass_WithSingleMethod()
{
    string input = """
        using Functorium.Adapters.SourceGenerator;
        using Functorium.Applications.Observabilities;
        using LanguageExt;

        namespace TestNamespace;

        public interface ITestAdapter : IAdapter
        {
            FinT<IO, int> GetValue();
        }

        [GeneratePipeline]
        public class TestAdapter : ITestAdapter
        {
            public string RequestCategory => "Test";
            public virtual FinT<IO, int> GetValue() => FinT<IO, int>.Succ(42);
        }
        """;

    string? actual = _sut.Generate(input);

    return Verify(actual);
}
```

### 해당 .verified.txt 파일

```
// TestNamespace/TestAdapterPipeline.g.cs
// 파일명: TestAdapter.Pipeline.g.cs

public class TestAdapterPipeline : TestAdapter
{
    private readonly ActivityContext _parentContext;
    private readonly ILogger<TestAdapterPipeline> _logger;
    private readonly IAdapterTrace _adapterTrace;
    private readonly IAdapterMetric _adapterMetric;

    // ... 전체 생성된 코드
}
```

---

## 테스트 파일 구조

```
Tests/Functorium.Tests.Unit/
└── AdaptersTests/
    └── SourceGenerators/
        ├── AdapterPipelineGeneratorTests.cs
        │
        │   // .verified.txt 파일들 (27개)
        ├── AdapterPipelineGeneratorTests.*.WithSingleMethod.verified.txt
        ├── AdapterPipelineGeneratorTests.*.WithMultipleMethods.verified.txt
        ├── AdapterPipelineGeneratorTests.*.WithPrimaryConstructor.verified.txt
        └── ...
```

---

## 장점과 주의점

### 장점

| 장점 | 설명 |
|------|------|
| 전체 출력 검증 | 생성된 코드 전체를 검증 |
| 변경 추적 | Git으로 변경 이력 관리 |
| 리팩토링 안전성 | 의도치 않은 변경 즉시 감지 |
| 문서화 | verified.txt가 예상 출력 문서 역할 |

### 주의점

| 주의점 | 해결 방법 |
|--------|----------|
| 파일 수 증가 | 테스트별 하나씩 필요 |
| 비결정적 출력 | 결정적 출력 보장 필수 |
| 리뷰 복잡도 | PR에서 변경된 파일 검토 필요 |

---

## 베스트 프랙티스

### 1. 테스트 이름 명확하게

```csharp
// ✅ 좋은 예
public Task Should_Generate_PipelineClass_WithPrimaryConstructor()

// ❌ 나쁜 예
public Task Test1()
```

### 2. 하나의 시나리오만 테스트

```csharp
// ✅ 좋은 예 - 한 가지만 테스트
[Fact]
public Task Should_Generate_Count_ForCollectionParameter() { }

[Fact]
public Task Should_Generate_Length_ForArrayParameter() { }

// ❌ 나쁜 예 - 여러 가지 혼합
[Fact]
public Task Should_Generate_CountAndLength() { }
```

### 3. 입력 최소화

```csharp
// ✅ 좋은 예 - 테스트에 필요한 최소 코드
string input = """
    [GeneratePipeline]
    public class TestAdapter : IAdapter
    {
        public virtual FinT<IO, List<int>> GetItems() => ...;
    }
    """;

// ❌ 나쁜 예 - 불필요한 코드 포함
string input = """
    // 불필요한 주석
    public interface IOtherInterface { }  // 테스트와 무관

    [GeneratePipeline]
    public class TestAdapter : IAdapter
    {
        private readonly string _unused;  // 테스트와 무관
        public virtual FinT<IO, List<int>> GetItems() => ...;
    }
    """;
```

---

## 요약

| 개념 | 설명 |
|------|------|
| `.verified.txt` | 승인된 예상 출력 |
| `.received.txt` | 최신 실행 결과 (비교용) |
| 워크플로우 | 실행 → 비교 → 승인/수정 |
| 소스 제어 | verified만 커밋, received 무시 |

---

## 다음 단계

다음 섹션에서는 테스트 시나리오 카탈로그를 학습합니다.

➡️ [03. 테스트 시나리오](03-test-scenarios.md)
