# 작성 가이드라인 및 템플릿 구조

## 템플릿 구조 요구사항

다음 구조를 따르세요:

1. **프론트매터** (제목, 설명, 날짜가 포함된 YAML 헤더)
2. **메인 제목** (`# Functorium {version} 새로운 기능`)
3. **소개** - 지원되는 .NET 버전 및 피드백 링크 포함
4. **주요 섹션** (선택적으로 이모지 헤더 사용)
5. **코드 예시** - 적절한 구문 강조 표시
6. **브레이킹 체인지** 섹션 (해당되는 경우)
7. **마이그레이션 가이드** - 브레이킹 체인지용

### 예시 템플릿 구조

```markdown
---
title: Functorium {version} 새로운 기능
description: Functorium {version}의 새로운 기능을 알아봅니다.
date: {date}
---

# Functorium {version} 새로운 기능

Functorium {version}은 다음 주요 버전 릴리스입니다...

## 핵심 기능 개선
### 기능 이름
[설명 및 코드 샘플]

## 개발자 경험 개선
[개선사항 및 예시]
```

## 핵심 문서화 규칙

### 1. **포괄적인 분석**

- `analysis-output/`의 모든 컴포넌트 분석 파일 검토
- 각 파일의 모든 커밋 검토하여 변경 범위 이해
- `api-changes-summary.md`를 사용하여 새 API 추가 및 변경 식별
- 컴포넌트 간 주요 기능 및 테마 요약

### 2. **샘플이 포함된 API 변경**

- 모든 API 변경에 코드 샘플 포함
- 코드 샘플 작성 전 Uber 파일 검색
- 표시된 대로 매개변수 이름과 타입 정확히 일치
- diff에서 찾은 브레이킹 체인지에 대한 마이그레이션 단계 표시
- API가 존재한다고 발명하거나 가정하지 않음

### 3. **스타일 및 구조**

- 일관된 문서 구조 유지: 프론트매터, 소개, 주요 섹션
- 능동태와 개발자 중심 언어 사용
- 코드 요소는 백틱으로 포맷: `ErrorCodeFactory`, `CreateFromException()`
- API를 처음 참조하거나 새 API인 경우 문서 링크 제공
- 영향별로 구성: 브레이킹 체인지, 주요 기능, 개선사항

## 작성 스타일 가이드라인

### 언어 및 톤

- **능동태 사용**: "이제 오류를 생성할 수 있습니다" - "오류가 생성될 수 있습니다" 대신
- **개발자 중심**: 실용적인 예시로 개발자 대상 작성
- **명확하고 간결하게**: 불필요한 전문 용어나 장황한 설명 피하기
- **행동 지향적**: 개발자가 새 기능으로 무엇을 할 수 있는지에 초점

### 코드 포맷팅

- **적절한 구문 강조 사용**: 항상 언어 지정 (```csharp, ```bash, ```json)
- **완전한 예시 포함**: 가능하면 전체, 작동하는 코드 샘플 표시
- **새 기능 강조**: `// ✨ 새 기능`과 같은 주석으로 변경 강조
- **일관성 유지**: 전체에서 동일한 변수 이름과 패턴 사용

### 섹션 구성

- **가장 영향력 있는 변경부터 시작**: 브레이킹 체인지 먼저, 그 다음 주요 기능
- **관련 기능 그룹화**: 유사한 기능을 통합 섹션으로 결합
- **설명적인 제목 사용**: 스캔하고 특정 개선사항을 찾기 쉽게
- **마이그레이션 가이드 포함**: 브레이킹 체인지에 대해 기존 코드 업데이트 방법 항상 표시

## 선택적 이모지 사용 가이드라인

필요한 경우 다음 이모지 패턴 사용:

- **✨** - 새 기능 및 능력
- **🔧** - 구성 및 설정 개선
- **⚠️** - 브레이킹 체인지 및 중요 공지
- **📊** - 로깅 및 관찰성 기능
- **🛡️** - 오류 처리 및 유효성 검사

## 예시 기능 문서화

### 완전한 예시: 새 기능

```markdown
### 예외에서 구조화된 오류 생성

Functorium은 이제 예외를 구조화된 오류 코드로 쉽게 변환하는 기능을 제공합니다.

```csharp
try
{
    await SomeOperationAsync();
}
catch (HttpRequestException ex)
{
    // 예외에서 구조화된 오류 생성
    var error = ErrorCodeFactory.CreateFromException("HTTP_001", ex);

    // 오류 정보가 자동으로 보존됨
    Log.Error("요청 실패: {@Error}", error);

    return Fin<Response>.Fail(error);
}
```

이 통합으로 예외 처리가 간소화되어 인프라 설정 대신 비즈니스 로직에 집중할 수 있습니다.
```

### 완전한 예시: 브레이킹 체인지

```markdown
### 오류 핸들러 인터페이스 이름 변경

오류 처리 API가 더 나은 일관성을 위해 통합되었습니다.

**이전 (Functorium 1.0)**:
```csharp
// 이전 명명
public class MyHandler : IErrorHandler
{
    public void Handle(Error error) { }
}
```

**이후 (Functorium 1.1)**:
```csharp
// 새로운 일관된 명명
public class MyDestructurer : IErrorDestructurer
{
    public LogEventPropertyValue Destructure(Error error, ILogEventPropertyValueFactory factory) { }
}
```

**마이그레이션 가이드**:
1. 모든 `IErrorHandler` 참조를 `IErrorDestructurer`로 업데이트
2. `Handle` 메서드를 `Destructure` 메서드로 교체
3. 반환 타입을 `LogEventPropertyValue`로 변경

이 변경으로 더 직관적이고 일관된 오류 처리 API가 제공됩니다.
```

## 품질 체크리스트

문서 완료 전:

- [ ] **모든 코드 샘플** Uber 파일에서 검증됨
- [ ] **브레이킹 체인지에 대한 완전한 마이그레이션 가이드**
- [ ] **일관된 포맷팅** - 기존 템플릿과 일치
- [ ] **명확하고 개발자 중심 언어** 전체에서
- [ ] **적절한 문서 링크** (상대 경로 또는 전체 URL)
- [ ] **발명된 API나 명령 없음**
- [ ] **영향 및 기능별 논리적 구성**
