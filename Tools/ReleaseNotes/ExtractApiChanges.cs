#!/usr/bin/env dotnet

// .NET 10 File-based Program - Extract API Changes
// Usage: dotnet run ExtractApiChanges.cs

#:package System.CommandLine@2.0.0-beta4.22272.1

using System;
using System.Collections.Generic;
using System.CommandLine;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

var rootCommand = new RootCommand("Extract API changes by building current branch");

rootCommand.SetHandler(async () =>
{
    await ExtractApiChangesAsync();
});

return await rootCommand.InvokeAsync(args);

// Main logic
static async Task ExtractApiChangesAsync()
{
    var startTime = DateTime.Now;

    // Get paths
    var toolsDir = Directory.GetCurrentDirectory();
    var analysisDir = Path.Combine(toolsDir, "analysis-output");
    var apiChangesDir = Path.Combine(analysisDir, "api-changes-build-current");
    var gitRoot = await GetGitRootAsync() ?? Path.GetFullPath(Path.Combine(toolsDir, "..", ".."));

    Console.WriteLine();
    Console.WriteLine("============================================================");
    Console.WriteLine("üîç Extracting API Changes");
    Console.WriteLine("============================================================");
    Console.WriteLine();

    var currentBranch = await GetCurrentBranchAsync();
    Console.WriteLine($"üìç Current branch: {currentBranch}");
    Console.WriteLine($"üìÇ Output directory: {apiChangesDir}");
    Console.WriteLine($"üïí Timestamp: {DateTime.Now}");
    Console.WriteLine();

    // Create output directory
    if (Directory.Exists(apiChangesDir))
    {
        Directory.Delete(apiChangesDir, true);
    }
    Directory.CreateDirectory(apiChangesDir);

    try
    {
        // Step 1: Find ApiGenerator
        Console.WriteLine("üì¶ Step 1: Locating ApiGenerator...");
        var apiGeneratorPath = Path.Combine(toolsDir, "ApiGenerator.cs");

        if (!File.Exists(apiGeneratorPath))
        {
            Console.Error.WriteLine($"‚ùå Error: ApiGenerator.cs not found at {apiGeneratorPath}");
            Environment.Exit(1);
        }
        Console.WriteLine($"   ‚úì Found: {apiGeneratorPath}");
        Console.WriteLine();

        // Step 2: Find projects
        Console.WriteLine("üîç Step 2: Finding Functorium projects...");
        var srcDir = Path.Combine(gitRoot, "Src");
        var projectFiles = Directory.GetFiles(srcDir, "*.csproj", SearchOption.AllDirectories)
            .Where(p => !p.Contains(".Tests.") && Path.GetFileName(p).StartsWith("Functorium"))
            .OrderBy(p => p)
            .ToList();

        Console.WriteLine($"   ‚úì Found {projectFiles.Count} projects");
        Console.WriteLine();

        // Step 3: Generate API files
        Console.WriteLine("üèóÔ∏è  Step 3: Publishing projects and generating API files...");
        var apiOutputDir = Path.Combine(apiChangesDir, "api-files");
        Directory.CreateDirectory(apiOutputDir);

        var generatedApiFiles = new List<string>();

        foreach (var projectFile in projectFiles)
        {
            var assemblyName = Path.GetFileNameWithoutExtension(projectFile);
            var outputFile = Path.Combine(apiOutputDir, $"{assemblyName}.cs");
            var publishDir = Path.Combine(Path.GetDirectoryName(projectFile)!, "bin", "publish");

            Console.WriteLine($"   üì¶ Publishing: {assemblyName}");

            try
            {
                // Publish the project
                var publishResult = await RunProcessAsync("dotnet", $"publish \"{projectFile}\" -c Release -o \"{publishDir}\"", quiet: true);

                if (publishResult.ExitCode != 0)
                {
                    Console.WriteLine($"      ‚ö†Ô∏è  Publish failed, skipping");
                    continue;
                }

                var dllPath = Path.Combine(publishDir, $"{assemblyName}.dll");
                if (!File.Exists(dllPath))
                {
                    Console.WriteLine($"      ‚ö†Ô∏è  DLL not found: {dllPath}");
                    continue;
                }

                Console.WriteLine($"   üîß Generating API: {assemblyName}");

                // Generate API using ApiGenerator.cs
                var apiResult = await RunProcessAsync("dotnet", $"\"{apiGeneratorPath}\" \"{dllPath}\" -", quiet: true);

                if (apiResult.ExitCode == 0 && !string.IsNullOrWhiteSpace(apiResult.Output))
                {
                    // Create file with header
                    var content = new StringBuilder();
                    content.AppendLine("//------------------------------------------------------------------------------");
                    content.AppendLine("// <auto-generated>");
                    content.AppendLine("//     This code was generated by PublicApiGenerator.");
                    content.AppendLine($"//     Assembly: {assemblyName}");
                    content.AppendLine($"//     Generated at: {DateTime.Now}");
                    content.AppendLine("// </auto-generated>");
                    content.AppendLine("//------------------------------------------------------------------------------");
                    content.AppendLine();
                    content.Append(apiResult.Output);

                    await File.WriteAllTextAsync(outputFile, content.ToString());
                    generatedApiFiles.Add(outputFile);
                    Console.WriteLine($"      ‚úì Created: {Path.GetFileName(outputFile)}");
                }
                else
                {
                    Console.WriteLine($"      ‚ö†Ô∏è  Skipped (no public API or error)");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"      ‚ùå Error: {ex.Message}");
            }
        }

        Console.WriteLine($"   ‚úì Generated {generatedApiFiles.Count} API files");
        Console.WriteLine();

        // Step 4: Create uber file
        Console.WriteLine("üìÑ Step 4: Creating uber API file...");
        var uberFile = Path.Combine(apiChangesDir, "all-api-changes.txt");

        var uberContent = new StringBuilder();
        uberContent.AppendLine("# All API Files - Uber File");
        uberContent.AppendLine($"# Generated from: {currentBranch}");
        uberContent.AppendLine($"# Generated at: {DateTime.Now}");
        uberContent.AppendLine("# Generated by: PublicApiGenerator");
        uberContent.AppendLine($"# Total API files included: {generatedApiFiles.Count}");
        uberContent.AppendLine();

        foreach (var apiFile in generatedApiFiles)
        {
            var assemblyName = Path.GetFileNameWithoutExtension(apiFile);

            uberContent.AppendLine("======================================");
            uberContent.AppendLine($"API FILE: {apiFile}");
            uberContent.AppendLine($"ASSEMBLY: {assemblyName}");
            uberContent.AppendLine("======================================");
            uberContent.AppendLine();

            try
            {
                var fileContent = await File.ReadAllTextAsync(apiFile);
                uberContent.AppendLine(fileContent);
            }
            catch
            {
                uberContent.AppendLine($"# Error reading file {apiFile}");
            }

            uberContent.AppendLine();
            uberContent.AppendLine();
        }

        await File.WriteAllTextAsync(uberFile, uberContent.ToString());
        Console.WriteLine($"   ‚úì Uber file: {Path.GetFileName(uberFile)}");
        Console.WriteLine();

        // Step 5: Generate git diff
        Console.WriteLine("üìä Step 5: Generating git diff...");
        var apiDiffPath = Path.Combine(apiChangesDir, "api-changes-diff.txt");

        var diffResult = await RunProcessAsync("git", "diff HEAD -- 'Src/*/api/*.cs'", quiet: true);
        var diffContent = !string.IsNullOrWhiteSpace(diffResult.Output)
            ? diffResult.Output
            : "# No tracked API file changes (API files are newly generated)";

        await File.WriteAllTextAsync(apiDiffPath, diffContent);
        Console.WriteLine($"   ‚úì Diff file: {Path.GetFileName(apiDiffPath)}");
        Console.WriteLine();

        // Step 6: Create summary
        Console.WriteLine("üìù Step 6: Creating summary report...");

        var summary = new StringBuilder();
        summary.AppendLine("# API Files Summary");
        summary.AppendLine();
        summary.AppendLine($"Generated from: {currentBranch}");
        summary.AppendLine($"Generated at: {DateTime.Now}");
        summary.AppendLine("Generated by: PublicApiGenerator");
        summary.AppendLine();
        summary.AppendLine("## Overview");
        summary.AppendLine();
        summary.AppendLine("This document contains all Public API definitions from the Functorium repository.");
        summary.AppendLine();
        summary.AppendLine("## Results");
        summary.AppendLine();
        summary.AppendLine($"- **Total API Files Generated**: {generatedApiFiles.Count}");
        summary.AppendLine();
        summary.AppendLine("## API Files List");
        summary.AppendLine();

        foreach (var apiFile in generatedApiFiles)
        {
            var assemblyName = Path.GetFileNameWithoutExtension(apiFile);
            summary.AppendLine($"- **{assemblyName}**: `{apiFile}`");
        }

        await File.WriteAllTextAsync(Path.Combine(apiChangesDir, "api-changes-summary.md"), summary.ToString());

        // Write projects list
        await File.WriteAllLinesAsync(
            Path.Combine(apiChangesDir, "projects.txt"),
            projectFiles.Select(Path.GetFileName)!);

        Console.WriteLine($"   ‚úì Summary: api-changes-summary.md");
        Console.WriteLine();

        // Final summary
        var totalTime = (DateTime.Now - startTime).TotalSeconds;

        Console.WriteLine("============================================================");
        Console.WriteLine("‚úÖ API Files Collection completed successfully!");
        Console.WriteLine("============================================================");
        Console.WriteLine($"üìç Current Branch: {currentBranch}");
        Console.WriteLine($"üìÇ Output: {apiChangesDir}/");
        Console.WriteLine($"üìÑ Total API Files: {generatedApiFiles.Count}");
        Console.WriteLine($"‚è±Ô∏è Total Time: {Math.Round(totalTime, 1)}s");
        Console.WriteLine($"üìù Summary: {Path.Combine(apiChangesDir, "api-changes-summary.md")}");
        Console.WriteLine($"üì¶ Uber API File: {uberFile}");
        Console.WriteLine($"üìÅ API Files: {apiOutputDir}/");
        Console.WriteLine();
    }
    catch (Exception ex)
    {
        Console.Error.WriteLine();
        Console.Error.WriteLine($"‚ùå Error: {ex.Message}");
        Console.Error.WriteLine(ex.StackTrace);
        Environment.Exit(1);
    }
}

// Helper methods
static async Task<string?> GetGitRootAsync()
{
    var result = await RunProcessAsync("git", "rev-parse --show-toplevel", quiet: true);
    return result.ExitCode == 0 ? result.Output.Trim() : null;
}

static async Task<string> GetCurrentBranchAsync()
{
    var result = await RunProcessAsync("git", "branch --show-current", quiet: true);
    if (result.ExitCode == 0 && !string.IsNullOrWhiteSpace(result.Output))
    {
        return result.Output.Trim();
    }

    result = await RunProcessAsync("git", "rev-parse HEAD", quiet: true);
    return result.ExitCode == 0 ? result.Output.Trim() : "unknown";
}

static async Task<(int ExitCode, string Output)> RunProcessAsync(string fileName, string arguments, bool quiet = false)
{
    var startInfo = new ProcessStartInfo
    {
        FileName = fileName,
        Arguments = arguments,
        RedirectStandardOutput = true,
        RedirectStandardError = true,
        UseShellExecute = false,
        CreateNoWindow = true
    };

    using var process = new Process { StartInfo = startInfo };

    var outputBuilder = new StringBuilder();
    var errorBuilder = new StringBuilder();

    process.OutputDataReceived += (sender, e) =>
    {
        if (e.Data != null)
        {
            outputBuilder.AppendLine(e.Data);
        }
    };

    process.ErrorDataReceived += (sender, e) =>
    {
        if (e.Data != null && !quiet)
        {
            errorBuilder.AppendLine(e.Data);
        }
    };

    process.Start();
    process.BeginOutputReadLine();
    process.BeginErrorReadLine();
    await process.WaitForExitAsync();

    var output = outputBuilder.ToString();
    if (!quiet && errorBuilder.Length > 0)
    {
        Console.Error.Write(errorBuilder.ToString());
    }

    return (process.ExitCode, output);
}
