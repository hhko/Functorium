# All API Files - Uber File
# Generated from: main
# Generated at: 2025-12-15 오전 5:33:45
# Generated by: PublicApiGenerator
# Total API files included: 2

======================================
API FILE: C:/Workspace/Github/Functorium\Src\Functorium\.api\Functorium.cs
ASSEMBLY: Functorium
======================================

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by PublicApiGenerator.
//     Assembly: Functorium
//     Generated at: 2025-12-15 오전 5:33:29
// </auto-generated>
//------------------------------------------------------------------------------

C:\Workspace\Github\Functorium\Tools\ReleaseNotes\ApiGenerator.csproj : warning NU1603: ApiGenerator은(는) PublicApiGenerator (>= 11.2.1)에 종속되지만 PublicApiGenerator 11.2.1을(를) 찾을 수 없습니다. 대신 PublicApiGenerator 11.3.0이(가) 확인되었습니다.
C:\Workspace\Github\Functorium\Tools\ReleaseNotes\ApiGenerator.csproj : warning NU1603: ApiGenerator은(는) PublicApiGenerator (>= 11.2.1)에 종속되지만 PublicApiGenerator 11.2.1을(를) 찾을 수 없습니다. 대신 PublicApiGenerator 11.3.0이(가) 확인되었습니다.
C:\Workspace\Github\Functorium\Tools\ReleaseNotes\ApiGenerator.cs(116,24): warning IL2026: Using member 'System.Reflection.Assembly.LoadFrom(String)' which has 'RequiresUnreferencedCodeAttribute' can break functionality when trimming application code. Types and members the loaded assembly depends on might be removed.
namespace Functorium.Abstractions.Errors.DestructuringPolicies.ErrorTypes
{
    public class ErrorCodeExceptionalDestructurer : Functorium.Abstractions.Errors.DestructuringPolicies.IErrorDestructurer
    {
        public ErrorCodeExceptionalDestructurer() { }
        public bool CanHandle(LanguageExt.Common.Error error) { }
        public Serilog.Events.LogEventPropertyValue Destructure(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory factory) { }
    }
    public class ErrorCodeExpectedDestructurer : Functorium.Abstractions.Errors.DestructuringPolicies.IErrorDestructurer
    {
        public ErrorCodeExpectedDestructurer() { }
        public bool CanHandle(LanguageExt.Common.Error error) { }
        public Serilog.Events.LogEventPropertyValue Destructure(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory factory) { }
    }
    public class ErrorCodeExpectedTDestructurer : Functorium.Abstractions.Errors.DestructuringPolicies.IErrorDestructurer
    {
        public ErrorCodeExpectedTDestructurer() { }
        public bool CanHandle(LanguageExt.Common.Error error) { }
        public Serilog.Events.LogEventPropertyValue Destructure(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory factory) { }
    }
    public class ExceptionalDestructurer : Functorium.Abstractions.Errors.DestructuringPolicies.IErrorDestructurer
    {
        public ExceptionalDestructurer() { }
        public bool CanHandle(LanguageExt.Common.Error error) { }
        public Serilog.Events.LogEventPropertyValue Destructure(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory factory) { }
    }
    public class ExpectedDestructurer : Functorium.Abstractions.Errors.DestructuringPolicies.IErrorDestructurer
    {
        public ExpectedDestructurer() { }
        public bool CanHandle(LanguageExt.Common.Error error) { }
        public Serilog.Events.LogEventPropertyValue Destructure(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory factory) { }
    }
    public class ManyErrorsDestructurer : Functorium.Abstractions.Errors.DestructuringPolicies.IErrorDestructurer
    {
        public ManyErrorsDestructurer() { }
        public bool CanHandle(LanguageExt.Common.Error error) { }
        public Serilog.Events.LogEventPropertyValue Destructure(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory factory) { }
    }
}
namespace Functorium.Abstractions.Errors.DestructuringPolicies
{
    public class ErrorsDestructuringPolicy : Serilog.Core.IDestructuringPolicy
    {
        public ErrorsDestructuringPolicy() { }
        public bool TryDestructure(object value, Serilog.Core.ILogEventPropertyValueFactory propertyValueFactory, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out Serilog.Events.LogEventPropertyValue? result) { }
        public static Serilog.Events.LogEventPropertyValue DestructureError(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory propertyValueFactory) { }
    }
    public interface IErrorDestructurer
    {
        bool CanHandle(LanguageExt.Common.Error error);
        Serilog.Events.LogEventPropertyValue Destructure(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory factory);
    }
}
namespace Functorium.Abstractions.Errors
{
    public static class ErrorCodeFactory
    {
        public static LanguageExt.Common.Error Create(string errorCode, string errorCurrentValue, string errorMessage) { }
        public static LanguageExt.Common.Error Create<T>(string errorCode, T errorCurrentValue, string errorMessage)
            where T :  notnull { }
        public static LanguageExt.Common.Error Create<T1, T2>(string errorCode, T1 errorCurrentValue1, T2 errorCurrentValue2, string errorMessage)
            where T1 :  notnull
            where T2 :  notnull { }
        public static LanguageExt.Common.Error Create<T1, T2, T3>(string errorCode, T1 errorCurrentValue1, T2 errorCurrentValue2, T3 errorCurrentValue3, string errorMessage)
            where T1 :  notnull
            where T2 :  notnull
            where T3 :  notnull { }
        public static LanguageExt.Common.Error CreateFromException(string errorCode, System.Exception exception) { }
        public static string Format(params string[] parts) { }
    }
}
namespace Functorium.Abstractions.Registrations
{
    public static class OpenTelemetryRegistration
    {
        public static Functorium.Adapters.Observabilities.Builders.OpenTelemetryBuilder RegisterObservability(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, Microsoft.Extensions.Configuration.IConfiguration configuration) { }
    }
}
namespace Functorium.Abstractions.Utilities
{
    public static class DictionaryUtilities
    {
        public static void AddOrUpdate<TKey, TValue>(this System.Collections.Generic.Dictionary<TKey, TValue> dictionary, TKey key, TValue value)
            where TKey :  notnull { }
    }
    public static class IEnumerableUtilities
    {
        public static bool Any(this System.Collections.IEnumerable source) { }
        public static bool IsEmpty(this System.Collections.IEnumerable source) { }
        public static string Join<TValue>(this System.Collections.Generic.IEnumerable<TValue> items, char separator) { }
        public static string Join<TValue>(this System.Collections.Generic.IEnumerable<TValue> items, string separator) { }
    }
    public static class StringUtilities
    {
        public static double ConvertToDouble(this string str) { }
        public static int ConvertToInt(this string str) { }
        public static bool Empty(this string? str) { }
        public static bool NotContains(this string str, string subStr, System.StringComparison stringComparison = 5) { }
        public static bool NotEmpty(this string? str) { }
        public static bool NotEquals(this string str, string otherStr, System.StringComparison stringComparison = 5) { }
        public static string Replace(this string str, string[] oldStrList, string newStr) { }
        public static bool TryConvertToDouble(this string str) { }
    }
}
namespace Functorium.Adapters.Observabilities.Builders.Configurators
{
    public class LoggingConfigurator
    {
        public Functorium.Adapters.Observabilities.OpenTelemetryOptions Options { get; }
        public Functorium.Adapters.Observabilities.Builders.Configurators.LoggingConfigurator AddDestructuringPolicy<TPolicy>()
            where TPolicy : Serilog.Core.IDestructuringPolicy, new () { }
        public Functorium.Adapters.Observabilities.Builders.Configurators.LoggingConfigurator AddEnricher(Serilog.Core.ILogEventEnricher enricher) { }
        public Functorium.Adapters.Observabilities.Builders.Configurators.LoggingConfigurator AddEnricher<TEnricher>()
            where TEnricher : Serilog.Core.ILogEventEnricher, new () { }
        public Functorium.Adapters.Observabilities.Builders.Configurators.LoggingConfigurator Configure(System.Action<Serilog.LoggerConfiguration> configure) { }
    }
    public class MetricsConfigurator
    {
        public Functorium.Adapters.Observabilities.OpenTelemetryOptions Options { get; }
        public Functorium.Adapters.Observabilities.Builders.Configurators.MetricsConfigurator AddInstrumentation(System.Action<OpenTelemetry.Metrics.MeterProviderBuilder> configure) { }
        public Functorium.Adapters.Observabilities.Builders.Configurators.MetricsConfigurator AddMeter(string meterName) { }
        public Functorium.Adapters.Observabilities.Builders.Configurators.MetricsConfigurator Configure(System.Action<OpenTelemetry.Metrics.MeterProviderBuilder> configure) { }
    }
    public class TracingConfigurator
    {
        public Functorium.Adapters.Observabilities.OpenTelemetryOptions Options { get; }
        public Functorium.Adapters.Observabilities.Builders.Configurators.TracingConfigurator AddProcessor(OpenTelemetry.BaseProcessor<System.Diagnostics.Activity> processor) { }
        public Functorium.Adapters.Observabilities.Builders.Configurators.TracingConfigurator AddSource(string sourceName) { }
        public Functorium.Adapters.Observabilities.Builders.Configurators.TracingConfigurator Configure(System.Action<OpenTelemetry.Trace.TracerProviderBuilder> configure) { }
    }
}
namespace Functorium.Adapters.Observabilities.Builders
{
    public class OpenTelemetryBuilder
    {
        public Functorium.Adapters.Observabilities.OpenTelemetryOptions Options { get; }
        public Microsoft.Extensions.DependencyInjection.IServiceCollection Build() { }
        public Functorium.Adapters.Observabilities.Builders.OpenTelemetryBuilder ConfigureMetrics(System.Action<Functorium.Adapters.Observabilities.Builders.Configurators.MetricsConfigurator> configure) { }
        public Functorium.Adapters.Observabilities.Builders.OpenTelemetryBuilder ConfigureSerilog(System.Action<Functorium.Adapters.Observabilities.Builders.Configurators.LoggingConfigurator> configure) { }
        public Functorium.Adapters.Observabilities.Builders.OpenTelemetryBuilder ConfigureStartupLogger(System.Action<Microsoft.Extensions.Logging.ILogger> configure) { }
        public Functorium.Adapters.Observabilities.Builders.OpenTelemetryBuilder ConfigureTraces(System.Action<Functorium.Adapters.Observabilities.Builders.Configurators.TracingConfigurator> configure) { }
        public static System.Collections.Generic.Dictionary<string, object> CreateResourceAttributes(Functorium.Adapters.Observabilities.OpenTelemetryOptions options) { }
        public static OpenTelemetry.Exporter.OtlpExportProtocol ToOtlpProtocolForExporter(Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol protocol) { }
        public static Serilog.Sinks.OpenTelemetry.OtlpProtocol ToOtlpProtocolForSerilog(Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol protocol) { }
    }
}
namespace Functorium.Adapters.Observabilities
{
    public interface IOpenTelemetryOptions
    {
        bool EnablePrometheusExporter { get; }
    }
    public sealed class OpenTelemetryOptions : Functorium.Adapters.Observabilities.IOpenTelemetryOptions, Functorium.Adapters.Observabilities.Logging.IStartupOptionsLogger
    {
        public const string SectionName = "OpenTelemetry";
        public OpenTelemetryOptions() { }
        public string CollectorEndpoint { get; set; }
        public string CollectorProtocol { get; set; }
        public bool EnablePrometheusExporter { get; set; }
        public string? LoggingCollectorEndpoint { get; set; }
        public string? LoggingCollectorProtocol { get; set; }
        public string? MetricsCollectorEndpoint { get; set; }
        public string? MetricsCollectorProtocol { get; set; }
        public double SamplingRate { get; set; }
        public string ServiceName { get; set; }
        public string ServiceVersion { get; }
        public string? TracingCollectorEndpoint { get; set; }
        public string? TracingCollectorProtocol { get; set; }
        public string GetLoggingEndpoint() { }
        public Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol GetLogsProtocol() { }
        public string GetMetricsEndpoint() { }
        public Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol GetMetricsProtocol() { }
        public string GetTracingEndpoint() { }
        public Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol GetTracingProtocol() { }
        public void LogConfiguration(Microsoft.Extensions.Logging.ILogger logger) { }
        public sealed class OtlpCollectorProtocol : Ardalis.SmartEnum.SmartEnum<Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol>
        {
            public static readonly Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol Grpc;
            public static readonly Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol HttpProtobuf;
        }
        public sealed class Validator : FluentValidation.AbstractValidator<Functorium.Adapters.Observabilities.OpenTelemetryOptions>
        {
            public Validator() { }
        }
    }
}
namespace Functorium.Adapters.Observabilities.Logging
{
    public interface IStartupOptionsLogger
    {
        void LogConfiguration(Microsoft.Extensions.Logging.ILogger logger);
    }
    public class StartupLogger : Microsoft.Extensions.Hosting.IHostedService
    {
        public StartupLogger(Microsoft.Extensions.Logging.ILogger<Functorium.Adapters.Observabilities.Logging.StartupLogger> logger, Microsoft.Extensions.Hosting.IHostEnvironment environment, System.Collections.Generic.IEnumerable<Functorium.Adapters.Observabilities.Logging.IStartupOptionsLogger> optionsLoggers, System.Action<Microsoft.Extensions.Logging.ILogger>? additionalLogger = null) { }
        public System.Threading.Tasks.Task StartAsync(System.Threading.CancellationToken cancellationToken) { }
        public System.Threading.Tasks.Task StopAsync(System.Threading.CancellationToken cancellationToken) { }
    }
}
namespace Functorium.Adapters.Options
{
    public static class OptionsConfigurator
    {
        public static TOptions GetOptions<TOptions>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)
            where TOptions :  class, new () { }
        public static Microsoft.Extensions.Options.OptionsBuilder<TOptions> RegisterConfigureOptions<TOptions, TValidator>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, string configurationSectionName)
            where TOptions :  class
            where TValidator :  class, FluentValidation.IValidator<TOptions> { }
    }
}
namespace Functorium.Applications.Linq
{
    public static class FinTUtilites
    {
        public static LanguageExt.Fin<A> Filter<A>(this LanguageExt.Fin<A> fin, System.Func<A, bool> predicate) { }
        public static LanguageExt.FinT<M, A> Filter<M, A>(this LanguageExt.FinT<M, A> finT, System.Func<A, bool> predicate)
            where M : LanguageExt.Traits.Monad<M> { }
        public static LanguageExt.FinT<LanguageExt.IO, B> SelectMany<A, B>(this LanguageExt.IO<A> io, System.Func<A, B> selector) { }
        public static LanguageExt.FinT<LanguageExt.IO, C> SelectMany<A, B, C>(this LanguageExt.IO<A> io, System.Func<A, LanguageExt.FinT<LanguageExt.IO, B>> finTSelector, System.Func<A, B, C> projector) { }
        public static LanguageExt.FinT<M, C> SelectMany<M, A, B, C>(this LanguageExt.Fin<A> fin, System.Func<A, LanguageExt.FinT<M, B>> finTSelector, System.Func<A, B, C> projector)
            where M : LanguageExt.Traits.Monad<M> { }
    }
}



======================================
API FILE: C:/Workspace/Github/Functorium\Src\Functorium.Testing\.api\Functorium.Testing.cs
ASSEMBLY: Functorium.Testing
======================================

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by PublicApiGenerator.
//     Assembly: Functorium.Testing
//     Generated at: 2025-12-15 오전 5:33:45
// </auto-generated>
//------------------------------------------------------------------------------

namespace Functorium.Testing.ArchitectureRules
{
    public static class ArchitectureValidationEntryPoint
    {
        public static Functorium.Testing.ArchitectureRules.ValidationResultSummary ValidateAllClasses(this ArchUnitNET.Domain.IObjectProvider<ArchUnitNET.Domain.Class> classes, ArchUnitNET.Domain.Architecture architecture, System.Action<Functorium.Testing.ArchitectureRules.ClassValidator> validationRule) { }
        public static Functorium.Testing.ArchitectureRules.ValidationResultSummary ValidateAllClasses(this ArchUnitNET.Domain.IObjectProvider<ArchUnitNET.Domain.Class> classes, ArchUnitNET.Domain.Architecture architecture, System.Action<Functorium.Testing.ArchitectureRules.ClassValidator> validationRule, bool verbose) { }
    }
    public sealed class ClassValidator
    {
        public ClassValidator(ArchUnitNET.Domain.Architecture architecture, ArchUnitNET.Domain.Class targetClass) { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequireAllMethods(System.Action<Functorium.Testing.ArchitectureRules.MethodValidator> methodValidation) { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequireAllPrivateConstructors() { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequireImmutable() { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequireImplements(System.Type interfaceType) { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequireImplementsGenericInterface(string genericInterfaceName) { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequireInherits(System.Type baseType) { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequireInternal() { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequireMethod(string methodName, System.Action<Functorium.Testing.ArchitectureRules.MethodValidator> methodValidation) { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequireNestedClass(string nestedClassName, System.Action<Functorium.Testing.ArchitectureRules.ClassValidator>? nestedClassValidation = null) { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequireNestedClassIfExists(string nestedClassName, System.Action<Functorium.Testing.ArchitectureRules.ClassValidator>? nestedClassValidation = null) { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequirePrivateAnyParameterlessConstructor() { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequirePublic() { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequireSealed() { }
        public void ValidateAndThrow() { }
    }
    public sealed class MethodValidator
    {
        public MethodValidator(ArchUnitNET.Domain.MethodMember targetMethod, Functorium.Testing.ArchitectureRules.ClassValidator parentValidator) { }
        public Functorium.Testing.ArchitectureRules.MethodValidator RequireReturnType(System.Type returnType) { }
        public Functorium.Testing.ArchitectureRules.MethodValidator RequireReturnTypeOfDeclaringClass() { }
        public Functorium.Testing.ArchitectureRules.MethodValidator RequireStatic() { }
        public Functorium.Testing.ArchitectureRules.MethodValidator RequireVisibility(ArchUnitNET.Domain.Visibility visibility) { }
    }
    public sealed class ValidationResultSummary
    {
        public ValidationResultSummary() { }
        public void ThrowIfAnyFailures(string ruleName) { }
    }
}
namespace Functorium.Testing.Arrangements.Hosting
{
    public class HostTestFixture<TProgram> : System.IAsyncDisposable, Xunit.IAsyncLifetime
        where TProgram :  class
    {
        public HostTestFixture() { }
        public System.Net.Http.HttpClient Client { get; }
        protected virtual string EnvironmentName { get; }
        public System.IServiceProvider Services { get; }
        protected virtual void ConfigureHost(Microsoft.AspNetCore.Hosting.IWebHostBuilder builder) { }
        public virtual System.Threading.Tasks.ValueTask DisposeAsync() { }
        protected virtual string GetTestProjectPath() { }
        public virtual System.Threading.Tasks.ValueTask InitializeAsync() { }
    }
}
namespace Functorium.Testing.Arrangements.Loggers
{
    public class TestSink : Serilog.Core.ILogEventSink
    {
        public TestSink(System.Collections.Generic.List<Serilog.Events.LogEvent> logEvents) { }
        public void Emit(Serilog.Events.LogEvent logEvent) { }
    }
}
namespace Functorium.Testing.Arrangements.Logging
{
    public class StructuredTestLogger<T> : Microsoft.Extensions.Logging.ILogger, Microsoft.Extensions.Logging.ILogger<T>
    {
        public StructuredTestLogger(Serilog.ILogger serilogLogger) { }
        public System.IDisposable? BeginScope<TState>(TState state)
            where TState :  notnull { }
        public bool IsEnabled(Microsoft.Extensions.Logging.LogLevel logLevel) { }
        public void Log<TState>(Microsoft.Extensions.Logging.LogLevel logLevel, Microsoft.Extensions.Logging.EventId eventId, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter) { }
    }
}
namespace Functorium.Testing.Arrangements.ScheduledJobs
{
    public sealed class JobCompletionListener : Quartz.IJobListener
    {
        public JobCompletionListener() { }
        public string Name { get; }
        public System.Threading.Tasks.Task JobExecutionVetoed(Quartz.IJobExecutionContext context, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task JobToBeExecuted(Quartz.IJobExecutionContext context, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task JobWasExecuted(Quartz.IJobExecutionContext context, Quartz.JobExecutionException? jobException, System.Threading.CancellationToken cancellationToken = default) { }
        public void Reset() { }
        public System.Threading.Tasks.Task<Functorium.Testing.Arrangements.ScheduledJobs.JobExecutionResult> WaitForJobCompletionAsync(string jobName, System.TimeSpan timeout, System.Threading.CancellationToken cancellationToken = default) { }
    }
    public sealed class JobExecutionResult : System.IEquatable<Functorium.Testing.Arrangements.ScheduledJobs.JobExecutionResult>
    {
        public JobExecutionResult(string JobName, bool Success, object? Result, Quartz.JobExecutionException? Exception, System.TimeSpan ExecutionTime) { }
        public Quartz.JobExecutionException? Exception { get; init; }
        public System.TimeSpan ExecutionTime { get; init; }
        public string JobName { get; init; }
        public object? Result { get; init; }
        public bool Success { get; init; }
    }
    public class QuartzTestFixture<TProgram> : System.IAsyncDisposable, Xunit.IAsyncLifetime
        where TProgram :  class
    {
        public QuartzTestFixture() { }
        protected virtual string EnvironmentName { get; }
        public Functorium.Testing.Arrangements.ScheduledJobs.JobCompletionListener JobListener { get; }
        public Quartz.IScheduler Scheduler { get; }
        public System.IServiceProvider Services { get; }
        protected virtual void ConfigureWebHost(Microsoft.AspNetCore.Hosting.IWebHostBuilder builder) { }
        public virtual System.Threading.Tasks.ValueTask DisposeAsync() { }
        public System.Threading.Tasks.Task<Functorium.Testing.Arrangements.ScheduledJobs.JobExecutionResult> ExecuteJobOnceAsync<TJob>(System.TimeSpan timeout)
            where TJob : Quartz.IJob { }
        public System.Threading.Tasks.Task<Functorium.Testing.Arrangements.ScheduledJobs.JobExecutionResult> ExecuteJobOnceAsync<TJob>(string jobName, string jobGroup, System.TimeSpan timeout)
            where TJob : Quartz.IJob { }
        protected virtual string GetTestProjectPath() { }
        public virtual System.Threading.Tasks.ValueTask InitializeAsync() { }
    }
}
namespace Functorium.Testing
{
    public static class AssemblyReference
    {
        public static readonly System.Reflection.Assembly Assembly;
    }
}
namespace Functorium.Testing.Assertions.Logging
{
    public static class LogEventPropertyExtractor
    {
        public static object ExtractLogData(Serilog.Events.LogEvent logEvent) { }
        public static System.Collections.Generic.IEnumerable<object> ExtractLogData(System.Collections.Generic.IEnumerable<Serilog.Events.LogEvent> logEvents) { }
        public static object ExtractValue(Serilog.Events.LogEventPropertyValue propertyValue) { }
    }
    public static class LogEventPropertyValueConverter
    {
        public static object ToAnonymousObject(Serilog.Events.LogEventPropertyValue value) { }
    }
    public sealed class SerilogTestPropertyValueFactory : Serilog.Core.ILogEventPropertyValueFactory
    {
        public SerilogTestPropertyValueFactory() { }
        public Serilog.Events.LogEventPropertyValue CreatePropertyValue(object? value, bool destructureObjects = false) { }
    }
}



