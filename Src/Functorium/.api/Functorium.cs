//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by PublicApiGenerator.
//     Assembly: Functorium
//     Generated at: 2026-01-01 오전 2:47:29
// </auto-generated>
//------------------------------------------------------------------------------

namespace Functorium.Abstractions
{
    public static class ElapsedTimeCalculator
    {
        public static double CalculateElapsedMilliseconds(long startTimestamp) { }
        public static long GetCurrentTimestamp() { }
        public sealed class Timer : System.IDisposable
        {
            public Timer() { }
            public double ElapsedMilliseconds { get; }
            public void Dispose() { }
        }
    }
}
namespace Functorium.Abstractions.Errors.DestructuringPolicies.ErrorTypes
{
    public class ErrorCodeExceptionalDestructurer : Functorium.Abstractions.Errors.DestructuringPolicies.IErrorDestructurer
    {
        public ErrorCodeExceptionalDestructurer() { }
        public bool CanHandle(LanguageExt.Common.Error error) { }
        public Serilog.Events.LogEventPropertyValue Destructure(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory factory) { }
    }
    public class ErrorCodeExpectedDestructurer : Functorium.Abstractions.Errors.DestructuringPolicies.IErrorDestructurer
    {
        public ErrorCodeExpectedDestructurer() { }
        public bool CanHandle(LanguageExt.Common.Error error) { }
        public Serilog.Events.LogEventPropertyValue Destructure(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory factory) { }
    }
    public class ErrorCodeExpectedTDestructurer : Functorium.Abstractions.Errors.DestructuringPolicies.IErrorDestructurer
    {
        public ErrorCodeExpectedTDestructurer() { }
        public bool CanHandle(LanguageExt.Common.Error error) { }
        public Serilog.Events.LogEventPropertyValue Destructure(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory factory) { }
    }
    public class ExceptionalDestructurer : Functorium.Abstractions.Errors.DestructuringPolicies.IErrorDestructurer
    {
        public ExceptionalDestructurer() { }
        public bool CanHandle(LanguageExt.Common.Error error) { }
        public Serilog.Events.LogEventPropertyValue Destructure(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory factory) { }
    }
    public class ExpectedDestructurer : Functorium.Abstractions.Errors.DestructuringPolicies.IErrorDestructurer
    {
        public ExpectedDestructurer() { }
        public bool CanHandle(LanguageExt.Common.Error error) { }
        public Serilog.Events.LogEventPropertyValue Destructure(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory factory) { }
    }
    public class ManyErrorsDestructurer : Functorium.Abstractions.Errors.DestructuringPolicies.IErrorDestructurer
    {
        public ManyErrorsDestructurer() { }
        public bool CanHandle(LanguageExt.Common.Error error) { }
        public Serilog.Events.LogEventPropertyValue Destructure(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory factory) { }
    }
}
namespace Functorium.Abstractions.Errors.DestructuringPolicies
{
    public class ErrorsDestructuringPolicy : Serilog.Core.IDestructuringPolicy
    {
        public ErrorsDestructuringPolicy() { }
        public bool TryDestructure(object value, Serilog.Core.ILogEventPropertyValueFactory propertyValueFactory, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out Serilog.Events.LogEventPropertyValue? result) { }
        public static Serilog.Events.LogEventPropertyValue DestructureError(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory propertyValueFactory) { }
    }
    public interface IErrorDestructurer
    {
        bool CanHandle(LanguageExt.Common.Error error);
        Serilog.Events.LogEventPropertyValue Destructure(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory factory);
    }
}
namespace Functorium.Abstractions.Errors
{
    public static class ErrorCodeFactory
    {
        public static LanguageExt.Common.Error Create(string errorCode, string errorCurrentValue, string errorMessage) { }
        public static LanguageExt.Common.Error Create<T>(string errorCode, T errorCurrentValue, string errorMessage)
            where T :  notnull { }
        public static LanguageExt.Common.Error Create<T1, T2>(string errorCode, T1 errorCurrentValue1, T2 errorCurrentValue2, string errorMessage)
            where T1 :  notnull
            where T2 :  notnull { }
        public static LanguageExt.Common.Error Create<T1, T2, T3>(string errorCode, T1 errorCurrentValue1, T2 errorCurrentValue2, T3 errorCurrentValue3, string errorMessage)
            where T1 :  notnull
            where T2 :  notnull
            where T3 :  notnull { }
        public static LanguageExt.Common.Error CreateFromException(string errorCode, System.Exception exception) { }
        public static string Format(params string[] parts) { }
    }
}
namespace Functorium.Abstractions.Registrations
{
    public static class AdapterPipelineRegistration
    {
        public static Microsoft.Extensions.DependencyInjection.IServiceCollection RegisterScopedAdapterPipeline<TService>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, System.Func<System.Diagnostics.ActivityContext, TService> implementationFactory)
            where TService :  class, Functorium.Applications.Observabilities.IAdapter { }
        public static Microsoft.Extensions.DependencyInjection.IServiceCollection RegisterScopedAdapterPipeline<TService>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, System.Func<System.IServiceProvider, System.Diagnostics.ActivityContext, TService> implementationFactory)
            where TService :  class, Functorium.Applications.Observabilities.IAdapter { }
        public static Microsoft.Extensions.DependencyInjection.IServiceCollection RegisterScopedAdapterPipeline<TService, TImplementation>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)
            where TService :  class, Functorium.Applications.Observabilities.IAdapter
            where TImplementation :  class, TService { }
        public static Microsoft.Extensions.DependencyInjection.IServiceCollection RegisterScopedAdapterPipelineFor<TImplementation>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, params System.Type[] serviceTypes)
            where TImplementation :  class, Functorium.Applications.Observabilities.IAdapter { }
        public static Microsoft.Extensions.DependencyInjection.IServiceCollection RegisterScopedAdapterPipelineFor<TService1, TService2, TImplementation>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)
            where TService1 :  class, Functorium.Applications.Observabilities.IAdapter
            where TService2 :  class, Functorium.Applications.Observabilities.IAdapter
            where TImplementation :  class, TService1, TService2 { }
        public static Microsoft.Extensions.DependencyInjection.IServiceCollection RegisterScopedAdapterPipelineFor<TService1, TService2, TService3, TImplementation>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)
            where TService1 :  class, Functorium.Applications.Observabilities.IAdapter
            where TService2 :  class, Functorium.Applications.Observabilities.IAdapter
            where TService3 :  class, Functorium.Applications.Observabilities.IAdapter
            where TImplementation :  class, TService1, TService2, TService3 { }
        public static Microsoft.Extensions.DependencyInjection.IServiceCollection RegisterSingletonAdapterPipeline<TService>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, System.Func<System.Diagnostics.ActivityContext, TService> implementationFactory)
            where TService :  class, Functorium.Applications.Observabilities.IAdapter { }
        public static Microsoft.Extensions.DependencyInjection.IServiceCollection RegisterSingletonAdapterPipeline<TService>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, System.Func<System.IServiceProvider, System.Diagnostics.ActivityContext, TService> implementationFactory)
            where TService :  class, Functorium.Applications.Observabilities.IAdapter { }
        public static Microsoft.Extensions.DependencyInjection.IServiceCollection RegisterSingletonAdapterPipeline<TService, TImplementation>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)
            where TService :  class, Functorium.Applications.Observabilities.IAdapter
            where TImplementation :  class, TService { }
        public static Microsoft.Extensions.DependencyInjection.IServiceCollection RegisterTransientAdapterPipeline<TService>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, System.Func<System.Diagnostics.ActivityContext, TService> implementationFactory)
            where TService :  class, Functorium.Applications.Observabilities.IAdapter { }
        public static Microsoft.Extensions.DependencyInjection.IServiceCollection RegisterTransientAdapterPipeline<TService>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, System.Func<System.IServiceProvider, System.Diagnostics.ActivityContext, TService> implementationFactory)
            where TService :  class, Functorium.Applications.Observabilities.IAdapter { }
        public static Microsoft.Extensions.DependencyInjection.IServiceCollection RegisterTransientAdapterPipeline<TService, TImplementation>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)
            where TService :  class, Functorium.Applications.Observabilities.IAdapter
            where TImplementation :  class, TService { }
        public static Microsoft.Extensions.DependencyInjection.IServiceCollection RegisterTransientAdapterPipelineFor<TImplementation>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, params System.Type[] serviceTypes)
            where TImplementation :  class, Functorium.Applications.Observabilities.IAdapter { }
        public static Microsoft.Extensions.DependencyInjection.IServiceCollection RegisterTransientAdapterPipelineFor<TService1, TService2, TImplementation>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)
            where TService1 :  class, Functorium.Applications.Observabilities.IAdapter
            where TService2 :  class, Functorium.Applications.Observabilities.IAdapter
            where TImplementation :  class, TService1, TService2 { }
        public static Microsoft.Extensions.DependencyInjection.IServiceCollection RegisterTransientAdapterPipelineFor<TService1, TService2, TService3, TImplementation>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)
            where TService1 :  class, Functorium.Applications.Observabilities.IAdapter
            where TService2 :  class, Functorium.Applications.Observabilities.IAdapter
            where TService3 :  class, Functorium.Applications.Observabilities.IAdapter
            where TImplementation :  class, TService1, TService2, TService3 { }
    }
    public static class OpenTelemetryRegistration
    {
        public static Functorium.Adapters.Observabilities.Builders.OpenTelemetryBuilder RegisterOpenTelemetry(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, Microsoft.Extensions.Configuration.IConfiguration configuration, System.Reflection.Assembly projectAssembly) { }
    }
}
namespace Functorium.Abstractions.Utilities
{
    public static class DictionaryUtilities
    {
        public static void AddOrUpdate<TKey, TValue>(this System.Collections.Generic.Dictionary<TKey, TValue> dictionary, TKey key, TValue value)
            where TKey :  notnull { }
    }
    public static class IEnumerableUtilities
    {
        public static bool Any(this System.Collections.IEnumerable source) { }
        public static bool IsEmpty(this System.Collections.IEnumerable source) { }
        public static string Join<TValue>(this System.Collections.Generic.IEnumerable<TValue> items, char separator) { }
        public static string Join<TValue>(this System.Collections.Generic.IEnumerable<TValue> items, string separator) { }
    }
    public static class StringUtilities
    {
        public static double ConvertToDouble(this string str) { }
        public static int ConvertToInt(this string str) { }
        public static bool Empty(this string? str) { }
        public static bool NotContains(this string str, string subStr, System.StringComparison stringComparison = 5) { }
        public static bool NotEmpty(this string? str) { }
        public static bool NotEquals(this string str, string otherStr, System.StringComparison stringComparison = 5) { }
        public static string Replace(this string str, string[] oldStrList, string newStr) { }
        public static bool TryConvertToDouble(this string str) { }
    }
}
namespace Functorium.Adapters.Observabilities.Builders.Configurators
{
    public class LoggingConfigurator
    {
        public Functorium.Adapters.Observabilities.OpenTelemetryOptions Options { get; }
        public Functorium.Adapters.Observabilities.Builders.Configurators.LoggingConfigurator AddDestructuringPolicy<TPolicy>()
            where TPolicy : Serilog.Core.IDestructuringPolicy, new () { }
        public Functorium.Adapters.Observabilities.Builders.Configurators.LoggingConfigurator AddEnricher(Serilog.Core.ILogEventEnricher enricher) { }
        public Functorium.Adapters.Observabilities.Builders.Configurators.LoggingConfigurator AddEnricher<TEnricher>()
            where TEnricher : Serilog.Core.ILogEventEnricher, new () { }
        public Functorium.Adapters.Observabilities.Builders.Configurators.LoggingConfigurator Configure(System.Action<Serilog.LoggerConfiguration> configure) { }
    }
    public class MetricsConfigurator
    {
        public Functorium.Adapters.Observabilities.OpenTelemetryOptions Options { get; }
        public Functorium.Adapters.Observabilities.Builders.Configurators.MetricsConfigurator AddInstrumentation(System.Action<OpenTelemetry.Metrics.MeterProviderBuilder> configure) { }
        public Functorium.Adapters.Observabilities.Builders.Configurators.MetricsConfigurator AddMeter(string meterName) { }
        public Functorium.Adapters.Observabilities.Builders.Configurators.MetricsConfigurator Configure(System.Action<OpenTelemetry.Metrics.MeterProviderBuilder> configure) { }
    }
    public class TracingConfigurator
    {
        public Functorium.Adapters.Observabilities.OpenTelemetryOptions Options { get; }
        public Functorium.Adapters.Observabilities.Builders.Configurators.TracingConfigurator AddProcessor(OpenTelemetry.BaseProcessor<System.Diagnostics.Activity> processor) { }
        public Functorium.Adapters.Observabilities.Builders.Configurators.TracingConfigurator AddSource(string sourceName) { }
        public Functorium.Adapters.Observabilities.Builders.Configurators.TracingConfigurator Configure(System.Action<OpenTelemetry.Trace.TracerProviderBuilder> configure) { }
    }
}
namespace Functorium.Adapters.Observabilities.Builders
{
    public class OpenTelemetryBuilder
    {
        public Functorium.Adapters.Observabilities.OpenTelemetryOptions Options { get; }
        public Microsoft.Extensions.DependencyInjection.IServiceCollection Build() { }
        public Functorium.Adapters.Observabilities.Builders.OpenTelemetryBuilder ConfigureLogging(System.Action<Functorium.Adapters.Observabilities.Builders.Configurators.LoggingConfigurator> configure) { }
        public Functorium.Adapters.Observabilities.Builders.OpenTelemetryBuilder ConfigureMetrics(System.Action<Functorium.Adapters.Observabilities.Builders.Configurators.MetricsConfigurator> configure) { }
        public Functorium.Adapters.Observabilities.Builders.OpenTelemetryBuilder ConfigureStartupLogger(System.Action<Microsoft.Extensions.Logging.ILogger> configure) { }
        public Functorium.Adapters.Observabilities.Builders.OpenTelemetryBuilder ConfigureTracing(System.Action<Functorium.Adapters.Observabilities.Builders.Configurators.TracingConfigurator> configure) { }
        public Functorium.Adapters.Observabilities.Builders.OpenTelemetryBuilder WithAdapterObservability(bool enable = true) { }
        public static System.Collections.Generic.Dictionary<string, object> CreateResourceAttributes(Functorium.Adapters.Observabilities.OpenTelemetryOptions options) { }
        public static OpenTelemetry.Exporter.OtlpExportProtocol ToOtlpProtocolForExporter(Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol protocol) { }
        public static Serilog.Sinks.OpenTelemetry.OtlpProtocol ToOtlpProtocolForSerilog(Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol protocol) { }
    }
}
namespace Functorium.Adapters.Observabilities.Context
{
    public static class ActivityContextHolder
    {
        public static System.IDisposable EnterActivity(System.Diagnostics.Activity? activity) { }
        public static System.IDisposable EnterContext(Functorium.Applications.Observabilities.Context.IObservabilityContext? context) { }
        public static System.Diagnostics.Activity? GetCurrentActivity() { }
        public static Functorium.Applications.Observabilities.Context.IObservabilityContext? GetCurrentContext() { }
    }
    public sealed class ActivityContextPropagator : Functorium.Applications.Observabilities.Context.IContextPropagator
    {
        public ActivityContextPropagator() { }
        public Functorium.Applications.Observabilities.Context.IObservabilityContext? Current { get; }
        public System.IDisposable CreateScope(Functorium.Applications.Observabilities.Context.IObservabilityContext context) { }
        public Functorium.Applications.Observabilities.Context.IObservabilityContext? ExtractContext(Functorium.Applications.Observabilities.Spans.ISpan? span) { }
    }
}
namespace Functorium.Adapters.Observabilities
{
    public interface IOpenTelemetryOptions
    {
        bool EnablePrometheusExporter { get; }
        string ServiceNamespace { get; }
    }
    public sealed class OpenTelemetryOptions : Functorium.Adapters.Observabilities.IOpenTelemetryOptions, Functorium.Adapters.Observabilities.Loggers.IStartupOptionsLogger
    {
        public const string SectionName = "OpenTelemetry";
        public OpenTelemetryOptions() { }
        public string CollectorEndpoint { get; set; }
        public string CollectorProtocol { get; set; }
        public bool EnablePrometheusExporter { get; set; }
        public string? LoggingEndpoint { get; set; }
        public string? LoggingProtocol { get; set; }
        public string? MetricsEndpoint { get; set; }
        public string? MetricsProtocol { get; set; }
        public double SamplingRate { get; set; }
        public string ServiceName { get; set; }
        public string ServiceNamespace { get; set; }
        public string ServiceVersion { get; }
        public string? TracingEndpoint { get; set; }
        public string? TracingProtocol { get; set; }
        public string GetLoggingEndpoint() { }
        public Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol GetLoggingProtocol() { }
        public string GetMetricsEndpoint() { }
        public Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol GetMetricsProtocol() { }
        public string GetTracingEndpoint() { }
        public Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol GetTracingProtocol() { }
        public void LogConfiguration(Microsoft.Extensions.Logging.ILogger logger) { }
        public sealed class OtlpCollectorProtocol : Ardalis.SmartEnum.SmartEnum<Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol>
        {
            public static readonly Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol Grpc;
            public static readonly Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol HttpProtobuf;
        }
        public sealed class Validator : FluentValidation.AbstractValidator<Functorium.Adapters.Observabilities.OpenTelemetryOptions>
        {
            public Validator() { }
        }
    }
}
namespace Functorium.Adapters.Observabilities.Loggers
{
    public interface IStartupOptionsLogger
    {
        void LogConfiguration(Microsoft.Extensions.Logging.ILogger logger);
    }
    public class StartupLogger : Microsoft.Extensions.Hosting.IHostedService
    {
        public StartupLogger(Microsoft.Extensions.Logging.ILogger<Functorium.Adapters.Observabilities.Loggers.StartupLogger> logger, Microsoft.Extensions.Hosting.IHostEnvironment environment, System.Collections.Generic.IEnumerable<Functorium.Adapters.Observabilities.Loggers.IStartupOptionsLogger> optionsLoggers, System.Action<Microsoft.Extensions.Logging.ILogger>? additionalLogger = null) { }
        public System.Threading.Tasks.Task StartAsync(System.Threading.CancellationToken cancellationToken) { }
        public System.Threading.Tasks.Task StopAsync(System.Threading.CancellationToken cancellationToken) { }
    }
}
namespace Functorium.Adapters.Observabilities.Metrics
{
    public sealed class OpenTelemetryMetricRecorder : Functorium.Applications.Observabilities.Metrics.IMetricRecorder, System.IDisposable
    {
        public OpenTelemetryMetricRecorder(string serviceNamespace) { }
        public void Dispose() { }
        public void RecordFailure(string category, string handler, string method, double elapsedMs, LanguageExt.Common.Error error) { }
        public void RecordRequestStart(string category, string handler, string method) { }
        public void RecordSuccess(string category, string handler, string method, double elapsedMs) { }
    }
}
namespace Functorium.Adapters.Observabilities.Spans
{
    public sealed class OpenTelemetrySpanFactory : Functorium.Applications.Observabilities.Spans.ISpanFactory
    {
        public OpenTelemetrySpanFactory(System.Diagnostics.ActivitySource activitySource) { }
        public Functorium.Applications.Observabilities.Spans.ISpan? CreateChildSpan(Functorium.Applications.Observabilities.Context.IObservabilityContext? parentContext, string operationName, string category, string handler, string method) { }
        public Functorium.Applications.Observabilities.Spans.ISpan? CreateSpan(string operationName, string category, string handler, string method) { }
    }
}
namespace Functorium.Adapters.Options
{
    public static class OptionsConfigurator
    {
        public static TOptions GetOptions<TOptions>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)
            where TOptions :  class, new () { }
        public static Microsoft.Extensions.Options.OptionsBuilder<TOptions> RegisterConfigureOptions<TOptions, TValidator>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, string configurationSectionName)
            where TOptions :  class
            where TValidator :  class, FluentValidation.IValidator<TOptions> { }
    }
}
namespace Functorium.Applications.Cqrs
{
    public static class FinResponse
    {
        public static Functorium.Applications.Cqrs.FinResponse<A> Fail<A>(LanguageExt.Common.Error error) { }
        public static Functorium.Applications.Cqrs.FinResponse<A> Succ<A>()
            where A : new() { }
        public static Functorium.Applications.Cqrs.FinResponse<A> Succ<A>(A value) { }
    }
    public abstract class FinResponse<A> : Functorium.Applications.Cqrs.IFinResponse, Functorium.Applications.Cqrs.IFinResponseFactory<Functorium.Applications.Cqrs.FinResponse<A>>, Functorium.Applications.Cqrs.IFinResponse<A>, System.IEquatable<Functorium.Applications.Cqrs.FinResponse<A>>
    {
        protected FinResponse() { }
        public abstract bool IsFail { get; }
        public abstract bool IsSucc { get; }
        public Functorium.Applications.Cqrs.FinResponse<B> BiBind<B>(System.Func<A, Functorium.Applications.Cqrs.FinResponse<B>> Succ, System.Func<LanguageExt.Common.Error, Functorium.Applications.Cqrs.FinResponse<B>> Fail) { }
        public Functorium.Applications.Cqrs.FinResponse<B> BiMap<B>(System.Func<A, B> Succ, System.Func<LanguageExt.Common.Error, LanguageExt.Common.Error> Fail) { }
        public Functorium.Applications.Cqrs.FinResponse<B> Bind<B>(System.Func<A, Functorium.Applications.Cqrs.FinResponse<B>> f) { }
        public Functorium.Applications.Cqrs.FinResponse<A> BindFail(System.Func<LanguageExt.Common.Error, Functorium.Applications.Cqrs.FinResponse<A>> Fail) { }
        public A IfFail(A alternative) { }
        public void IfFail(System.Action<LanguageExt.Common.Error> Fail) { }
        public A IfFail(System.Func<LanguageExt.Common.Error, A> Fail) { }
        public void IfSucc(System.Action<A> Succ) { }
        public Functorium.Applications.Cqrs.FinResponse<B> Map<B>(System.Func<A, B> f) { }
        public Functorium.Applications.Cqrs.FinResponse<A> MapFail(System.Func<LanguageExt.Common.Error, LanguageExt.Common.Error> f) { }
        public void Match(System.Action<A> Succ, System.Action<LanguageExt.Common.Error> Fail) { }
        public abstract B Match<B>(System.Func<A, B> Succ, System.Func<LanguageExt.Common.Error, B> Fail);
        public Functorium.Applications.Cqrs.FinResponse<B> Select<B>(System.Func<A, B> f) { }
        public Functorium.Applications.Cqrs.FinResponse<C> SelectMany<B, C>(System.Func<A, Functorium.Applications.Cqrs.FinResponse<B>> bind, System.Func<A, B, C> project) { }
        public A ThrowIfFail() { }
        public static Functorium.Applications.Cqrs.FinResponse<A> CreateFail(LanguageExt.Common.Error error) { }
        public static Functorium.Applications.Cqrs.FinResponse<A> op_Implicit(A value) { }
        public static Functorium.Applications.Cqrs.FinResponse<A> op_Implicit(LanguageExt.Common.Error error) { }
        public static bool operator false(Functorium.Applications.Cqrs.FinResponse<A> ma) { }
        public static bool operator true(Functorium.Applications.Cqrs.FinResponse<A> ma) { }
        public static Functorium.Applications.Cqrs.FinResponse<A> operator |(Functorium.Applications.Cqrs.FinResponse<A> lhs, Functorium.Applications.Cqrs.FinResponse<A> rhs) { }
        public sealed class Fail : Functorium.Applications.Cqrs.FinResponse<A>, Functorium.Applications.Cqrs.IFinResponseWithError, System.IEquatable<Functorium.Applications.Cqrs.FinResponse<A>.Fail>
        {
            public Fail(LanguageExt.Common.Error Error) { }
            public LanguageExt.Common.Error Error { get; init; }
            public override bool IsFail { get; }
            public override bool IsSucc { get; }
            public void Deconstruct(out LanguageExt.Common.Error error) { }
            public override B Match<B>(System.Func<A, B> Succ, System.Func<LanguageExt.Common.Error, B> Fail) { }
            public override string ToString() { }
        }
        public sealed class Succ : Functorium.Applications.Cqrs.FinResponse<A>, System.IEquatable<Functorium.Applications.Cqrs.FinResponse<A>.Succ>
        {
            public Succ(A Value) { }
            public override bool IsFail { get; }
            public override bool IsSucc { get; }
            public A Value { get; init; }
            public void Deconstruct(out A value) { }
            public override B Match<B>(System.Func<A, B> Succ, System.Func<LanguageExt.Common.Error, B> Fail) { }
            public override string ToString() { }
        }
    }
    public static class FinToFinResponse
    {
        public static Functorium.Applications.Cqrs.FinResponse<A> ToFinResponse<A>(this LanguageExt.Fin<A> fin) { }
        public static Functorium.Applications.Cqrs.FinResponse<B> ToFinResponse<A, B>(this LanguageExt.Fin<A> fin, System.Func<B> factory) { }
        public static Functorium.Applications.Cqrs.FinResponse<B> ToFinResponse<A, B>(this LanguageExt.Fin<A> fin, System.Func<A, B> mapper) { }
        public static Functorium.Applications.Cqrs.FinResponse<B> ToFinResponse<A, B>(this LanguageExt.Fin<A> fin, System.Func<A, Functorium.Applications.Cqrs.FinResponse<B>> onSucc, System.Func<LanguageExt.Common.Error, Functorium.Applications.Cqrs.FinResponse<B>> onFail) { }
    }
    public interface ICacheable
    {
        string CacheKey { get; }
        System.TimeSpan? Duration { get; }
    }
    public interface ICommandRequest<TSuccess> : Mediator.IBaseCommand, Mediator.ICommand<Functorium.Applications.Cqrs.FinResponse<TSuccess>>, Mediator.IMessage { }
    public interface ICommandUsecase<in TCommand, TSuccess> : Mediator.ICommandHandler<TCommand, Functorium.Applications.Cqrs.FinResponse<TSuccess>>
        where in TCommand : Functorium.Applications.Cqrs.ICommandRequest<TSuccess> { }
    public interface IFinResponse
    {
        bool IsFail { get; }
        bool IsSucc { get; }
    }
    public interface IFinResponseFactory<TSelf>
        where TSelf : Functorium.Applications.Cqrs.IFinResponseFactory<TSelf>
    {
        TSelf CreateFail(LanguageExt.Common.Error error);
    }
    public interface IFinResponseWithError
    {
        LanguageExt.Common.Error Error { get; }
    }
    public interface IFinResponse<out A> : Functorium.Applications.Cqrs.IFinResponse { }
    public interface IQueryRequest<TSuccess> : Mediator.IBaseQuery, Mediator.IMessage, Mediator.IQuery<Functorium.Applications.Cqrs.FinResponse<TSuccess>> { }
    public interface IQueryUsecase<in TQuery, TSuccess> : Mediator.IQueryHandler<TQuery, Functorium.Applications.Cqrs.FinResponse<TSuccess>>
        where in TQuery : Functorium.Applications.Cqrs.IQueryRequest<TSuccess> { }
}
namespace Functorium.Applications.Linq
{
    public static class FinTUtilites
    {
        public static LanguageExt.Fin<A> Filter<A>(this LanguageExt.Fin<A> fin, System.Func<A, bool> predicate) { }
        public static LanguageExt.FinT<M, A> Filter<M, A>(this LanguageExt.FinT<M, A> finT, System.Func<A, bool> predicate)
            where M : LanguageExt.Traits.Monad<M> { }
        public static LanguageExt.FinT<LanguageExt.IO, B> SelectMany<A, B>(this LanguageExt.IO<A> io, System.Func<A, B> selector) { }
        public static LanguageExt.FinT<LanguageExt.IO, C> SelectMany<A, B, C>(this LanguageExt.IO<A> io, System.Func<A, LanguageExt.FinT<LanguageExt.IO, B>> finTSelector, System.Func<A, B, C> projector) { }
        public static LanguageExt.FinT<M, C> SelectMany<M, A, B, C>(this LanguageExt.Fin<A> fin, System.Func<A, LanguageExt.FinT<M, B>> finTSelector, System.Func<A, B, C> projector)
            where M : LanguageExt.Traits.Monad<M> { }
        public static LanguageExt.FinT<LanguageExt.IO, LanguageExt.Seq<B>> TraverseSerial<A, B>(this LanguageExt.Seq<A> seq, System.Func<A, LanguageExt.FinT<LanguageExt.IO, B>> f, System.Diagnostics.ActivitySource activitySource, string operationName, System.Func<A, int, string> getItemIdentifier) { }
        public static LanguageExt.FinT<M, LanguageExt.Seq<B>> TraverseSerial<M, A, B>(this LanguageExt.Seq<A> seq, System.Func<A, LanguageExt.FinT<M, B>> f)
            where M : LanguageExt.Traits.Monad<M> { }
    }
}
namespace Functorium.Applications.Observabilities.Context
{
    public interface IContextPropagator
    {
        Functorium.Applications.Observabilities.Context.IObservabilityContext? Current { get; }
        System.IDisposable CreateScope(Functorium.Applications.Observabilities.Context.IObservabilityContext context);
        Functorium.Applications.Observabilities.Context.IObservabilityContext? ExtractContext(Functorium.Applications.Observabilities.Spans.ISpan? span);
    }
    public interface IObservabilityContext
    {
        string SpanId { get; }
        string TraceId { get; }
    }
}
namespace Functorium.Applications.Observabilities
{
    public interface IAdapter
    {
        string RequestCategory { get; }
    }
    public static class ObservabilityNaming
    {
        public static class Categories
        {
            public const string Adapter = "adapter";
            public const string Repository = "repository";
            public const string Usecase = "usecase";
        }
        public static class Cqrs
        {
            public const string Command = "command";
            public const string Query = "query";
            public const string Unknown = "unknown";
        }
        public static class CustomAttributes
        {
            public const string ErrorCode = "error.code";
            public const string ErrorCount = "error.count";
            public const string ErrorMessage = "error.message";
            public const string RequestCategory = "request.category";
            public const string RequestHandler = "request.handler";
            public const string RequestHandlerCqrs = "request.handler.cqrs";
            public const string RequestHandlerMethod = "request.handler.method";
            public const string RequestLayer = "request.layer";
            public const string ResponseElapsed = "response.elapsed";
            public const string ResponseStatus = "response.status";
        }
        public static class EventIds
        {
            public static class Adapter
            {
                public static readonly Microsoft.Extensions.Logging.EventId AdapterRequest;
                public static readonly Microsoft.Extensions.Logging.EventId AdapterResponseError;
                public static readonly Microsoft.Extensions.Logging.EventId AdapterResponseSuccess;
                public static readonly Microsoft.Extensions.Logging.EventId AdapterResponseWarning;
            }
            public static class Application
            {
                public static readonly Microsoft.Extensions.Logging.EventId ApplicationRequest;
                public static readonly Microsoft.Extensions.Logging.EventId ApplicationResponseError;
                public static readonly Microsoft.Extensions.Logging.EventId ApplicationResponseSuccess;
                public static readonly Microsoft.Extensions.Logging.EventId ApplicationResponseWarning;
            }
        }
        public static class Layers
        {
            public const string Adapter = "adapter";
            public const string Application = "application";
        }
        public static class LogKeys
        {
            public const string ErrorData = "Error";
            public const string RequestCategory = "RequestCategory";
            public const string RequestData = "Request";
            public const string RequestHandler = "RequestHandler";
            public const string RequestHandlerCqrs = "RequestHandlerCqrs";
            public const string RequestHandlerMethod = "RequestHandlerMethod";
            public const string RequestLayer = "RequestLayer";
            public const string ResponseData = "Response";
            public const string ResponseElapsed = "Elapsed";
            public const string ResponseStatus = "Status";
        }
        public static class Metrics
        {
            public static string AdapterDuration(string category) { }
            public static string AdapterRequest(string category) { }
            public static string AdapterResponseFailure(string category) { }
            public static string AdapterResponseSuccess(string category) { }
            public static string Duration(string layer, string category) { }
            public static string Requests(string layer, string category) { }
            public static string ResponseFailure(string layer, string category) { }
            public static string ResponseSuccess(string layer, string category) { }
            public static string UsecaseDuration(string cqrsType) { }
            public static string UsecaseRequest(string cqrsType) { }
            public static string UsecaseResponseFailure(string cqrsType) { }
            public static string UsecaseResponseSuccess(string cqrsType) { }
        }
        public static class OTelAttributes
        {
            public const string CodeFilepath = "code.filepath";
            public const string CodeFunction = "code.function";
            public const string CodeLineno = "code.lineno";
            public const string CodeNamespace = "code.namespace";
            public const string DeploymentEnvironment = "deployment.environment";
            public const string ErrorType = "error.type";
            public const string ExceptionMessage = "exception.message";
            public const string ExceptionStacktrace = "exception.stacktrace";
            public const string ExceptionType = "exception.type";
            public const string ServiceName = "service.name";
            public const string ServiceNamespace = "service.namespace";
            public const string ServiceVersion = "service.version";
        }
        public static class Spans
        {
            public static string OperationName(string layer, string category, string handler, string method) { }
        }
        public static class Status
        {
            public const string Failure = "failure";
            public const string Success = "success";
        }
    }
}
namespace Functorium.Applications.Observabilities.Loggers
{
    public static class UsecaseLoggerExtensions
    {
        public static void LogRequestMessage<T>(this Microsoft.Extensions.Logging.ILogger logger, string requestLayer, string requestCategory, string requestCqrs, string requestHandler, string requestHandlerMethod, T? request) { }
        public static void LogResponseMessageError(this Microsoft.Extensions.Logging.ILogger logger, string requestLayer, string requestCategory, string requestCqrs, string requestHandler, string requestHandlerMethod, string status, double elapsed, LanguageExt.Common.Error error) { }
        public static void LogResponseMessageSuccess<T>(this Microsoft.Extensions.Logging.ILogger logger, string requestLayer, string requestCategory, string requestCqrs, string requestHandler, string requestHandlerMethod, T? response, string status, double elapsed) { }
        public static void LogResponseMessageWarning(this Microsoft.Extensions.Logging.ILogger logger, string requestLayer, string requestCategory, string requestCqrs, string requestHandler, string requestHandlerMethod, string status, double elapsed, LanguageExt.Common.Error error) { }
    }
}
namespace Functorium.Applications.Observabilities.Metrics
{
    public interface IMetricRecorder
    {
        void RecordFailure(string category, string handler, string method, double elapsedMs, LanguageExt.Common.Error error);
        void RecordRequestStart(string category, string handler, string method);
        void RecordSuccess(string category, string handler, string method, double elapsedMs);
    }
}
namespace Functorium.Applications.Observabilities.Spans
{
    public interface ISpan : System.IDisposable
    {
        Functorium.Applications.Observabilities.Context.IObservabilityContext Context { get; }
        string SpanId { get; }
        string TraceId { get; }
        void SetFailure(LanguageExt.Common.Error error, double? elapsedMs = default);
        void SetFailure(string message, double? elapsedMs = default);
        void SetSuccess(double? elapsedMs = default);
        void SetTag(string key, object? value);
    }
    public interface ISpanFactory
    {
        Functorium.Applications.Observabilities.Spans.ISpan? CreateChildSpan(Functorium.Applications.Observabilities.Context.IObservabilityContext? parentContext, string operationName, string category, string handler, string method);
        Functorium.Applications.Observabilities.Spans.ISpan? CreateSpan(string operationName, string category, string handler, string method);
    }
}
namespace Functorium.Applications.Pipelines
{
    public sealed class UsecaseExceptionPipeline<TRequest, TResponse> : Functorium.Applications.Pipelines.UsecasePipelineBase<TRequest>, Mediator.IPipelineBehavior<TRequest, TResponse>
        where TRequest : Mediator.IMessage
        where TResponse : Functorium.Applications.Cqrs.IFinResponseFactory<TResponse>
    {
        public UsecaseExceptionPipeline() { }
        public System.Threading.Tasks.ValueTask<TResponse> Handle(TRequest request, Mediator.MessageHandlerDelegate<TRequest, TResponse> next, System.Threading.CancellationToken cancellationToken) { }
    }
    public sealed class UsecaseLoggingPipeline<TRequest, TResponse> : Functorium.Applications.Pipelines.UsecasePipelineBase<TRequest>, Mediator.IPipelineBehavior<TRequest, TResponse>
        where TRequest : Mediator.IMessage
        where TResponse : Functorium.Applications.Cqrs.IFinResponse, Functorium.Applications.Cqrs.IFinResponseFactory<TResponse>
    {
        public UsecaseLoggingPipeline(Microsoft.Extensions.Logging.ILogger<Functorium.Applications.Pipelines.UsecaseLoggingPipeline<TRequest, TResponse>> logger) { }
        public System.Threading.Tasks.ValueTask<TResponse> Handle(TRequest request, Mediator.MessageHandlerDelegate<TRequest, TResponse> next, System.Threading.CancellationToken cancellationToken) { }
    }
    public abstract class UsecaseMetricCustomPipelineBase<TRequest>
    {
        protected const string CountUnit = "requests";
        protected const string DurationUnit = "ms";
        protected readonly System.Diagnostics.Metrics.Meter _meter;
        protected UsecaseMetricCustomPipelineBase(string serviceNamespace, System.Diagnostics.Metrics.IMeterFactory meterFactory) { }
        protected string GetMetricName(string metricName) { }
        protected string GetMetricNameWithoutHandler(string metricName) { }
        public class RequestDuration : System.IDisposable
        {
            public RequestDuration(System.Diagnostics.Metrics.Histogram<double> histogram) { }
            public void Dispose() { }
        }
    }
    public sealed class UsecaseMetricPipeline<TRequest, TResponse> : Functorium.Applications.Pipelines.UsecasePipelineBase<TRequest>, Mediator.IPipelineBehavior<TRequest, TResponse>
        where TRequest : Mediator.IMessage
        where TResponse : Functorium.Applications.Cqrs.IFinResponse, Functorium.Applications.Cqrs.IFinResponseFactory<TResponse>
    {
        public UsecaseMetricPipeline(Functorium.Adapters.Observabilities.IOpenTelemetryOptions openTelemetryOptions, System.Diagnostics.Metrics.IMeterFactory meterFactory) { }
        public System.Threading.Tasks.ValueTask<TResponse> Handle(TRequest request, Mediator.MessageHandlerDelegate<TRequest, TResponse> next, System.Threading.CancellationToken cancellationToken) { }
    }
    public abstract class UsecasePipelineBase<TRequest>
    {
        protected UsecasePipelineBase() { }
        protected static string GetRequestCqrs<T>(T request) { }
        protected static string GetRequestHandler() { }
        protected static string GetRequestHandlerPath() { }
    }
    public sealed class UsecaseTracingPipeline<TRequest, TResponse> : Functorium.Applications.Pipelines.UsecasePipelineBase<TRequest>, Mediator.IPipelineBehavior<TRequest, TResponse>
        where TRequest : Mediator.IMessage
        where TResponse : Functorium.Applications.Cqrs.IFinResponse, Functorium.Applications.Cqrs.IFinResponseFactory<TResponse>
    {
        public UsecaseTracingPipeline(System.Diagnostics.ActivitySource activitySource) { }
        public System.Threading.Tasks.ValueTask<TResponse> Handle(TRequest request, Mediator.MessageHandlerDelegate<TRequest, TResponse> next, System.Threading.CancellationToken cancellationToken) { }
    }
    public sealed class UsecaseValidationPipeline<TRequest, TResponse> : Functorium.Applications.Pipelines.UsecasePipelineBase<TRequest>, Mediator.IPipelineBehavior<TRequest, TResponse>
        where TRequest : Mediator.IMessage
        where TResponse : Functorium.Applications.Cqrs.IFinResponseFactory<TResponse>
    {
        public UsecaseValidationPipeline(System.Collections.Generic.IEnumerable<FluentValidation.IValidator<TRequest>> validators) { }
        public System.Threading.Tasks.ValueTask<TResponse> Handle(TRequest request, Mediator.MessageHandlerDelegate<TRequest, TResponse> next, System.Threading.CancellationToken cancellationToken) { }
    }
}
namespace Functorium.Domains.ValueObjects
{
    [System.Serializable]
    public abstract class AbstractValueObject : Functorium.Domains.ValueObjects.IValueObject, System.IEquatable<Functorium.Domains.ValueObjects.AbstractValueObject>
    {
        protected AbstractValueObject() { }
        public bool Equals(Functorium.Domains.ValueObjects.AbstractValueObject? other) { }
        public override bool Equals(object? obj) { }
        protected abstract System.Collections.Generic.IEnumerable<object> GetEqualityComponents();
        public override int GetHashCode() { }
        protected static System.Type GetUnproxiedType(object obj) { }
        public static bool operator !=(Functorium.Domains.ValueObjects.AbstractValueObject? a, Functorium.Domains.ValueObjects.AbstractValueObject? b) { }
        public static bool operator ==(Functorium.Domains.ValueObjects.AbstractValueObject? a, Functorium.Domains.ValueObjects.AbstractValueObject? b) { }
    }
    [System.Serializable]
    public abstract class ComparableSimpleValueObject<T> : Functorium.Domains.ValueObjects.ComparableValueObject
        where T :  notnull, System.IComparable
    {
        protected ComparableSimpleValueObject(T value) { }
        protected T Value { get; }
        public override sealed bool Equals(object? obj) { }
        protected override System.Collections.Generic.IEnumerable<System.IComparable> GetComparableEqualityComponents() { }
        public override sealed int GetHashCode() { }
        public override string ToString() { }
        public static LanguageExt.Fin<TValueObject> CreateFromValidation<TValueObject>(LanguageExt.Validation<LanguageExt.Common.Error, T> validation, System.Func<T, TValueObject> factory)
            where TValueObject : Functorium.Domains.ValueObjects.ComparableSimpleValueObject<T> { }
        public static T op_Explicit(Functorium.Domains.ValueObjects.ComparableSimpleValueObject<T>? valueObject) { }
        public static bool operator !=(Functorium.Domains.ValueObjects.ComparableSimpleValueObject<T>? left, Functorium.Domains.ValueObjects.ComparableSimpleValueObject<T>? right) { }
        public static bool operator ==(Functorium.Domains.ValueObjects.ComparableSimpleValueObject<T>? left, Functorium.Domains.ValueObjects.ComparableSimpleValueObject<T>? right) { }
    }
    [System.Serializable]
    public abstract class ComparableValueObject : Functorium.Domains.ValueObjects.ValueObject, System.IComparable<Functorium.Domains.ValueObjects.ComparableValueObject>
    {
        protected ComparableValueObject() { }
        public virtual int CompareTo(Functorium.Domains.ValueObjects.ComparableValueObject? other) { }
        protected abstract System.Collections.Generic.IEnumerable<System.IComparable> GetComparableEqualityComponents();
        protected override System.Collections.Generic.IEnumerable<object> GetEqualityComponents() { }
        public static bool operator <(Functorium.Domains.ValueObjects.ComparableValueObject? left, Functorium.Domains.ValueObjects.ComparableValueObject? right) { }
        public static bool operator <=(Functorium.Domains.ValueObjects.ComparableValueObject? left, Functorium.Domains.ValueObjects.ComparableValueObject? right) { }
        public static bool operator >(Functorium.Domains.ValueObjects.ComparableValueObject? left, Functorium.Domains.ValueObjects.ComparableValueObject? right) { }
        public static bool operator >=(Functorium.Domains.ValueObjects.ComparableValueObject? left, Functorium.Domains.ValueObjects.ComparableValueObject? right) { }
    }
    public interface IValueObject
    {
    }
    [System.Serializable]
    public abstract class SimpleValueObject<T> : Functorium.Domains.ValueObjects.ValueObject
        where T :  notnull
    {
        protected SimpleValueObject(T value) { }
        protected T Value { get; }
        public override sealed bool Equals(object? obj) { }
        protected override System.Collections.Generic.IEnumerable<object> GetEqualityComponents() { }
        public override sealed int GetHashCode() { }
        public override string ToString() { }
        public static LanguageExt.Fin<TValueObject> CreateFromValidation<TValueObject>(LanguageExt.Validation<LanguageExt.Common.Error, T> validation, System.Func<T, TValueObject> factory)
            where TValueObject : Functorium.Domains.ValueObjects.SimpleValueObject<T> { }
        public static T op_Explicit(Functorium.Domains.ValueObjects.SimpleValueObject<T>? valueObject) { }
        public static bool operator !=(Functorium.Domains.ValueObjects.SimpleValueObject<T>? left, Functorium.Domains.ValueObjects.SimpleValueObject<T>? right) { }
        public static bool operator ==(Functorium.Domains.ValueObjects.SimpleValueObject<T>? left, Functorium.Domains.ValueObjects.SimpleValueObject<T>? right) { }
    }
    [System.Serializable]
    public abstract class ValueObject : Functorium.Domains.ValueObjects.AbstractValueObject
    {
        protected ValueObject() { }
        public static LanguageExt.Fin<TValueObject> CreateFromValidation<TValueObject, TValue>(LanguageExt.Validation<LanguageExt.Common.Error, TValue> validation, System.Func<TValue, TValueObject> factory)
            where TValueObject : Functorium.Domains.ValueObjects.ValueObject { }
    }
}
