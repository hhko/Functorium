//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by PublicApiGenerator.
//     Assembly: Functorium
//     Generated at: 2025-12-20 오전 12:58:23
// </auto-generated>
//------------------------------------------------------------------------------

namespace Functorium.Abstractions
{
    public static class ElapsedTimeCalculator
    {
        public static double CalculateElapsedMilliseconds(long startTimestamp) { }
        public static long GetCurrentTimestamp() { }
        public sealed class Timer : System.IDisposable
        {
            public Timer() { }
            public double ElapsedMilliseconds { get; }
            public void Dispose() { }
        }
    }
}
namespace Functorium.Abstractions.Errors.DestructuringPolicies.ErrorTypes
{
    public class ErrorCodeExceptionalDestructurer : Functorium.Abstractions.Errors.DestructuringPolicies.IErrorDestructurer
    {
        public ErrorCodeExceptionalDestructurer() { }
        public bool CanHandle(LanguageExt.Common.Error error) { }
        public Serilog.Events.LogEventPropertyValue Destructure(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory factory) { }
    }
    public class ErrorCodeExpectedDestructurer : Functorium.Abstractions.Errors.DestructuringPolicies.IErrorDestructurer
    {
        public ErrorCodeExpectedDestructurer() { }
        public bool CanHandle(LanguageExt.Common.Error error) { }
        public Serilog.Events.LogEventPropertyValue Destructure(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory factory) { }
    }
    public class ErrorCodeExpectedTDestructurer : Functorium.Abstractions.Errors.DestructuringPolicies.IErrorDestructurer
    {
        public ErrorCodeExpectedTDestructurer() { }
        public bool CanHandle(LanguageExt.Common.Error error) { }
        public Serilog.Events.LogEventPropertyValue Destructure(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory factory) { }
    }
    public class ExceptionalDestructurer : Functorium.Abstractions.Errors.DestructuringPolicies.IErrorDestructurer
    {
        public ExceptionalDestructurer() { }
        public bool CanHandle(LanguageExt.Common.Error error) { }
        public Serilog.Events.LogEventPropertyValue Destructure(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory factory) { }
    }
    public class ExpectedDestructurer : Functorium.Abstractions.Errors.DestructuringPolicies.IErrorDestructurer
    {
        public ExpectedDestructurer() { }
        public bool CanHandle(LanguageExt.Common.Error error) { }
        public Serilog.Events.LogEventPropertyValue Destructure(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory factory) { }
    }
    public class ManyErrorsDestructurer : Functorium.Abstractions.Errors.DestructuringPolicies.IErrorDestructurer
    {
        public ManyErrorsDestructurer() { }
        public bool CanHandle(LanguageExt.Common.Error error) { }
        public Serilog.Events.LogEventPropertyValue Destructure(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory factory) { }
    }
}
namespace Functorium.Abstractions.Errors.DestructuringPolicies
{
    public class ErrorsDestructuringPolicy : Serilog.Core.IDestructuringPolicy
    {
        public ErrorsDestructuringPolicy() { }
        public bool TryDestructure(object value, Serilog.Core.ILogEventPropertyValueFactory propertyValueFactory, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out Serilog.Events.LogEventPropertyValue? result) { }
        public static Serilog.Events.LogEventPropertyValue DestructureError(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory propertyValueFactory) { }
    }
    public interface IErrorDestructurer
    {
        bool CanHandle(LanguageExt.Common.Error error);
        Serilog.Events.LogEventPropertyValue Destructure(LanguageExt.Common.Error error, Serilog.Core.ILogEventPropertyValueFactory factory);
    }
}
namespace Functorium.Abstractions.Errors
{
    public static class ErrorCodeFactory
    {
        public static LanguageExt.Common.Error Create(string errorCode, string errorCurrentValue, string errorMessage) { }
        public static LanguageExt.Common.Error Create<T>(string errorCode, T errorCurrentValue, string errorMessage)
            where T :  notnull { }
        public static LanguageExt.Common.Error Create<T1, T2>(string errorCode, T1 errorCurrentValue1, T2 errorCurrentValue2, string errorMessage)
            where T1 :  notnull
            where T2 :  notnull { }
        public static LanguageExt.Common.Error Create<T1, T2, T3>(string errorCode, T1 errorCurrentValue1, T2 errorCurrentValue2, T3 errorCurrentValue3, string errorMessage)
            where T1 :  notnull
            where T2 :  notnull
            where T3 :  notnull { }
        public static LanguageExt.Common.Error CreateFromException(string errorCode, System.Exception exception) { }
        public static string Format(params string[] parts) { }
    }
}
namespace Functorium.Abstractions.Registrations
{
    public static class OpenTelemetryRegistration
    {
        public static Functorium.Adapters.Observabilities.Builders.OpenTelemetryBuilder RegisterObservability(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, Microsoft.Extensions.Configuration.IConfiguration configuration) { }
    }
}
namespace Functorium.Abstractions.Utilities
{
    public static class DictionaryUtilities
    {
        public static void AddOrUpdate<TKey, TValue>(this System.Collections.Generic.Dictionary<TKey, TValue> dictionary, TKey key, TValue value)
            where TKey :  notnull { }
    }
    public static class IEnumerableUtilities
    {
        public static bool Any(this System.Collections.IEnumerable source) { }
        public static bool IsEmpty(this System.Collections.IEnumerable source) { }
        public static string Join<TValue>(this System.Collections.Generic.IEnumerable<TValue> items, char separator) { }
        public static string Join<TValue>(this System.Collections.Generic.IEnumerable<TValue> items, string separator) { }
    }
    public static class StringUtilities
    {
        public static double ConvertToDouble(this string str) { }
        public static int ConvertToInt(this string str) { }
        public static bool Empty(this string? str) { }
        public static bool NotContains(this string str, string subStr, System.StringComparison stringComparison = 5) { }
        public static bool NotEmpty(this string? str) { }
        public static bool NotEquals(this string str, string otherStr, System.StringComparison stringComparison = 5) { }
        public static string Replace(this string str, string[] oldStrList, string newStr) { }
        public static bool TryConvertToDouble(this string str) { }
    }
}
namespace Functorium.Adapters.Observabilities.Builders.Configurators
{
    public class LoggingConfigurator
    {
        public Functorium.Adapters.Observabilities.OpenTelemetryOptions Options { get; }
        public Functorium.Adapters.Observabilities.Builders.Configurators.LoggingConfigurator AddDestructuringPolicy<TPolicy>()
            where TPolicy : Serilog.Core.IDestructuringPolicy, new () { }
        public Functorium.Adapters.Observabilities.Builders.Configurators.LoggingConfigurator AddEnricher(Serilog.Core.ILogEventEnricher enricher) { }
        public Functorium.Adapters.Observabilities.Builders.Configurators.LoggingConfigurator AddEnricher<TEnricher>()
            where TEnricher : Serilog.Core.ILogEventEnricher, new () { }
        public Functorium.Adapters.Observabilities.Builders.Configurators.LoggingConfigurator Configure(System.Action<Serilog.LoggerConfiguration> configure) { }
    }
    public class MetricsConfigurator
    {
        public Functorium.Adapters.Observabilities.OpenTelemetryOptions Options { get; }
        public Functorium.Adapters.Observabilities.Builders.Configurators.MetricsConfigurator AddInstrumentation(System.Action<OpenTelemetry.Metrics.MeterProviderBuilder> configure) { }
        public Functorium.Adapters.Observabilities.Builders.Configurators.MetricsConfigurator AddMeter(string meterName) { }
        public Functorium.Adapters.Observabilities.Builders.Configurators.MetricsConfigurator Configure(System.Action<OpenTelemetry.Metrics.MeterProviderBuilder> configure) { }
    }
    public class TracingConfigurator
    {
        public Functorium.Adapters.Observabilities.OpenTelemetryOptions Options { get; }
        public Functorium.Adapters.Observabilities.Builders.Configurators.TracingConfigurator AddProcessor(OpenTelemetry.BaseProcessor<System.Diagnostics.Activity> processor) { }
        public Functorium.Adapters.Observabilities.Builders.Configurators.TracingConfigurator AddSource(string sourceName) { }
        public Functorium.Adapters.Observabilities.Builders.Configurators.TracingConfigurator Configure(System.Action<OpenTelemetry.Trace.TracerProviderBuilder> configure) { }
    }
}
namespace Functorium.Adapters.Observabilities.Builders
{
    public class OpenTelemetryBuilder
    {
        public Functorium.Adapters.Observabilities.OpenTelemetryOptions Options { get; }
        public Microsoft.Extensions.DependencyInjection.IServiceCollection Build() { }
        public Functorium.Adapters.Observabilities.Builders.OpenTelemetryBuilder ConfigureMetrics(System.Action<Functorium.Adapters.Observabilities.Builders.Configurators.MetricsConfigurator> configure) { }
        public Functorium.Adapters.Observabilities.Builders.OpenTelemetryBuilder ConfigureSerilog(System.Action<Functorium.Adapters.Observabilities.Builders.Configurators.LoggingConfigurator> configure) { }
        public Functorium.Adapters.Observabilities.Builders.OpenTelemetryBuilder ConfigureStartupLogger(System.Action<Microsoft.Extensions.Logging.ILogger> configure) { }
        public Functorium.Adapters.Observabilities.Builders.OpenTelemetryBuilder ConfigureTraces(System.Action<Functorium.Adapters.Observabilities.Builders.Configurators.TracingConfigurator> configure) { }
        public static System.Collections.Generic.Dictionary<string, object> CreateResourceAttributes(Functorium.Adapters.Observabilities.OpenTelemetryOptions options) { }
        public static OpenTelemetry.Exporter.OtlpExportProtocol ToOtlpProtocolForExporter(Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol protocol) { }
        public static Serilog.Sinks.OpenTelemetry.OtlpProtocol ToOtlpProtocolForSerilog(Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol protocol) { }
    }
}
namespace Functorium.Adapters.Observabilities
{
    public interface IOpenTelemetryOptions
    {
        bool EnablePrometheusExporter { get; }
    }
    public sealed class OpenTelemetryOptions : Functorium.Adapters.Observabilities.IOpenTelemetryOptions, Functorium.Adapters.Observabilities.Logging.IStartupOptionsLogger
    {
        public const string SectionName = "OpenTelemetry";
        public OpenTelemetryOptions() { }
        public string CollectorEndpoint { get; set; }
        public string CollectorProtocol { get; set; }
        public bool EnablePrometheusExporter { get; set; }
        public string? LoggingCollectorEndpoint { get; set; }
        public string? LoggingCollectorProtocol { get; set; }
        public string? MetricsCollectorEndpoint { get; set; }
        public string? MetricsCollectorProtocol { get; set; }
        public double SamplingRate { get; set; }
        public string ServiceName { get; set; }
        public string ServiceVersion { get; }
        public string? TracingCollectorEndpoint { get; set; }
        public string? TracingCollectorProtocol { get; set; }
        public string GetLoggingEndpoint() { }
        public Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol GetLogsProtocol() { }
        public string GetMetricsEndpoint() { }
        public Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol GetMetricsProtocol() { }
        public string GetTracingEndpoint() { }
        public Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol GetTracingProtocol() { }
        public void LogConfiguration(Microsoft.Extensions.Logging.ILogger logger) { }
        public sealed class OtlpCollectorProtocol : Ardalis.SmartEnum.SmartEnum<Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol>
        {
            public static readonly Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol Grpc;
            public static readonly Functorium.Adapters.Observabilities.OpenTelemetryOptions.OtlpCollectorProtocol HttpProtobuf;
        }
        public sealed class Validator : FluentValidation.AbstractValidator<Functorium.Adapters.Observabilities.OpenTelemetryOptions>
        {
            public Validator() { }
        }
    }
}
namespace Functorium.Adapters.Observabilities.Logging
{
    public interface IStartupOptionsLogger
    {
        void LogConfiguration(Microsoft.Extensions.Logging.ILogger logger);
    }
    public class StartupLogger : Microsoft.Extensions.Hosting.IHostedService
    {
        public StartupLogger(Microsoft.Extensions.Logging.ILogger<Functorium.Adapters.Observabilities.Logging.StartupLogger> logger, Microsoft.Extensions.Hosting.IHostEnvironment environment, System.Collections.Generic.IEnumerable<Functorium.Adapters.Observabilities.Logging.IStartupOptionsLogger> optionsLoggers, System.Action<Microsoft.Extensions.Logging.ILogger>? additionalLogger = null) { }
        public System.Threading.Tasks.Task StartAsync(System.Threading.CancellationToken cancellationToken) { }
        public System.Threading.Tasks.Task StopAsync(System.Threading.CancellationToken cancellationToken) { }
    }
}
namespace Functorium.Adapters.Options
{
    public static class OptionsConfigurator
    {
        public static TOptions GetOptions<TOptions>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)
            where TOptions :  class, new () { }
        public static Microsoft.Extensions.Options.OptionsBuilder<TOptions> RegisterConfigureOptions<TOptions, TValidator>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, string configurationSectionName)
            where TOptions :  class
            where TValidator :  class, FluentValidation.IValidator<TOptions> { }
    }
}
namespace Functorium.Applications.Linq
{
    public static class FinTUtilites
    {
        public static LanguageExt.Fin<A> Filter<A>(this LanguageExt.Fin<A> fin, System.Func<A, bool> predicate) { }
        public static LanguageExt.FinT<M, A> Filter<M, A>(this LanguageExt.FinT<M, A> finT, System.Func<A, bool> predicate)
            where M : LanguageExt.Traits.Monad<M> { }
        public static LanguageExt.FinT<LanguageExt.IO, B> SelectMany<A, B>(this LanguageExt.IO<A> io, System.Func<A, B> selector) { }
        public static LanguageExt.FinT<LanguageExt.IO, C> SelectMany<A, B, C>(this LanguageExt.IO<A> io, System.Func<A, LanguageExt.FinT<LanguageExt.IO, B>> finTSelector, System.Func<A, B, C> projector) { }
        public static LanguageExt.FinT<M, C> SelectMany<M, A, B, C>(this LanguageExt.Fin<A> fin, System.Func<A, LanguageExt.FinT<M, B>> finTSelector, System.Func<A, B, C> projector)
            where M : LanguageExt.Traits.Monad<M> { }
        public static LanguageExt.FinT<LanguageExt.IO, LanguageExt.Seq<B>> TraverseSerial<A, B>(this LanguageExt.Seq<A> seq, System.Func<A, LanguageExt.FinT<LanguageExt.IO, B>> f, System.Diagnostics.ActivitySource activitySource, string operationName, System.Func<A, int, string> getItemIdentifier) { }
        public static LanguageExt.FinT<M, LanguageExt.Seq<B>> TraverseSerial<M, A, B>(this LanguageExt.Seq<A> seq, System.Func<A, LanguageExt.FinT<M, B>> f)
            where M : LanguageExt.Traits.Monad<M> { }
    }
}
namespace Functorium.Applications.Observabilities
{
    public interface IAdapter
    {
        string RequestCategory { get; }
    }
    public interface IAdapterMetric
    {
        void Request(System.Diagnostics.Activity? activity, string requestCategory, string requestHandler, string requestHandlerMethod, System.DateTimeOffset startTime);
        void ResponseFailure(System.Diagnostics.Activity? activity, string requestCategory, double elapsedMs, LanguageExt.Common.Error error);
        void ResponseSuccess(System.Diagnostics.Activity? activity, string requestCategory, double elapsedMs);
    }
    public interface IAdapterTrace
    {
        System.Diagnostics.Activity? Request(System.Diagnostics.ActivityContext parentContext, string requestCategory, string requestHandler, string requestHandlerMethod, System.DateTimeOffset startTime);
        void ResponseFailure(System.Diagnostics.Activity? activity, double elapsedMs, LanguageExt.Common.Error error);
        void ResponseSuccess(System.Diagnostics.Activity? activity, double elapsedMs);
    }
    public static class TraceParentActivityHolder
    {
        public static System.IDisposable Enter(System.Diagnostics.Activity? activity) { }
        public static System.Diagnostics.Activity? GetCurrent() { }
    }
}
namespace Functorium.Applications
{
    public static class TraceParentContextHolder
    {
        public static System.IDisposable Enter(System.Diagnostics.ActivityContext? context) { }
        public static System.Diagnostics.ActivityContext? GetCurrent() { }
        public static void SetCurrent(System.Diagnostics.ActivityContext? context) { }
        public static LanguageExt.Unit SetCurrentUnit(System.Diagnostics.ActivityContext? context) { }
    }
}
