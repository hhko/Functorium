//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by PublicApiGenerator.
//     Assembly: Functorium.Testing
//     Generated at: 2025-12-16 오전 7:08:23
// </auto-generated>
//------------------------------------------------------------------------------

namespace Functorium.Testing.ArchitectureRules
{
    public static class ArchitectureValidationEntryPoint
    {
        public static Functorium.Testing.ArchitectureRules.ValidationResultSummary ValidateAllClasses(this ArchUnitNET.Domain.IObjectProvider<ArchUnitNET.Domain.Class> classes, ArchUnitNET.Domain.Architecture architecture, System.Action<Functorium.Testing.ArchitectureRules.ClassValidator> validationRule) { }
        public static Functorium.Testing.ArchitectureRules.ValidationResultSummary ValidateAllClasses(this ArchUnitNET.Domain.IObjectProvider<ArchUnitNET.Domain.Class> classes, ArchUnitNET.Domain.Architecture architecture, System.Action<Functorium.Testing.ArchitectureRules.ClassValidator> validationRule, bool verbose) { }
    }
    public sealed class ClassValidator
    {
        public ClassValidator(ArchUnitNET.Domain.Architecture architecture, ArchUnitNET.Domain.Class targetClass) { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequireAllMethods(System.Action<Functorium.Testing.ArchitectureRules.MethodValidator> methodValidation) { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequireAllPrivateConstructors() { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequireImmutable() { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequireImplements(System.Type interfaceType) { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequireImplementsGenericInterface(string genericInterfaceName) { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequireInherits(System.Type baseType) { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequireInternal() { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequireMethod(string methodName, System.Action<Functorium.Testing.ArchitectureRules.MethodValidator> methodValidation) { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequireNestedClass(string nestedClassName, System.Action<Functorium.Testing.ArchitectureRules.ClassValidator>? nestedClassValidation = null) { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequireNestedClassIfExists(string nestedClassName, System.Action<Functorium.Testing.ArchitectureRules.ClassValidator>? nestedClassValidation = null) { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequirePrivateAnyParameterlessConstructor() { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequirePublic() { }
        public Functorium.Testing.ArchitectureRules.ClassValidator RequireSealed() { }
        public void ValidateAndThrow() { }
    }
    public sealed class MethodValidator
    {
        public MethodValidator(ArchUnitNET.Domain.MethodMember targetMethod, Functorium.Testing.ArchitectureRules.ClassValidator parentValidator) { }
        public Functorium.Testing.ArchitectureRules.MethodValidator RequireReturnType(System.Type returnType) { }
        public Functorium.Testing.ArchitectureRules.MethodValidator RequireReturnTypeOfDeclaringClass() { }
        public Functorium.Testing.ArchitectureRules.MethodValidator RequireStatic() { }
        public Functorium.Testing.ArchitectureRules.MethodValidator RequireVisibility(ArchUnitNET.Domain.Visibility visibility) { }
    }
    public sealed class ValidationResultSummary
    {
        public ValidationResultSummary() { }
        public void ThrowIfAnyFailures(string ruleName) { }
    }
}
namespace Functorium.Testing.Arrangements.Hosting
{
    public class HostTestFixture<TProgram> : System.IAsyncDisposable, Xunit.IAsyncLifetime
        where TProgram :  class
    {
        public HostTestFixture() { }
        public System.Net.Http.HttpClient Client { get; }
        protected virtual string EnvironmentName { get; }
        public System.IServiceProvider Services { get; }
        protected virtual void ConfigureHost(Microsoft.AspNetCore.Hosting.IWebHostBuilder builder) { }
        public virtual System.Threading.Tasks.ValueTask DisposeAsync() { }
        protected virtual string GetTestProjectPath() { }
        public virtual System.Threading.Tasks.ValueTask InitializeAsync() { }
    }
}
namespace Functorium.Testing.Arrangements.Loggers
{
    public class TestSink : Serilog.Core.ILogEventSink
    {
        public TestSink(System.Collections.Generic.List<Serilog.Events.LogEvent> logEvents) { }
        public void Emit(Serilog.Events.LogEvent logEvent) { }
    }
}
namespace Functorium.Testing.Arrangements.Logging
{
    public class StructuredTestLogger<T> : Microsoft.Extensions.Logging.ILogger, Microsoft.Extensions.Logging.ILogger<T>
    {
        public StructuredTestLogger(Serilog.ILogger serilogLogger) { }
        public System.IDisposable? BeginScope<TState>(TState state)
            where TState :  notnull { }
        public bool IsEnabled(Microsoft.Extensions.Logging.LogLevel logLevel) { }
        public void Log<TState>(Microsoft.Extensions.Logging.LogLevel logLevel, Microsoft.Extensions.Logging.EventId eventId, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter) { }
    }
}
namespace Functorium.Testing.Arrangements.ScheduledJobs
{
    public sealed class JobCompletionListener : Quartz.IJobListener
    {
        public JobCompletionListener() { }
        public string Name { get; }
        public System.Threading.Tasks.Task JobExecutionVetoed(Quartz.IJobExecutionContext context, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task JobToBeExecuted(Quartz.IJobExecutionContext context, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task JobWasExecuted(Quartz.IJobExecutionContext context, Quartz.JobExecutionException? jobException, System.Threading.CancellationToken cancellationToken = default) { }
        public void Reset() { }
        public System.Threading.Tasks.Task<Functorium.Testing.Arrangements.ScheduledJobs.JobExecutionResult> WaitForJobCompletionAsync(string jobName, System.TimeSpan timeout, System.Threading.CancellationToken cancellationToken = default) { }
    }
    public sealed class JobExecutionResult : System.IEquatable<Functorium.Testing.Arrangements.ScheduledJobs.JobExecutionResult>
    {
        public JobExecutionResult(string JobName, bool Success, object? Result, Quartz.JobExecutionException? Exception, System.TimeSpan ExecutionTime) { }
        public Quartz.JobExecutionException? Exception { get; init; }
        public System.TimeSpan ExecutionTime { get; init; }
        public string JobName { get; init; }
        public object? Result { get; init; }
        public bool Success { get; init; }
    }
    public class QuartzTestFixture<TProgram> : System.IAsyncDisposable, Xunit.IAsyncLifetime
        where TProgram :  class
    {
        public QuartzTestFixture() { }
        protected virtual string EnvironmentName { get; }
        public Functorium.Testing.Arrangements.ScheduledJobs.JobCompletionListener JobListener { get; }
        public Quartz.IScheduler Scheduler { get; }
        public System.IServiceProvider Services { get; }
        protected virtual void ConfigureWebHost(Microsoft.AspNetCore.Hosting.IWebHostBuilder builder) { }
        public virtual System.Threading.Tasks.ValueTask DisposeAsync() { }
        public System.Threading.Tasks.Task<Functorium.Testing.Arrangements.ScheduledJobs.JobExecutionResult> ExecuteJobOnceAsync<TJob>(System.TimeSpan timeout)
            where TJob : Quartz.IJob { }
        public System.Threading.Tasks.Task<Functorium.Testing.Arrangements.ScheduledJobs.JobExecutionResult> ExecuteJobOnceAsync<TJob>(string jobName, string jobGroup, System.TimeSpan timeout)
            where TJob : Quartz.IJob { }
        protected virtual string GetTestProjectPath() { }
        public virtual System.Threading.Tasks.ValueTask InitializeAsync() { }
    }
}
namespace Functorium.Testing
{
    public static class AssemblyReference
    {
        public static readonly System.Reflection.Assembly Assembly;
    }
}
namespace Functorium.Testing.Assertions.Logging
{
    public static class LogEventPropertyExtractor
    {
        public static object ExtractLogData(Serilog.Events.LogEvent logEvent) { }
        public static System.Collections.Generic.IEnumerable<object> ExtractLogData(System.Collections.Generic.IEnumerable<Serilog.Events.LogEvent> logEvents) { }
        public static object ExtractValue(Serilog.Events.LogEventPropertyValue propertyValue) { }
    }
    public static class LogEventPropertyValueConverter
    {
        public static object ToAnonymousObject(Serilog.Events.LogEventPropertyValue value) { }
    }
    public sealed class SerilogTestPropertyValueFactory : Serilog.Core.ILogEventPropertyValueFactory
    {
        public SerilogTestPropertyValueFactory() { }
        public Serilog.Events.LogEventPropertyValue CreatePropertyValue(object? value, bool destructureObjects = false) { }
    }
}
