using System.Collections.Immutable;
using System.Linq;
using System.Text;

using Functorium.Adapters.SourceGenerator.Generators;
using Functorium.Adapters.SourceGenerator.Generators.AdapterPipelineGenerator;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

using static Functorium.Adapters.SourceGenerator.Abstractions.Constants;
using static Functorium.Adapters.SourceGenerator.Abstractions.Selectors;

namespace Functorium.Adapters.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public sealed class AdapterPipelineGenerator()
    : IncrementalGeneratorBase<PipelineClassInfo>(
        RegisterSourceProvider,
        Generate,
        AttachDebugger: false)  // ⚠️ 디버깅 필요 시 true로 변경 (자세한 내용: DEBUGGING_SOURCE_GENERATOR.md 참조)
{
    private const string AttributeName = "GeneratePipeline";
    private const string AttributeNamespace = "Functorium.Adapters.SourceGenerator";
    private const string FullyQualifiedAttributeName = $"{AttributeNamespace}.{AttributeName}Attribute";
    private const string GeneratePipelineAttributeFileName = "GeneratePipelineAttribute.g.cs";

    // Diagnostic descriptors
    private static readonly DiagnosticDescriptor DuplicateParameterTypeDiagnostic = new(
        id: "FUNCTORIUM001",
        title: "Duplicate parameter types in pipeline constructor",
        messageFormat: "Pipeline constructor for '{0}' contains multiple parameters of the same type '{1}'. This may cause issues with dependency injection resolution.",
        category: "Design",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public const string GeneratePipelineAttribute = Header + """

                                                             namespace Functorium.Adapters.SourceGenerator;

                                                             /// <summary>
                                                             /// Add to adapter classes to indicate that pipeline wrapper should be generated
                                                             /// </summary>
                                                             [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
                                                             [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(Justification = "Generated by source generator.")]
                                                             public class GeneratePipelineAttribute : global::System.Attribute;
                                                             """;

    private static IncrementalValuesProvider<PipelineClassInfo> RegisterSourceProvider(
        IncrementalGeneratorInitializationContext context)
    {
        //
        // 1단계: 고정 코드 생성 (Post-initialization)
        //  - 소스 코드 분석과 무관하게 항상 생성되는 코드 등록 (예: Attribute 정의)
        //  - 컴파일 초기 단계에 한 번만 실행됨
        //
        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddSource(
                hintName: GeneratePipelineAttributeFileName,
                sourceText: SourceText.From(GeneratePipelineAttribute, Encoding.UTF8)));

        //
        // 2단계: 대상 필터링 및 코드 생성 준비
        //  - [GeneratePipeline] 같은 특성이 붙은 "클래스"만 대상으로 삼음
        //  - 이후 코드 생성에 필요한 정보 구조로 변환
        //
        return context
            .SyntaxProvider
            .ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: FullyQualifiedAttributeName,
                predicate: IsClass,
                transform: MapToPipelineClassInfo)
            .Where(x => x != PipelineClassInfo.None);
    }

    private static PipelineClassInfo MapToPipelineClassInfo(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
    {
        // 클래스가 없을 때
        if (context.TargetSymbol is not INamedTypeSymbol classSymbol)
        {
            return PipelineClassInfo.None;
        }

        cancellationToken.ThrowIfCancellationRequested();

        // 클래스가 있을 때

        // 클래스 이름과 네임스페이스
        string className = classSymbol.Name;
        string @namespace = classSymbol.ContainingNamespace.IsGlobalNamespace
            ? string.Empty
            : classSymbol.ContainingNamespace.ToString();

        // IAdapter를 상속받은 모든 인터페이스의 메서드를 직접 추출
        // 클래스 구현을 찾을 필요 없이 인터페이스 정의에서 바로 가져옴
        var methods = classSymbol.AllInterfaces
            .Where(ImplementsIAdapter)
            .SelectMany(i => i.GetMembers().OfType<IMethodSymbol>())
            .Where(m => m.MethodKind == MethodKind.Ordinary)
            .Select(m => new MethodInfo(
                m.Name,
                m.Parameters.Select(p => new ParameterInfo(
                    p.Name,
                    p.Type.ToDisplayString(SymbolDisplayFormats.GlobalQualifiedFormat),
                    p.RefKind)).ToList(),
                m.ReturnType.ToDisplayString(SymbolDisplayFormats.GlobalQualifiedFormat)))
            .ToList();

        // IAdapter를 구현하지 않은 경우 (메서드가 없음) - 파이프라인 생성하지 않음
        if (methods.Count == 0)
        {
            return PipelineClassInfo.None;
        }

        // 생성자 파라미터 추출
        // 우선순위: 1. 타겟 클래스 자체의 생성자, 2. 부모 클래스의 생성자
        var baseConstructorParameters = ConstructorParameterExtractor.ExtractParameters(classSymbol);

        // 원본 소스 위치 (IDE 진단용)
        Location? location = context.TargetNode.GetLocation();

        return new PipelineClassInfo(@namespace, className, methods, baseConstructorParameters, location);
    }

    /// <summary>
    /// 인터페이스가 IAdapter를 상속받았는지 확인합니다.
    /// </summary>
    /// <param name="interfaceSymbol">확인할 인터페이스 심볼</param>
    /// <returns>IAdapter를 상속받았으면 true, 아니면 false</returns>
    private static bool ImplementsIAdapter(INamedTypeSymbol interfaceSymbol)
    {
        // IAdapter 자체인지 확인
        if (interfaceSymbol.Name == "IAdapter")
        {
            return true;
        }

        // IAdapter를 상속받은 인터페이스인지 확인
        return interfaceSymbol.AllInterfaces.Any(i => i.Name == "IAdapter");
    }

    // 매핑된 PipelineClassInfo로부터 소스 파일을 생성합니다.
    private static void Generate(SourceProductionContext context, ImmutableArray<PipelineClassInfo> pipelineClasses)
    {
        foreach (var pipelineClass in pipelineClasses)
        {
            // 생성자 파라미터 타입 중복 체크
            var allParameters = new List<ParameterInfo>();
            allParameters.AddRange(pipelineClass.BaseConstructorParameters);

            // Pipeline 클래스 생성자 파라미터 (ActivitySource, ILogger, IMeterFactory)
            allParameters.Add(new ParameterInfo("activitySource", "global::System.Diagnostics.ActivitySource", RefKind.None));
            allParameters.Add(new ParameterInfo("logger", $"global::Microsoft.Extensions.Logging.ILogger<{pipelineClass.Namespace}.{pipelineClass.ClassName}Pipeline>", RefKind.None));
            allParameters.Add(new ParameterInfo("meterFactory", "global::System.Diagnostics.Metrics.IMeterFactory", RefKind.None));

            // 동일한 타입의 파라미터가 있는지 체크
            var duplicateTypes = allParameters
                .GroupBy(p => p.Type)
                .Where(g => g.Count() > 1)
                .Select(g => g.Key)
                .ToList();

            if (duplicateTypes.Any())
            {
                // IDE 친화적 진단 리포트 (원본 소스 파일 위치 표시)
                context.ReportDiagnostic(Diagnostic.Create(
                    DuplicateParameterTypeDiagnostic,
                    pipelineClass.Location,
                    pipelineClass.ClassName,
                    string.Join(", ", duplicateTypes)));

                continue;  // 에러 시 코드 생성 건너뛰기
            }
            else
            {
                // 정상적인 Pipeline 클래스 생성
                StringBuilder sb = new();
                string source = GeneratePipelineClassSource(pipelineClass, sb);

                // 네임스페이스의 마지막 부분 추출 (예: Observability.Adapters.Infrastructure.Repositories -> Repositories)
                string namespaceSuffix = string.Empty;
                if (!string.IsNullOrEmpty(pipelineClass.Namespace))
                {
                    var lastDotIndex = pipelineClass.Namespace.LastIndexOf('.');
                    if (lastDotIndex >= 0)
                    {
                        namespaceSuffix = pipelineClass.Namespace.Substring(lastDotIndex + 1) + ".";
                    }
                }

                context.AddSource(
                    $"{namespaceSuffix}{pipelineClass.ClassName}Pipeline.g.cs",
                    SourceText.From(source, Encoding.UTF8));
            }
        }
    }

    private static string GeneratePipelineClassSource(PipelineClassInfo classInfo, StringBuilder sb)
    {
        sb.Append(Header)
            .AppendLine()
            .AppendLine("using System.Diagnostics;")
            .AppendLine("using System.Diagnostics.Metrics;")
            .AppendLine("using Functorium.Adapters.Observabilities;")
            .AppendLine("using Functorium.Adapters.Observabilities.Naming;")
            .AppendLine("using Functorium.Applications.Observabilities;")
            .AppendLine()
            .AppendLine("using LanguageExt;")
            .AppendLine("using Microsoft.Extensions.Logging;")
            .AppendLine()
            .AppendLine($"namespace {classInfo.Namespace};")
            .AppendLine()
            .AppendLine($"public class {classInfo.ClassName}Pipeline : {classInfo.ClassName}")
            .AppendLine("{")
            .AppendLine("    private readonly ActivitySource _activitySource;")
            .AppendLine($"    private readonly ILogger<{classInfo.ClassName}Pipeline> _logger;")
            .AppendLine()
            .AppendLine("    // Metrics")
            .AppendLine("    private readonly Counter<long> _requestCounter;")
            .AppendLine("    private readonly Counter<long> _responseCounter;")
            .AppendLine("    private readonly Histogram<double> _durationHistogram;")
            .AppendLine()
            .AppendLine($"    private const string RequestHandler = nameof({classInfo.ClassName});")
            .AppendLine()
            .AppendLine("    private readonly bool _isDebugEnabled;")
            .AppendLine("    private readonly bool _isInformationEnabled;")
            .AppendLine("    private readonly bool _isWarningEnabled;")
            .AppendLine("    private readonly bool _isErrorEnabled;")
            .AppendLine()
            .Append($"    public {classInfo.ClassName}Pipeline(")
            .AppendLine()
            .AppendLine("        ActivitySource activitySource,")
            .AppendLine($"        ILogger<{classInfo.ClassName}Pipeline> logger,")
            .Append("        IMeterFactory meterFactory");

        string baseParams = GenerateBaseConstructorParameters(classInfo.BaseConstructorParameters);
        if (!string.IsNullOrEmpty(baseParams))
        {
            sb.Append(baseParams);
        }

        sb.Append(")");

        string baseCall = GenerateBaseConstructorCall(classInfo.BaseConstructorParameters);
        if (!string.IsNullOrEmpty(baseCall))
        {
            sb.AppendLine()
                .Append(baseCall);
        }
        else
        {
            sb.AppendLine();
        }

        sb.AppendLine()
            .AppendLine("    {")
            .AppendLine("        global::System.ArgumentNullException.ThrowIfNull(activitySource);")
            .AppendLine("        global::System.ArgumentNullException.ThrowIfNull(meterFactory);")
            .AppendLine()
            .AppendLine("        _activitySource = activitySource;")
            .AppendLine("        _logger = logger;")
            .AppendLine()
            .AppendLine("        // Meter 및 Metrics 초기화")
            .AppendLine("        string categoryLower = this.RequestCategory?.ToLowerInvariant() ?? \"adapter\";")
            .AppendLine("        var meter = meterFactory.Create($\"adapter.{categoryLower}\");")
            .AppendLine("        _requestCounter = meter.CreateCounter<long>($\"adapter.{categoryLower}.requests\", \"{request}\", \"Total number of adapter requests\");")
            .AppendLine("        _responseCounter = meter.CreateCounter<long>($\"adapter.{categoryLower}.responses\", \"{response}\", \"Total number of adapter responses\");")
            .AppendLine("        _durationHistogram = meter.CreateHistogram<double>($\"adapter.{categoryLower}.duration\", \"s\", \"Duration of adapter execution in seconds\");")
            .AppendLine()
            .AppendLine("        _isDebugEnabled = logger.IsEnabled(LogLevel.Debug);")
            .AppendLine("        _isInformationEnabled = logger.IsEnabled(LogLevel.Information);")
            .AppendLine("        _isWarningEnabled = logger.IsEnabled(LogLevel.Warning);")
            .AppendLine("        _isErrorEnabled = logger.IsEnabled(LogLevel.Error);")
            .AppendLine("    }")
            .AppendLine();

        // 헬퍼 메서드들 추가
        GenerateHelperMethods(sb, classInfo);

        // 메서드들 생성
        foreach (var method in classInfo.Methods)
        {
            GenerateMethod(sb, classInfo, method);
        }

        sb.AppendLine("}")
            .AppendLine()
            .AppendLine($"internal static class {classInfo.ClassName}PipelineLoggers")
            .AppendLine("{");

        // 로깅 확장 메서드들 생성
        foreach (var method in classInfo.Methods)
        {
            GenerateLoggingMethods(sb, classInfo, method);
        }

        sb.AppendLine("}")
            .AppendLine();

        return sb.ToString();
    }

    /// <summary>
    /// 부모 생성자 파라미터 선언을 생성합니다.
    /// </summary>
    private static string GenerateBaseConstructorParameters(List<ParameterInfo> baseConstructorParameters)
    {
        if (baseConstructorParameters.Count == 0)
        {
            return string.Empty;
        }

        var resolvedParams = ParameterNameResolver.ResolveNames(baseConstructorParameters);

        var parameters = resolvedParams
            .Select(p => $",\n        {p.Original.Type} {p.ResolvedName}")
            .ToList();

        return string.Join("", parameters);
    }

    /// <summary>
    /// 부모 생성자 호출 코드를 생성합니다.
    /// </summary>
    private static string GenerateBaseConstructorCall(List<ParameterInfo> baseConstructorParameters)
    {
        if (baseConstructorParameters.Count == 0)
        {
            return string.Empty;
        }

        var resolvedParams = ParameterNameResolver.ResolveNames(baseConstructorParameters);
        var parameterNames = resolvedParams.Select(p => p.ResolvedName);

        return $"        : base({string.Join(", ", parameterNames)})";
    }

    /// <summary>
    /// FinT&lt;A, B&gt; 형태에서 실제 반환 타입 B를 추출합니다.
    /// </summary>
    private static string ExtractActualReturnType(string returnType)
    {
        return TypeExtractor.ExtractSecondTypeParameter(returnType);
    }

    private static void GenerateHelperMethods(StringBuilder sb, PipelineClassInfo classInfo)
    {
        sb.AppendLine("    private static global::LanguageExt.IO<A> FinTToIO<A>(global::LanguageExt.FinT<global::LanguageExt.IO, A> finT) =>")
            .AppendLine("        ((global::LanguageExt.IO<global::LanguageExt.IO<A>>)finT.Match(")
            .AppendLine("            Succ: value => global::LanguageExt.IO.pure(value),")
            .AppendLine("            Fail: global::LanguageExt.IO.fail<A>")
            .AppendLine("        )).Flatten();")
            .AppendLine()
            .AppendLine("    private global::LanguageExt.IO<A> ExecuteWithSpan<A>(")
            .AppendLine("            string requestHandler,")
            .AppendLine("            string requestHandlerMethod,")
            .AppendLine("            global::LanguageExt.IO<A> operation,")
            .AppendLine("            global::System.Func<global::LanguageExt.IO<global::LanguageExt.Unit>> requestLog,")
            .AppendLine("            global::System.Action<string, string, A, double> responseLogSuccess,")
            .AppendLine("            global::System.Action<string, string, global::LanguageExt.Common.Error, double> responseLogFailure,")
            .AppendLine("            long startTimestamp) =>")
            .AppendLine("        AcquireActivity(requestHandler, requestHandlerMethod)")
            .AppendLine("            .Bracket(")
            .AppendLine("                Use: activity =>")
            .AppendLine("                    from _logged in requestLog()")
            .AppendLine("                    from result in ExecuteOperationWithErrorHandling(")
            .AppendLine("                        requestHandler,")
            .AppendLine("                        requestHandlerMethod,")
            .AppendLine("                        operation,")
            .AppendLine("                        activity,")
            .AppendLine("                        responseLogSuccess,")
            .AppendLine("                        responseLogFailure,")
            .AppendLine("                        startTimestamp)")
            .AppendLine("                    select result,")
            .AppendLine("                Fin: activity => global::LanguageExt.IO.lift(() =>")
            .AppendLine("                {")
            .AppendLine("                    activity?.Dispose();")
            .AppendLine("                    return global::LanguageExt.Unit.Default;")
            .AppendLine("                }));")
            .AppendLine()
            .AppendLine("    private global::LanguageExt.IO<A> ExecuteOperationWithErrorHandling<A>(")
            .AppendLine("        string requestHandler,")
            .AppendLine("        string requestHandlerMethod,")
            .AppendLine("        global::LanguageExt.IO<A> operation,")
            .AppendLine("        Activity? activity,")
            .AppendLine("        global::System.Action<string, string, A, double> responseLogSuccess,")
            .AppendLine("        global::System.Action<string, string, global::LanguageExt.Common.Error, double> responseLogFailure,")
            .AppendLine("        long startTimestamp) =>")
            .AppendLine("        operation")
            .AppendLine("            .Bind(result =>")
            .AppendLine("                from _ in global::LanguageExt.IO.lift(() =>")
            .AppendLine("                {")
            .AppendLine("                    double elapsed = ElapsedTimeCalculator.CalculateElapsedSeconds(startTimestamp);")
            .AppendLine("                    responseLogSuccess(requestHandler, requestHandlerMethod, result, elapsed);")
            .AppendLine("                    RecordActivitySuccess(activity, requestHandlerMethod, elapsed);")
            .AppendLine("                    return global::LanguageExt.Unit.Default;")
            .AppendLine("                })")
            .AppendLine("                select result)")
            .AppendLine("            .IfFail(error =>")
            .AppendLine("                HandleOperationFailure<A>(requestHandler, requestHandlerMethod, error, activity, startTimestamp, responseLogFailure));")
            .AppendLine()
            .AppendLine("    private global::LanguageExt.IO<A> HandleOperationFailure<A>(")
            .AppendLine("        string requestHandler,")
            .AppendLine("        string requestHandlerMethod,")
            .AppendLine("        global::LanguageExt.Common.Error error,")
            .AppendLine("        Activity? activity,")
            .AppendLine("        long startTimestamp,")
            .AppendLine("        global::System.Action<string, string, global::LanguageExt.Common.Error, double> responseLogFailure)")
            .AppendLine("    {")
            .AppendLine("        double elapsed = ElapsedTimeCalculator.CalculateElapsedSeconds(startTimestamp);")
            .AppendLine("        responseLogFailure(requestHandler, requestHandlerMethod, error, elapsed);")
            .AppendLine("        RecordActivityFailure(activity, requestHandlerMethod, error, elapsed);")
            .AppendLine("        return global::LanguageExt.IO.fail<A>(error);")
            .AppendLine("    }")
            .AppendLine()
            .AppendLine("    private global::LanguageExt.IO<Activity?> AcquireActivity(string requestHandler, string requestHandlerMethod) =>")
            .AppendLine("        global::LanguageExt.IO.lift(() =>")
            .AppendLine("        {")
            .AppendLine("            string operationName = ObservabilityNaming.Spans.OperationName(")
            .AppendLine("                ObservabilityNaming.Layers.Adapter,")
            .AppendLine($"                this.GetRequestCategoryPascalCase(),")
            .AppendLine("                requestHandler,")
            .AppendLine("                requestHandlerMethod);")
            .AppendLine()
            .AppendLine("            // TagList: 구조체로 스택에 할당되어 GC 부담 최소화")
            .AppendLine("            TagList tags = new()")
            .AppendLine("            {")
            .AppendLine("                { ObservabilityNaming.CustomAttributes.RequestLayer, ObservabilityNaming.Layers.Adapter },")
            .AppendLine($"                {{ ObservabilityNaming.CustomAttributes.RequestCategory, this.GetRequestCategoryPascalCase() }},")
            .AppendLine("                { ObservabilityNaming.CustomAttributes.RequestHandler, requestHandler },")
            .AppendLine("                { ObservabilityNaming.CustomAttributes.RequestHandlerMethod, requestHandlerMethod }")
            .AppendLine("            };")
            .AppendLine()
            .AppendLine("            // Activity.Current를 부모로 사용 (표준 OpenTelemetry 동작)")
            .AppendLine("            var parentContext = Activity.Current?.Context ?? default;")
            .AppendLine("            var activity = _activitySource.StartActivity(")
            .AppendLine("                operationName,")
            .AppendLine("                ActivityKind.Internal,")
            .AppendLine("                parentContext,")
            .AppendLine("                tags);")
            .AppendLine()
            .AppendLine("            // Metrics 기록")
            .AppendLine("            TagList metricTags = new()")
            .AppendLine("            {")
            .AppendLine("                { ObservabilityNaming.CustomAttributes.RequestLayer, ObservabilityNaming.Layers.Adapter },")
            .AppendLine($"                {{ ObservabilityNaming.CustomAttributes.RequestCategory, this.GetRequestCategoryPascalCase() }},")
            .AppendLine("                { ObservabilityNaming.CustomAttributes.RequestHandler, requestHandler },")
            .AppendLine("                { ObservabilityNaming.CustomAttributes.RequestHandlerMethod, requestHandlerMethod }")
            .AppendLine("            };")
            .AppendLine("            _requestCounter.Add(1, metricTags);")
            .AppendLine()
            .AppendLine("            return activity;")
            .AppendLine("        });")
            .AppendLine()
            .AppendLine("    private void RecordActivitySuccess(Activity? activity, string requestHandlerMethod, double elapsed)")
            .AppendLine("    {")
            .AppendLine("        TagList metricTags = new()")
            .AppendLine("        {")
            .AppendLine("            { ObservabilityNaming.CustomAttributes.RequestLayer, ObservabilityNaming.Layers.Adapter },")
            .AppendLine($"            {{ ObservabilityNaming.CustomAttributes.RequestCategory, this.GetRequestCategoryPascalCase() }},")
            .AppendLine("            { ObservabilityNaming.CustomAttributes.RequestHandler, RequestHandler },")
            .AppendLine("            { ObservabilityNaming.CustomAttributes.RequestHandlerMethod, requestHandlerMethod },")
            .AppendLine("            { ObservabilityNaming.CustomAttributes.ResponseStatus, ObservabilityNaming.Status.Success }")
            .AppendLine("        };")
            .AppendLine("        _responseCounter.Add(1, metricTags);")
            .AppendLine("        _durationHistogram.Record(elapsed, metricTags);")
            .AppendLine()
            .AppendLine("        activity?.SetTag(ObservabilityNaming.CustomAttributes.ResponseElapsed, elapsed);")
            .AppendLine("        activity?.SetTag(ObservabilityNaming.CustomAttributes.ResponseStatus, ObservabilityNaming.Status.Success);")
            .AppendLine("        activity?.SetStatus(ActivityStatusCode.Ok);")
            .AppendLine("    }")
            .AppendLine()
            .AppendLine("    private void RecordActivityFailure(Activity? activity, string requestHandlerMethod, global::LanguageExt.Common.Error error, double elapsed)")
            .AppendLine("    {")
            .AppendLine("        var (errorType, errorCode) = GetErrorInfo(error);")
            .AppendLine()
            .AppendLine("        TagList metricTags = new()")
            .AppendLine("        {")
            .AppendLine("            { ObservabilityNaming.CustomAttributes.RequestLayer, ObservabilityNaming.Layers.Adapter },")
            .AppendLine($"            {{ ObservabilityNaming.CustomAttributes.RequestCategory, this.GetRequestCategoryPascalCase() }},")
            .AppendLine("            { ObservabilityNaming.CustomAttributes.RequestHandler, RequestHandler },")
            .AppendLine("            { ObservabilityNaming.CustomAttributes.RequestHandlerMethod, requestHandlerMethod },")
            .AppendLine("            { ObservabilityNaming.CustomAttributes.ResponseStatus, ObservabilityNaming.Status.Failure },")
            .AppendLine("            { ObservabilityNaming.OTelAttributes.ErrorType, errorType },")
            .AppendLine("            { ObservabilityNaming.CustomAttributes.ErrorCode, errorCode }")
            .AppendLine("        };")
            .AppendLine("        _responseCounter.Add(1, metricTags);")
            .AppendLine("        _durationHistogram.Record(elapsed, metricTags);")
            .AppendLine()
            .AppendLine("        activity?.SetTag(ObservabilityNaming.CustomAttributes.ResponseElapsed, elapsed);")
            .AppendLine("        activity?.SetTag(ObservabilityNaming.CustomAttributes.ResponseStatus, ObservabilityNaming.Status.Failure);")
            .AppendLine("        activity?.SetTag(ObservabilityNaming.OTelAttributes.ErrorType, errorType);")
            .AppendLine("        activity?.SetTag(ObservabilityNaming.CustomAttributes.ErrorCode, errorCode);")
            .AppendLine("        activity?.SetStatus(ActivityStatusCode.Error, $\"{errorType}: {errorCode}\");")
            .AppendLine("    }")
            .AppendLine()
            .AppendLine("    private string GetRequestCategoryPascalCase() =>")
            .AppendLine("        string.IsNullOrEmpty(this.RequestCategory)")
            .AppendLine("            ? string.Empty")
            .AppendLine("            : char.ToUpper(this.RequestCategory[0]) + this.RequestCategory.Substring(1).ToLower();")
            .AppendLine()
            .AppendLine("    /// <summary>")
            .AppendLine("    /// 에러 정보(타입, 코드)를 추출합니다.")
            .AppendLine("    /// </summary>")
            .AppendLine("    private static (string ErrorType, string ErrorCode) GetErrorInfo(global::LanguageExt.Common.Error error)")
            .AppendLine("    {")
            .AppendLine("        return error switch")
            .AppendLine("        {")
            .AppendLine("            // ManyErrors - 복합 에러")
            .AppendLine("            global::LanguageExt.Common.ManyErrors many => (")
            .AppendLine("                ErrorType: ObservabilityNaming.ErrorTypes.Aggregate,")
            .AppendLine("                ErrorCode: GetPrimaryErrorCode(many)")
            .AppendLine("            ),")
            .AppendLine("            // IHasErrorCode - ErrorCode가 있는 에러 (IsExceptional로 타입 구분)")
            .AppendLine("            global::Functorium.Abstractions.Errors.IHasErrorCode hasErrorCode => (")
            .AppendLine("                ErrorType: error.IsExceptional")
            .AppendLine("                    ? ObservabilityNaming.ErrorTypes.Exceptional")
            .AppendLine("                    : ObservabilityNaming.ErrorTypes.Expected,")
            .AppendLine("                ErrorCode: hasErrorCode.ErrorCode")
            .AppendLine("            ),")
            .AppendLine("            // Fallback - 알 수 없는 에러 타입")
            .AppendLine("            _ => (")
            .AppendLine("                ErrorType: error.IsExceptional")
            .AppendLine("                    ? ObservabilityNaming.ErrorTypes.Exceptional")
            .AppendLine("                    : ObservabilityNaming.ErrorTypes.Expected,")
            .AppendLine("                ErrorCode: error.GetType().Name")
            .AppendLine("            )")
            .AppendLine("        };")
            .AppendLine("    }")
            .AppendLine()
            .AppendLine("    /// <summary>")
            .AppendLine("    /// ManyErrors에서 대표 에러 코드를 선정합니다.")
            .AppendLine("    /// 우선순위: Exceptional > First > \"ManyErrors\"")
            .AppendLine("    /// </summary>")
            .AppendLine("    private static string GetPrimaryErrorCode(global::LanguageExt.Common.ManyErrors many)")
            .AppendLine("    {")
            .AppendLine("        // 1순위: Exceptional 에러 (시스템 에러가 더 심각)")
            .AppendLine("        foreach (var e in many.Errors)")
            .AppendLine("        {")
            .AppendLine("            if (e.IsExceptional)")
            .AppendLine("                return GetErrorCode(e);")
            .AppendLine("        }")
            .AppendLine()
            .AppendLine("        // 2순위: 첫 번째 에러")
            .AppendLine("        return many.Errors.Head.Match(")
            .AppendLine("            Some: GetErrorCode,")
            .AppendLine("            None: () => nameof(global::LanguageExt.Common.ManyErrors));")
            .AppendLine("    }")
            .AppendLine()
            .AppendLine("    /// <summary>")
            .AppendLine("    /// 단일 에러에서 에러 코드를 추출합니다.")
            .AppendLine("    /// </summary>")
            .AppendLine("    private static string GetErrorCode(global::LanguageExt.Common.Error error)")
            .AppendLine("    {")
            .AppendLine("        return error switch")
            .AppendLine("        {")
            .AppendLine("            global::Functorium.Abstractions.Errors.IHasErrorCode hasErrorCode => hasErrorCode.ErrorCode,")
            .AppendLine("            _ => error.GetType().Name")
            .AppendLine("        };")
            .AppendLine("    }")
            .AppendLine();
    }

    private static void GenerateMethod(StringBuilder sb, PipelineClassInfo classInfo, MethodInfo method)
    {
        // 파라미터에서 반환 타입 추출 (FinT<IO, ReturnType>에서 ReturnType 추출)
        // global::LanguageExt.FinT<global::LanguageExt.IO, global::Observability.Application.Usecases.GenResult> 형태 처리
        string actualReturnType = ExtractActualReturnType(method.ReturnType);

        // 글로벌 네임스페이스 접두사는 유지 (global::Namespace.Type 형태 유지)

        // 메서드 시그니처
        sb.AppendLine($"    public override {method.ReturnType} {method.Name}(");
        for (int i = 0; i < method.Parameters.Count; i++)
        {
            var param = method.Parameters[i];
            var comma = i < method.Parameters.Count - 1 ? "," : "";
            sb.AppendLine($"        {param.Type} {param.Name}{comma}");
        }
        // method.ReturnType은 global::LanguageExt.FinT<global::LanguageExt.IO, ActualType> 형태
        // actualReturnType은 ActualType 부분만 추출한 것
        var actualReturnTypeForMethod = ExtractActualReturnType(method.ReturnType);
        sb.AppendLine("    ) =>")
            .AppendLine($"        global::LanguageExt.FinT.lift<global::LanguageExt.IO, {actualReturnTypeForMethod}>(")
            .AppendLine("            (from result in ExecuteWithSpan(")
            .AppendLine($"                requestHandler: RequestHandler,")
            .AppendLine($"                requestHandlerMethod: nameof({method.Name}),")
            .AppendLine($"                operation: FinTToIO(base.{method.Name}({string.Join(", ", method.Parameters.Select(p => p.Name))})),")
            .AppendLine($"                requestLog: () => RequestLog_{classInfo.ClassName}_{method.Name}(RequestHandler, nameof({method.Name}){(method.Parameters.Count > 0 ? ", " + string.Join(", ", method.Parameters.Select(p => p.Name)) : "")}),")
            .AppendLine($"                responseLogSuccess: ResponseLogSuccess_{classInfo.ClassName}_{method.Name},")
            .AppendLine($"                responseLogFailure: ResponseLogFailure_{classInfo.ClassName}_{method.Name},")
            .AppendLine("                startTimestamp: ElapsedTimeCalculator.GetCurrentTimestamp())")
            .AppendLine($"            select result).Map(r => global::LanguageExt.Fin.Succ(r)));")
            .AppendLine();

        // Request logging helper
        var parameterDeclarations = method.Parameters.Count > 0
            ? ",\n        " + string.Join(",\n        ", method.Parameters.Select(p => $"{p.Type} {p.Name}"))
            : "";
        sb.AppendLine($"    private global::LanguageExt.IO<global::LanguageExt.Unit> RequestLog_{classInfo.ClassName}_{method.Name}(")
            .AppendLine("        string requestHandler,")
            .Append("        string requestHandlerMethod")
            .AppendLine($"{parameterDeclarations}) =>")
            .AppendLine("        global::LanguageExt.IO.lift(() =>")
            .AppendLine("        {")
            .AppendLine("            if (_isDebugEnabled)")
            .AppendLine("            {")
            .AppendLine($"                _logger.LogRequestDebug_{classInfo.ClassName}_{method.Name}(")
            .AppendLine("                    ObservabilityNaming.Layers.Adapter,")
            .AppendLine($"                    this.GetRequestCategoryPascalCase(),")
            .AppendLine("                    requestHandler,")
            .Append("                    requestHandlerMethod")
            .AppendLine($"{(method.Parameters.Count > 0 ? ",\n                    " + string.Join(", ", method.Parameters.Select(p => p.Name)) : "")});")
            .AppendLine("            }")
            .AppendLine("            else if (_isInformationEnabled)")
            .AppendLine("            {")
            .AppendLine($"                _logger.LogRequest_{classInfo.ClassName}_{method.Name}(")
            .AppendLine("                    ObservabilityNaming.Layers.Adapter,")
            .AppendLine($"                    this.GetRequestCategoryPascalCase(),")
            .AppendLine("                    requestHandler,")
            .AppendLine("                    requestHandlerMethod);")
            .AppendLine("            }")
            .AppendLine("            return global::LanguageExt.Unit.Default;")
            .AppendLine("        });")
            .AppendLine();

        // Response success logging helper
        sb.AppendLine($"    private void ResponseLogSuccess_{classInfo.ClassName}_{method.Name}(")
            .AppendLine("        string requestHandler,")
            .AppendLine("        string requestHandlerMethod,")
            .AppendLine($"        {actualReturnType} result,")
            .AppendLine("        double elapsed)")
            .AppendLine("    {")
            .AppendLine("        if (_isDebugEnabled)")
            .AppendLine("        {")
            .AppendLine($"            _logger.LogResponseDebug_{classInfo.ClassName}_{method.Name}(")
            .AppendLine("                ObservabilityNaming.Layers.Adapter,")
            .AppendLine($"                this.GetRequestCategoryPascalCase(),")
            .AppendLine("                requestHandler,")
            .AppendLine("                requestHandlerMethod,")
            .AppendLine("                ObservabilityNaming.Status.Success,")
            .AppendLine("                result,")
            .AppendLine("                elapsed);")
            .AppendLine("        }")
            .AppendLine("        else if (_isInformationEnabled)")
            .AppendLine("        {")
            .AppendLine($"            _logger.LogResponse_{classInfo.ClassName}_{method.Name}(")
            .AppendLine("                ObservabilityNaming.Layers.Adapter,")
            .AppendLine($"                this.GetRequestCategoryPascalCase(),")
            .AppendLine("                requestHandler,")
            .AppendLine("                requestHandlerMethod,")
            .AppendLine("                ObservabilityNaming.Status.Success,")
            .AppendLine("                elapsed);")
            .AppendLine("        }")
            .AppendLine("    }")
            .AppendLine();

        // Response failure logging helper
        sb.AppendLine($"    private void ResponseLogFailure_{classInfo.ClassName}_{method.Name}(")
            .AppendLine("        string requestHandler,")
            .AppendLine("        string requestHandlerMethod,")
            .AppendLine("        global::LanguageExt.Common.Error error,")
            .AppendLine("        double elapsed)")
            .AppendLine("    {")
            .AppendLine("        if (error.IsExceptional && _isErrorEnabled)")
            .AppendLine("        {")
            .AppendLine($"            _logger.LogResponseError_{classInfo.ClassName}_{method.Name}(")
            .AppendLine("                ObservabilityNaming.Layers.Adapter,")
            .AppendLine($"                this.GetRequestCategoryPascalCase(),")
            .AppendLine("                requestHandler,")
            .AppendLine("                requestHandlerMethod,")
            .AppendLine("                ObservabilityNaming.Status.Failure,")
            .AppendLine("                elapsed,")
            .AppendLine("                error);")
            .AppendLine("        }")
            .AppendLine("        else if (_isWarningEnabled)")
            .AppendLine("        {")
            .AppendLine($"            _logger.LogResponseWarning_{classInfo.ClassName}_{method.Name}(")
            .AppendLine("                ObservabilityNaming.Layers.Adapter,")
            .AppendLine($"                this.GetRequestCategoryPascalCase(),")
            .AppendLine("                requestHandler,")
            .AppendLine("                requestHandlerMethod,")
            .AppendLine("                ObservabilityNaming.Status.Failure,")
            .AppendLine("                elapsed,")
            .AppendLine("                error);")
            .AppendLine("        }")
            .AppendLine("    }");
    }

    private static void GenerateLoggingMethods(StringBuilder sb, PipelineClassInfo classInfo, MethodInfo method)
    {
        // 파라미터에서 반환 타입 추출
        // global::LanguageExt.FinT<global::LanguageExt.IO, global::Observability.Application.Usecases.GenResult> 형태 처리
        string actualReturnType = ExtractActualReturnType(method.ReturnType);

        // 글로벌 네임스페이스 접두사는 유지 (global::Namespace.Type 형태 유지)

        // ===== Static delegate fields for LoggerMessage.Define =====
        GenerateLoggerMessageDefineFields(sb, classInfo, method, actualReturnType);

        // ===== LogRequestDebug (파라미터 포함) =====
        var logRequestDebugParams = method.Parameters.Count > 0
            ? ",\n        " + string.Join(",\n        ", method.Parameters.Select(p => $"{p.Type} {p.Name}"))
            : "";
        sb.AppendLine($"    public static void LogRequestDebug_{classInfo.ClassName}_{method.Name}(")
            .AppendLine("        this ILogger logger,")
            .AppendLine("        string requestLayer,")
            .AppendLine("        string requestCategory,")
            .AppendLine("        string requestHandler,")
            .Append("        string requestHandlerMethod")
            .AppendLine($"{logRequestDebugParams})")
            .AppendLine("    {")
            .AppendLine("        if (!logger.IsEnabled(LogLevel.Debug))")
            .AppendLine("            return;")
            .AppendLine();

        // ===== LoggerMessage.Define vs logger.LogDebug() 선택 로직 =====
        //
        // .NET의 LoggerMessage.Define은 제네릭 타입 파라미터가 최대 6개까지만 지원됩니다.
        // 이는 .NET Framework의 API 설계 제약 사항으로, 7개 이상의 오버로드는 제공되지 않습니다.
        //
        // 파라미터 개수 = 기본 4개 (requestLayer, requestCategory, requestHandler, requestHandlerMethod)
        //               + 메서드 파라미터 개수
        //               + 컬렉션 타입 파라미터의 Count 필드 개수
        //
        // 예시:
        //   - GetFile(int ms)                                    → 5개 (4 + 1)        ✅ LoggerMessage.Define
        //   - GetData(int id, string name)                       → 6개 (4 + 2)        ✅ LoggerMessage.Define
        //   - GetResult(int ms, string[] arr, List<T> list)      → 9개 (4 + 1 + 2 + 2) ❌ logger.LogDebug()
        //
        // 성능 차이:
        //   - LoggerMessage.Define: 제로 할당, 미리 컴파일된 delegate, 박싱 없음
        //   - logger.LogDebug():    params 배열 할당, 값 타입 박싱, 매 호출마다 템플릿 파싱
        //
        int totalDebugRequestParams = 4 + method.Parameters.Count + method.Parameters.Count(p => p.IsCollection);

        if (totalDebugRequestParams <= 6)
        {
            // ✅ 고성능 경로: LoggerMessage.Define 사용 (파라미터 ≤ 6개)
            sb.Append($"        _logRequestDebug_{classInfo.ClassName}_{method.Name}(logger, requestLayer, requestCategory, requestHandler, requestHandlerMethod");

            foreach (var param in method.Parameters)
            {
                sb.Append($", {param.Name}");
                if (param.IsCollection)
                {
                    if (CollectionTypeHelper.GetCountExpression(param.Name, param.Type) is { } countExpression)
                    {
                        sb.Append($", {countExpression}");
                    }
                }
            }

            sb.AppendLine(", null);");
        }
        else
        {
            // ⚠️ 폴백 경로: logger.LogDebug() 직접 사용 (파라미터 > 6개)
            //
            // LoggerMessage.Define의 제약으로 인해 일반 로깅 메서드 사용
            // 이 경우 약간의 성능 오버헤드가 발생하지만, 기능상 문제는 없습니다.
            //
            // 메시지 템플릿 구성: 첫 번째 줄
            sb.Append("        logger.LogDebug(")
                .AppendLine()
                .AppendLine("            eventId: ObservabilityNaming.EventIds.Adapter.AdapterRequest,")
                .Append("            message: \"{request.layer} {request.category} {request.handler}.{request.handler.method} \" +");

            // 두 번째 줄: 동적 파라미터 필드들
            sb.AppendLine();
            sb.Append("                     \"");

            var messageTemplateFields = new List<string>();
            foreach (var param in method.Parameters)
            {
                string requestFieldName = CollectionTypeHelper.GetRequestFieldName(param.Name);
                messageTemplateFields.Add($"{{{requestFieldName}}}");

                if (param.IsCollection)
                {
                    if (CollectionTypeHelper.GetRequestCountFieldName(param.Name) is { } countFieldName)
                    {
                        messageTemplateFields.Add($"{{{countFieldName}}}");
                    }
                }
            }

            sb.Append(string.Join(" ", messageTemplateFields));
            sb.AppendLine(" \" +");

            // 세 번째 줄: 종료
            sb.AppendLine("                     \"requesting\",");

            // 파라미터 전달
            sb.AppendLine("            requestLayer, requestCategory, requestHandler, requestHandlerMethod,");

            // 모든 파라미터와 Count 값 전달
            var logParameters = new List<string>();
            foreach (var param in method.Parameters)
            {
                logParameters.Add(param.Name);

                if (param.IsCollection)
                {
                    if (CollectionTypeHelper.GetCountExpression(param.Name, param.Type) is { } countExpression)
                    {
                        logParameters.Add(countExpression);
                    }
                }
            }

            sb.AppendLine($"            {string.Join(", ", logParameters)});");
        }

        sb.AppendLine("    }")
            .AppendLine();

        // ===== LogRequest (파라미터 제외) =====
        sb.AppendLine($"    public static void LogRequest_{classInfo.ClassName}_{method.Name}(")
            .AppendLine("        this ILogger logger,")
            .AppendLine("        string requestLayer,")
            .AppendLine("        string requestCategory,")
            .AppendLine("        string requestHandler,")
            .AppendLine("        string requestHandlerMethod)")
            .AppendLine("    {")
            .AppendLine("        if (!logger.IsEnabled(LogLevel.Information))")
            .AppendLine("            return;")
            .AppendLine()
            .AppendLine($"        _logRequest_{classInfo.ClassName}_{method.Name}(logger, requestLayer, requestCategory, requestHandler, requestHandlerMethod, null);")
            .AppendLine("    }")
            .AppendLine();

        // ===== LogResponseDebug (result 포함) =====
        sb.AppendLine($"    public static void LogResponseDebug_{classInfo.ClassName}_{method.Name}(")
            .AppendLine("        this ILogger logger,")
            .AppendLine("        string requestLayer,")
            .AppendLine("        string requestCategory,")
            .AppendLine("        string requestHandler,")
            .AppendLine("        string requestHandlerMethod,")
            .AppendLine("        string status,")
            .AppendLine($"        {actualReturnType} result,")
            .AppendLine("        double elapsed)")
            .AppendLine("    {")
            .AppendLine("        if (!logger.IsEnabled(LogLevel.Debug))")
            .AppendLine("            return;")
            .AppendLine();

        // 파라미터 개수 계산
        int debugResponseParams = 6; // layer, category, handler, method, status, elapsed
        if (CollectionTypeHelper.IsCollectionType(actualReturnType))
        {
            debugResponseParams += 2; // result + count
        }
        else
        {
            debugResponseParams += 1; // result only
        }

        if (debugResponseParams <= 6)
        {
            // LoggerMessage.Define 사용
            sb.Append($"        _logResponseDebug_{classInfo.ClassName}_{method.Name}(logger, requestLayer, requestCategory, requestHandler, requestHandlerMethod, status");

            if (CollectionTypeHelper.IsCollectionType(actualReturnType))
            {
                if (CollectionTypeHelper.GetCountExpression("result", actualReturnType) is { } countExpression)
                {
                    sb.AppendLine($", result, {countExpression}, elapsed, null);");
                }
                else
                {
                    sb.AppendLine(", result, elapsed, null);");
                }
            }
            else
            {
                sb.AppendLine(", result, elapsed, null);");
            }
        }
        else
        {
            // 기존 방식 유지 (6개 초과 - 컬렉션 + result인 경우)
            // 메시지 템플릿 구성: 첫 번째 줄
            sb.Append("        logger.LogDebug(")
                .AppendLine()
                .AppendLine("            eventId: ObservabilityNaming.EventIds.Adapter.AdapterResponseSuccess,")
                .Append("            message: \"{request.layer} {request.category} {request.handler}.{request.handler.method} \" +");

            // 두 번째 줄: Response 필드들
            sb.AppendLine();
            sb.Append("                     \"");

            string responseFieldName = CollectionTypeHelper.GetResponseFieldName();
            sb.Append($"{{{responseFieldName}}}");

            // 반환 타입이 컬렉션이면 Count도 추가
            if (CollectionTypeHelper.IsCollectionType(actualReturnType))
            {
                string countFieldName = CollectionTypeHelper.GetResponseCountFieldName();
                sb.Append($" {{{countFieldName}}}");
            }

            sb.AppendLine(" \" +");

            // 세 번째 줄: 종료
            sb.AppendLine("                     \"responded {response.status} in {response.elapsed:0.0000} s\",");

            // 파라미터 전달
            sb.Append("            requestLayer, requestCategory, requestHandler, requestHandlerMethod, ");
            sb.Append("result");

            // Count 값 추가
            if (CollectionTypeHelper.IsCollectionType(actualReturnType))
            {
                if (CollectionTypeHelper.GetCountExpression("result", actualReturnType) is { } countExpression)
                {
                    sb.Append($", {countExpression}");
                }
            }

            sb.AppendLine(", status, elapsed);");
        }

        sb.AppendLine("    }")
            .AppendLine();

        // ===== LogResponse (result 제외) =====
        sb.AppendLine($"    public static void LogResponse_{classInfo.ClassName}_{method.Name}(")
            .AppendLine("        this ILogger logger,")
            .AppendLine("        string requestLayer,")
            .AppendLine("        string requestCategory,")
            .AppendLine("        string requestHandler,")
            .AppendLine("        string requestHandlerMethod,")
            .AppendLine("        string status,")
            .AppendLine("        double elapsed)")
            .AppendLine("    {")
            .AppendLine("        if (!logger.IsEnabled(LogLevel.Information))")
            .AppendLine("            return;")
            .AppendLine()
            .AppendLine($"        _logResponse_{classInfo.ClassName}_{method.Name}(logger, requestLayer, requestCategory, requestHandler, requestHandlerMethod, status, elapsed, null);")
            .AppendLine("    }")
            .AppendLine();

        // ===== LogResponseWarning =====
        sb.AppendLine($"    public static void LogResponseWarning_{classInfo.ClassName}_{method.Name}(")
            .AppendLine("        this ILogger logger,")
            .AppendLine("        string requestLayer,")
            .AppendLine("        string requestCategory,")
            .AppendLine("        string requestHandler,")
            .AppendLine("        string requestHandlerMethod,")
            .AppendLine("        string status,")
            .AppendLine("        double elapsed,")
            .AppendLine("        global::LanguageExt.Common.Error error)")
            .AppendLine("    {")
            .AppendLine("        if (!logger.IsEnabled(LogLevel.Warning))")
            .AppendLine("            return;")
            .AppendLine()
            .AppendLine($"        _logResponseWarning_{classInfo.ClassName}_{method.Name}(logger, requestLayer, requestCategory, requestHandler, requestHandlerMethod, elapsed, error, null);")
            .AppendLine("    }")
            .AppendLine();

        // ===== LogResponseError =====
        sb.AppendLine($"    public static void LogResponseError_{classInfo.ClassName}_{method.Name}(")
            .AppendLine("        this ILogger logger,")
            .AppendLine("        string requestLayer,")
            .AppendLine("        string requestCategory,")
            .AppendLine("        string requestHandler,")
            .AppendLine("        string requestHandlerMethod,")
            .AppendLine("        string status,")
            .AppendLine("        double elapsed,")
            .AppendLine("        global::LanguageExt.Common.Error error)")
            .AppendLine("    {")
            .AppendLine("        if (!logger.IsEnabled(LogLevel.Error))")
            .AppendLine("            return;")
            .AppendLine()
            .AppendLine($"        _logResponseError_{classInfo.ClassName}_{method.Name}(logger, requestLayer, requestCategory, requestHandler, requestHandlerMethod, elapsed, error, null);")
            .AppendLine("    }");
    }

    /// <summary>
    /// LoggerMessage.Define을 사용한 정적 delegate 필드들을 생성합니다.
    /// </summary>
    private static void GenerateLoggerMessageDefineFields(StringBuilder sb, PipelineClassInfo classInfo, MethodInfo method, string actualReturnType)
    {
        sb.AppendLine();
        sb.AppendLine($"    // ===== LoggerMessage.Define delegates for {method.Name} =====");

        // 1. LogRequest (4 params)
        GenerateLogRequestDelegate(sb, classInfo, method);

        // 2. LogRequestDebug (4+ params, dynamic)
        GenerateLogRequestDebugDelegate(sb, classInfo, method);

        // 3. LogResponse (6 params without status hardcoding, 7 with status)
        GenerateLogResponseDelegate(sb, classInfo, method);

        // 4. LogResponseDebug (depends on collection type)
        GenerateLogResponseDebugDelegate(sb, classInfo, method, actualReturnType);

        // 5. LogResponseWarning (6 params without status)
        GenerateLogResponseWarningDelegate(sb, classInfo, method);

        // 6. LogResponseError (6 params without status)
        GenerateLogResponseErrorDelegate(sb, classInfo, method);

        sb.AppendLine();
    }

    private static void GenerateLogRequestDelegate(StringBuilder sb, PipelineClassInfo classInfo, MethodInfo method)
    {
        sb.AppendLine($"    private static readonly global::System.Action<ILogger, string, string, string, string, global::System.Exception?> _logRequest_{classInfo.ClassName}_{method.Name} =");
        sb.AppendLine("        LoggerMessage.Define<string, string, string, string>(");
        sb.AppendLine("            LogLevel.Information,");
        sb.AppendLine("            ObservabilityNaming.EventIds.Adapter.AdapterRequest,");
        sb.AppendLine("            \"{request.layer} {request.category} {request.handler}.{request.handler.method} requesting\");");
        sb.AppendLine();
    }

    private static void GenerateLogRequestDebugDelegate(StringBuilder sb, PipelineClassInfo classInfo, MethodInfo method)
    {
        // ===== LoggerMessage.Define 제약 검사 =====
        //
        // .NET의 LoggerMessage.Define<T1, T2, ..., T6>은 최대 6개의 타입 파라미터만 지원합니다.
        // 이는 .NET Functorium/Core의 API 설계 제약으로, Microsoft가 의도적으로 6개까지만 오버로드를 제공합니다.
        //
        // 이유:
        //   1. 제네릭 타입 폭발 방지 (바이너리 크기 증가)
        //   2. API 복잡도 제한
        //   3. 실용적 균형점 (대부분 6개 이하로 충분)
        //
        // 6개 초과 시 LoggerMessage.Define을 사용할 수 없으므로 delegate를 생성하지 않고,
        // 호출 측에서 logger.LogDebug()를 직접 사용하도록 폴백합니다.
        //
        int totalParams = 4 + method.Parameters.Count + method.Parameters.Count(p => p.IsCollection);

        if (totalParams > 6)
        {
            // 6개 초과 시 delegate 생성하지 않음 (호출 측에서 logger.LogDebug() 직접 사용)
            return;
        }

        // 타입 파라미터 목록 생성
        var typeParams = new List<string> { "string", "string", "string", "string" };
        foreach (var param in method.Parameters)
        {
            typeParams.Add(param.Type);
            if (param.IsCollection)
            {
                typeParams.Add("int"); // count
            }
        }

        // 메시지 템플릿 생성
        var messageFields = new List<string> { "{request.layer}", "{request.category}", "{request.handler}.{request.handler.method}" };
        foreach (var param in method.Parameters)
        {
            string requestFieldName = CollectionTypeHelper.GetRequestFieldName(param.Name);
            messageFields.Add($"{{{requestFieldName}}}");

            if (param.IsCollection)
            {
                if (CollectionTypeHelper.GetRequestCountFieldName(param.Name) is { } countFieldName)
                {
                    messageFields.Add($"{{{countFieldName}}}");
                }
            }
        }
        messageFields.Add("requesting");

        string messageTemplate = string.Join(" ", messageFields);

        sb.AppendLine($"    private static readonly global::System.Action<ILogger, {string.Join(", ", typeParams)}, global::System.Exception?> _logRequestDebug_{classInfo.ClassName}_{method.Name} =");
        sb.AppendLine($"        LoggerMessage.Define<{string.Join(", ", typeParams)}>(");
        sb.AppendLine("            LogLevel.Debug,");
        sb.AppendLine("            ObservabilityNaming.EventIds.Adapter.AdapterRequest,");
        sb.AppendLine($"            \"{messageTemplate}\");");
        sb.AppendLine();
    }

    private static void GenerateLogResponseDelegate(StringBuilder sb, PipelineClassInfo classInfo, MethodInfo method)
    {
        sb.AppendLine($"    private static readonly global::System.Action<ILogger, string, string, string, string, string, double, global::System.Exception?> _logResponse_{classInfo.ClassName}_{method.Name} =");
        sb.AppendLine("        LoggerMessage.Define<string, string, string, string, string, double>(");
        sb.AppendLine("            LogLevel.Information,");
        sb.AppendLine("            ObservabilityNaming.EventIds.Adapter.AdapterResponseSuccess,");
        sb.AppendLine("            \"{request.layer} {request.category} {request.handler}.{request.handler.method} responded {response.status} in {response.elapsed:0.0000} s\");");
        sb.AppendLine();
    }

    private static void GenerateLogResponseDebugDelegate(StringBuilder sb, PipelineClassInfo classInfo, MethodInfo method, string actualReturnType)
    {
        // ===== LoggerMessage.Define 제약 검사 (Response용) =====
        //
        // Response 로그의 경우:
        //   - 기본: layer, category, handler, method, status, elapsed (6개)
        //   - result (일반 타입): +1개 → 총 7개 ✅ (status를 하드코딩하여 6개로 줄임)
        //   - result (컬렉션): +2개 (result + count) → 총 8개 ❌
        //
        // 컬렉션 반환 타입의 경우 8개가 되어 LoggerMessage.Define 사용 불가
        //
        int debugResponseParams = 6; // layer, category, handler, method, status, elapsed
        bool isCollection = CollectionTypeHelper.IsCollectionType(actualReturnType);

        if (isCollection)
        {
            debugResponseParams += 2; // result + count
        }
        else
        {
            debugResponseParams += 1; // result only
        }

        if (debugResponseParams > 6)
        {
            // 6개 초과 시 delegate 생성하지 않음 (호출 측에서 logger.LogDebug() 직접 사용)
            return;
        }

        // 타입 파라미터 목록
        var typeParams = new List<string> { "string", "string", "string", "string", "string", actualReturnType };
        string messageTemplate;

        if (isCollection)
        {
            typeParams.Add("int"); // count
            typeParams.Add("double"); // elapsed
            string responseFieldName = CollectionTypeHelper.GetResponseFieldName();
            string countFieldName = CollectionTypeHelper.GetResponseCountFieldName();
            messageTemplate = $"{{request.layer}} {{request.category}} {{request.handler}}.{{request.handler.method}} {{{responseFieldName}}} {{{countFieldName}}} responded {{response.status}} in {{response.elapsed:0.0000}} s";
        }
        else
        {
            typeParams.Add("double"); // elapsed
            string responseFieldName = CollectionTypeHelper.GetResponseFieldName();
            messageTemplate = $"{{request.layer}} {{request.category}} {{request.handler}}.{{request.handler.method}} {{{responseFieldName}}} responded {{response.status}} in {{response.elapsed:0.0000}} s";
        }

        sb.AppendLine($"    private static readonly global::System.Action<ILogger, {string.Join(", ", typeParams)}, global::System.Exception?> _logResponseDebug_{classInfo.ClassName}_{method.Name} =");
        sb.AppendLine($"        LoggerMessage.Define<{string.Join(", ", typeParams)}>(");
        sb.AppendLine("            LogLevel.Debug,");
        sb.AppendLine("            ObservabilityNaming.EventIds.Adapter.AdapterResponseSuccess,");
        sb.AppendLine($"            \"{messageTemplate}\");");
        sb.AppendLine();
    }

    private static void GenerateLogResponseWarningDelegate(StringBuilder sb, PipelineClassInfo classInfo, MethodInfo method)
    {
        // Status를 하드코딩하여 6개로 줄임: layer, category, handler, method, elapsed, error
        sb.AppendLine($"    private static readonly global::System.Action<ILogger, string, string, string, string, double, global::LanguageExt.Common.Error, global::System.Exception?> _logResponseWarning_{classInfo.ClassName}_{method.Name} =");
        sb.AppendLine("        LoggerMessage.Define<string, string, string, string, double, global::LanguageExt.Common.Error>(");
        sb.AppendLine("            LogLevel.Warning,");
        sb.AppendLine("            ObservabilityNaming.EventIds.Adapter.AdapterResponseWarning,");
        sb.AppendLine("            \"{request.layer} {request.category} {request.handler}.{request.handler.method} responded failure in {response.elapsed:0.0000} s with {@error}\");");
        sb.AppendLine();
    }

    private static void GenerateLogResponseErrorDelegate(StringBuilder sb, PipelineClassInfo classInfo, MethodInfo method)
    {
        // Status를 하드코딩하여 6개로 줄임: layer, category, handler, method, elapsed, error
        sb.AppendLine($"    private static readonly global::System.Action<ILogger, string, string, string, string, double, global::LanguageExt.Common.Error, global::System.Exception?> _logResponseError_{classInfo.ClassName}_{method.Name} =");
        sb.AppendLine("        LoggerMessage.Define<string, string, string, string, double, global::LanguageExt.Common.Error>(");
        sb.AppendLine("            LogLevel.Error,");
        sb.AppendLine("            ObservabilityNaming.EventIds.Adapter.AdapterResponseError,");
        sb.AppendLine("            \"{request.layer} {request.category} {request.handler}.{request.handler.method} responded failure in {response.elapsed:0.0000} s with {@error}\");");
        sb.AppendLine();
    }
}