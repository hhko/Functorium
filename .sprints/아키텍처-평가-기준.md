# ğŸ“Š ì•„í‚¤í…ì²˜ í‰ê°€ ê¸°ì¤€ (Architecture Evaluation Criteria)

> **ë²„ì „:** 1.0
> **ì‘ì„±ì¼:** 2026-01-07
> **ì‘ì„±ì:** ê³ í˜•í˜¸
> **ëª©ì :** Clean Architecture + Functional Programming êµ¬í˜„ì˜ ê°ê´€ì  í‰ê°€ ê¸°ì¤€ ì •ë¦½

---

## ğŸ“‘ ëª©ì°¨

1. [ê°œìš” (ë°°ê²½ ë° í•„ìš”ì„±)](#ê°œìš”-ë°°ê²½-ë°-í•„ìš”ì„±)
2. [í‰ê°€ í•­ëª© ì„ ì • ê¸°ì¤€](#í‰ê°€-í•­ëª©-ì„ ì •-ê¸°ì¤€)
3. [ê³µì‹ í‘œì¤€ê³¼ì˜ ë¹„êµ](#ê³µì‹-í‘œì¤€ê³¼ì˜-ë¹„êµ)
4. [í‰ê°€ í•­ëª© ê°œìš”](#í‰ê°€-í•­ëª©-ê°œìš”)
5. [í‰ê°€ ê¸°ì¤€ ìƒì„¸](#í‰ê°€-ê¸°ì¤€-ìƒì„¸)
   - [1. ë ˆì´ì–´ ë¶„ë¦¬](#1-ë ˆì´ì–´-ë¶„ë¦¬-layer-separation)
   - [2. ë„ë©”ì¸ ëª¨ë¸ë§](#2-ë„ë©”ì¸-ëª¨ë¸ë§-domain-modeling)
   - [3. ì—ëŸ¬ ì²˜ë¦¬](#3-ì—ëŸ¬-ì²˜ë¦¬-error-handling)
   - [4. í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„±](#4-í…ŒìŠ¤íŠ¸-ê°€ëŠ¥ì„±-testability)
   - [5. ì½”ë“œ ì¼ê´€ì„±](#5-ì½”ë“œ-ì¼ê´€ì„±-code-consistency)
   - [6. í•¨ìˆ˜í˜• ìŠ¤íƒ€ì¼](#6-í•¨ìˆ˜í˜•-ìŠ¤íƒ€ì¼-functional-style)
   - [7. ê´€ì°°ì„±](#7-ê´€ì°°ì„±-observability)
6. [ì ìˆ˜ í™˜ì‚°í‘œ](#ì ìˆ˜-í™˜ì‚°í‘œ)
7. [ì ìš© ì˜ˆì‹œ](#ì ìš©-ì˜ˆì‹œ)
8. [ê¸°ëŒ€ íš¨ê³¼](#ê¸°ëŒ€-íš¨ê³¼)

---

## ê°œìš” (ë°°ê²½ ë° í•„ìš”ì„±)

### ì™œ ì•„í‚¤í…ì²˜ í‰ê°€ ê¸°ì¤€ì´ í•„ìš”í•œê°€?

#### ë¬¸ì œ ì¸ì‹

ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œì—ì„œ "ì¢‹ì€ ì½”ë“œ"ì™€ "ë‚˜ìœ ì½”ë“œ"ë¥¼ êµ¬ë¶„í•˜ëŠ” ê²ƒì€ ì‰½ì§€ ì•ŠìŠµë‹ˆë‹¤. íŠ¹íˆ:

1. **ì£¼ê´€ì  íŒë‹¨ì˜ í•œê³„**
   - "ì´ ì½”ë“œê°€ ì¢‹ì€ê°€?"ì— ëŒ€í•œ ë‹µë³€ì´ ê°œë°œìë§ˆë‹¤ ë‹¤ë¦„
   - ì½”ë“œ ë¦¬ë·° ì‹œ "ì œ ìƒê°ì—ëŠ”..." ì‹ì˜ ì£¼ê´€ì  ì˜ê²¬ ì¶©ëŒ
   - ê°œì„ ì´ í•„ìš”í•œ ë¶€ë¶„ì„ ëª…í™•íˆ ì‹ë³„í•˜ê¸° ì–´ë ¤ì›€

2. **ê°œì„  íš¨ê³¼ì˜ ë¶ˆëª…í™•ì„±**
   - ë¦¬íŒ©í† ë§ ì „í›„ë¥¼ ì •ëŸ‰ì ìœ¼ë¡œ ë¹„êµí•  ê¸°ì¤€ ë¶€ì¬
   - "ì´ì „ë³´ë‹¤ ë‚˜ì•„ì¡ŒëŠ”ê°€?"ë¥¼ ê°ê´€ì ìœ¼ë¡œ ì…ì¦í•˜ê¸° ì–´ë ¤ì›€
   - íˆ¬ì ëŒ€ë¹„ íš¨ê³¼(ROI)ë¥¼ ì¸¡ì •í•  ìˆ˜ ì—†ìŒ

3. **íŒ€ í˜‘ì—…ì˜ ì–´ë ¤ì›€**
   - íŒ€ì›ë§ˆë‹¤ ë‹¤ë¥¸ ì½”ë”© ìŠ¤íƒ€ì¼ê³¼ íŒ¨í„´ ì‚¬ìš©
   - ì‹ ê·œ íŒ€ì›ì˜ ì˜¨ë³´ë”© ì‹œ "ì–´ë–»ê²Œ ì½”ë“œë¥¼ ì‘ì„±í•´ì•¼ í•˜ëŠ”ê°€?" ê¸°ì¤€ ë¶€ì¬
   - ì•„í‚¤í…ì²˜ ê²°ì •(Architecture Decision)ì˜ ê·¼ê±°ê°€ ë¶ˆëª…í™•

---

### í‰ê°€ ê¸°ì¤€ì˜ í•„ìš”ì„±

#### 1. ê°ê´€ì  í’ˆì§ˆ ì¸¡ì •

**Before (ê¸°ì¤€ ì—†ìŒ):**
```
ê°œë°œì A: "ì´ ì½”ë“œëŠ” ë³µì¡í•´ ë³´ì…ë‹ˆë‹¤."
ê°œë°œì B: "ê´œì°®ì€ ê²ƒ ê°™ì€ë°ìš”?"
â†’ ì£¼ê´€ì  ì˜ê²¬ ì¶©ëŒ, í•©ì˜ ì–´ë ¤ì›€
```

**After (ê¸°ì¤€ ìˆìŒ):**
```
í‰ê°€ì: "ë ˆì´ì–´ ë¶„ë¦¬ ì ìˆ˜: 75ì  (â­â­â­â­)"
        "ë„ë©”ì¸ ë¡œì§ì´ Application Layerì— ëˆ„ìˆ˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤."
        "FtpFileDomainObjectsCreationServiceë¥¼ Domain Serviceë¡œ ì´ë™í•˜ë©´ 100ì  ë‹¬ì„± ê°€ëŠ¥í•©ë‹ˆë‹¤."
â†’ ê°ê´€ì  ì¸¡ì •, ëª…í™•í•œ ê°œì„  ë°©í–¥
```

#### 2. ì§€ì†ì  ê°œì„  (Continuous Improvement)

**ì¸¡ì •í•  ìˆ˜ ì—†ìœ¼ë©´ ê°œì„ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.**

- **Before/After ì •ëŸ‰ ë¹„êµ:**
  - ê°œì„  ì „: 79.5ì  (â­â­â­â­ ì¢‹ìŒ)
  - ê°œì„  í›„: 99.5ì  (â­â­â­â­â­ íƒì›”)
  - ê°œì„  í­: +20ì  (25% í–¥ìƒ)

- **ê°œì„  ìš°ì„ ìˆœìœ„ ê²°ì •:**
  - ë ˆì´ì–´ ë¶„ë¦¬: 75ì  â†’ ìš°ì„  ê°œì„  í•„ìš”
  - í•¨ìˆ˜í˜• ìŠ¤íƒ€ì¼: 95ì  â†’ í˜„ì¬ ìƒíƒœ ìœ ì§€

#### 3. íŒ€ í‘œì¤€ í™•ë¦½

**ì¼ê´€ëœ ì½”ë“œ í’ˆì§ˆ ê¸°ì¤€:**
- ëª¨ë“  íŒ€ì›ì´ ë™ì¼í•œ ê¸°ì¤€ìœ¼ë¡œ ì½”ë“œ ì‘ì„±
- ì½”ë“œ ë¦¬ë·° ì‹œ ê°ê´€ì  ê·¼ê±°ë¡œ í”¼ë“œë°±
- ì‹ ê·œ íŒ€ì› ì˜¨ë³´ë”© ì‹œ ëª…í™•í•œ ê°€ì´ë“œë¼ì¸ ì œê³µ

**ì•„í‚¤í…ì²˜ ê²°ì • ê¸°ë¡ (ADR):**
- "ì™œ ì´ë ‡ê²Œ ì„¤ê³„í–ˆëŠ”ê°€?"ì— ëŒ€í•œ ê°ê´€ì  ê·¼ê±°
- ì„¤ê³„ íŠ¸ë ˆì´ë“œì˜¤í”„ë¥¼ ì ìˆ˜ë¡œ ëª…í™•íˆ í‘œí˜„
- ë¯¸ë˜ì˜ íŒ€ì›ì´ ê³¼ê±° ê²°ì •ì„ ì´í•´ ê°€ëŠ¥

#### 4. ê¸°ìˆ  ë¶€ì±„ ê´€ë¦¬

**ê¸°ìˆ  ë¶€ì±„ ê°€ì‹œí™”:**
- í˜„ì¬ ì•„í‚¤í…ì²˜ ì ìˆ˜: 79.5ì 
- ëª©í‘œ ì•„í‚¤í…ì²˜ ì ìˆ˜: 100ì 
- ê¸°ìˆ  ë¶€ì±„: 20.5ì  (20.5% ê°œì„  ì—¬ì§€)

**ë¶€ì±„ ìƒí™˜ ê³„íš:**
- 1ë‹¨ê³„: ë ˆì´ì–´ ë¶„ë¦¬ ê°œì„  (75 â†’ 100)
- 2ë‹¨ê³„: ì—ëŸ¬ ì²˜ë¦¬ ê°œì„  (75 â†’ 100)
- 3ë‹¨ê³„: ì½”ë“œ ì¼ê´€ì„± ê°œì„  (75 â†’ 100)

---

### ë³¸ ë¬¸ì„œì˜ ëª©ì 

ì´ ë¬¸ì„œëŠ” ë‹¤ìŒì„ ëª©í‘œë¡œ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤:

#### 1. ê°ê´€ì  í‰ê°€ ê¸°ì¤€ ì œì‹œ
- 7ê°œ í‰ê°€ í•­ëª©ë³„ ìƒì„¸ ê¸°ì¤€ (â­~â­â­â­â­â­)
- ì¸¡ì • ê°€ëŠ¥í•œ êµ¬ì²´ì  ì§€í‘œ
- ì½”ë“œ ì˜ˆì‹œë¥¼ í†µí•œ ëª…í™•í•œ ì´í•´

#### 2. ê°œì„  ë¡œë“œë§µ ì œê³µ
- í˜„ì¬ ìƒíƒœ í‰ê°€ â†’ ëª©í‘œ ì„¤ì • â†’ ê°œì„  ì‹¤í–‰ â†’ ì¬í‰ê°€
- ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ì ì§„ì  ê°œì„ 
- Before/After ì •ëŸ‰ì  ë¹„êµ

#### 3. íŒ€ í‘œì¤€ ë¬¸ì„œí™”
- Clean Architecture + Functional Programming ëª¨ë²” ì‚¬ë¡€
- íŒ€ ì „ì²´ê°€ ê³µìœ í•˜ëŠ” ì½”ë“œ í’ˆì§ˆ ê¸°ì¤€
- ì§€ì† ê°€ëŠ¥í•œ ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œ ë¬¸í™” êµ¬ì¶•

---

### ì ìš© ëŒ€ìƒ

ì´ í‰ê°€ ê¸°ì¤€ì€ ë‹¤ìŒ í”„ë¡œì íŠ¸ì— ì ìš©ë©ë‹ˆë‹¤:

- **ì•„í‚¤í…ì²˜:** Clean Architecture (Hexagonal Architecture)
- **íŒ¨ëŸ¬ë‹¤ì„:** Functional Programming (LanguageExt)
- **ì–¸ì–´:** C# (.NET 8+)
- **ë„ë©”ì¸:** DDD (Domain-Driven Design)

ë‹¨, ì›ì¹™ì€ ë‹¤ë¥¸ ì–¸ì–´/í”„ë ˆì„ì›Œí¬ì—ë„ ì ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.

---

### ì„±ê³µ ì§€í‘œ

ì´ í‰ê°€ ê¸°ì¤€ì˜ ì„±ê³µì€ ë‹¤ìŒìœ¼ë¡œ ì¸¡ì •ë©ë‹ˆë‹¤:

1. **ì •ëŸ‰ì  ì§€í‘œ:**
   - ì „ì²´ ì•„í‚¤í…ì²˜ ì ìˆ˜ í–¥ìƒ (79.5 â†’ 99.5)
   - ëª¨ë“  í•­ëª©ì—ì„œ â­â­â­â­â­ (81-100ì ) ë‹¬ì„±

2. **ì •ì„±ì  ì§€í‘œ:**
   - ì½”ë“œ ë¦¬ë·° ì‹œ ê°ê´€ì  ê·¼ê±° ê¸°ë°˜ í”¼ë“œë°± ì¦ê°€
   - íŒ€ì› ê°„ ì½”ë“œ í’ˆì§ˆ ë…¼ì˜ ì‹œ í•©ì˜ ì‹œê°„ ë‹¨ì¶•
   - ì‹ ê·œ íŒ€ì› ì˜¨ë³´ë”© ê¸°ê°„ ë‹¨ì¶•

3. **ì¥ê¸°ì  íš¨ê³¼:**
   - ê¸°ìˆ  ë¶€ì±„ ê°ì†Œ
   - ë²„ê·¸ ë°œìƒë¥  ê°ì†Œ
   - ê¸°ëŠ¥ ê°œë°œ ì†ë„ í–¥ìƒ (ì•ˆì •ì ì¸ ì•„í‚¤í…ì²˜ ê¸°ë°˜)

---

## í‰ê°€ í•­ëª© ì„ ì • ê¸°ì¤€

### ì„ ì • ì›ì¹™

í‰ê°€ í•­ëª©ì€ ë‹¤ìŒ 4ê°€ì§€ ì›ì¹™ì— ë”°ë¼ ì„ ì •ë˜ì—ˆìŠµë‹ˆë‹¤:

#### ì›ì¹™ 1: Clean Architecture + Functional Programming í•µì‹¬ ìš”ì†Œ
- í”„ë¡œì íŠ¸ì˜ ì•„í‚¤í…ì²˜ ì² í•™ì„ ë°˜ì˜
- Clean Architectureì˜ í•µì‹¬ ì›ì¹™ í¬í•¨
- í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ ì£¼ìš” íŠ¹ì„± í¬í•¨

#### ì›ì¹™ 2: ì¸¡ì • ê°€ëŠ¥ì„± (Measurability)
- ê°ê´€ì ìœ¼ë¡œ í‰ê°€ ê°€ëŠ¥í•œ í•­ëª©
- ì½”ë“œì—ì„œ êµ¬ì²´ì ìœ¼ë¡œ í™•ì¸ ê°€ëŠ¥
- Before/After ë¹„êµê°€ ëª…í™•

#### ì›ì¹™ 3: ì˜í–¥ë„ (Impact)
- ì½”ë“œ í’ˆì§ˆì— ì§ì ‘ì ì¸ ì˜í–¥
- ìœ ì§€ë³´ìˆ˜ì„±, í™•ì¥ì„±, í…ŒìŠ¤íŠ¸ ìš©ì´ì„±ì— ê¸°ì—¬
- íŒ€ ìƒì‚°ì„±ì— ì‹¤ì§ˆì  ì˜í–¥

#### ì›ì¹™ 4: ì‹¤ìš©ì„± (Practicality)
- ì‹¤ì œ í”„ë¡œì íŠ¸ì— ì ìš© ê°€ëŠ¥
- ê°œì„  ê°€ëŠ¥í•œ í•­ëª©
- íˆ¬ì ëŒ€ë¹„ íš¨ê³¼ê°€ ëª…í™•

---

### 7ê°œ í•­ëª© ì„ ì • ê·¼ê±°

#### 1. ë ˆì´ì–´ ë¶„ë¦¬ (20%)

**ì„ ì • ì´ìœ :**
- Clean Architectureì˜ **ê°€ì¥ í•µì‹¬ì ì¸ ì›ì¹™**
- Dependency Rule (ì˜ì¡´ì„± ê·œì¹™) ì¤€ìˆ˜ ì—¬ë¶€
- ë ˆì´ì–´ ê²½ê³„ê°€ ëª…í™•í•´ì•¼ ë³€ê²½ì— ê°•í•œ ì‹œìŠ¤í…œ êµ¬ì¶• ê°€ëŠ¥

**ì¸¡ì • ë°©ë²•:**
- Domain Layerì— Infrastructure ì˜ì¡´ì„± ìœ ë¬´
- Application Layerì— ë„ë©”ì¸ ë¡œì§ ëˆ„ìˆ˜ ì—¬ë¶€
- Port/Adapter íŒ¨í„´ ì ìš© ì—¬ë¶€

**ì˜í–¥ë„:**
- âš ï¸ **ë ˆì´ì–´ ë¶„ë¦¬ ì‹¤íŒ¨ ì‹œ:** ëª¨ë“  ë ˆì´ì–´ê°€ ê°•í•˜ê²Œ ê²°í•©ë˜ì–´ ë³€ê²½ ë¶ˆê°€ëŠ¥
- âœ… **ë ˆì´ì–´ ë¶„ë¦¬ ì„±ê³µ ì‹œ:** ë…ë¦½ì ì¸ ë ˆì´ì–´ë¡œ ë³€ê²½ ì˜í–¥ ìµœì†Œí™”

**ê°€ì¤‘ì¹˜ 20% ì´ìœ :**
- ì•„í‚¤í…ì²˜ì˜ **ê¸°ì´ˆ**ì´ì **í† ëŒ€**
- ë‹¤ë¥¸ ëª¨ë“  í•­ëª©ì˜ ì „ì œ ì¡°ê±´
- ì‹¤íŒ¨ ì‹œ ì „ì²´ ì‹œìŠ¤í…œ ì¬ì„¤ê³„ í•„ìš”

---

#### 2. ë„ë©”ì¸ ëª¨ë¸ë§ (20%)

**ì„ ì • ì´ìœ :**
- DDD(Domain-Driven Design)ì˜ í•µì‹¬
- **ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì˜ ìº¡ìŠí™”** ìˆ˜ì¤€
- Rich Domain Model vs Anemic Domain Model

**ì¸¡ì • ë°©ë²•:**
- Value Object ì‚¬ìš© ì—¬ë¶€ ë° ì¼ê´€ì„±
- Entityì— ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì¡´ì¬ ì—¬ë¶€
- ê²€ì¦ ë¡œì§ì˜ ìœ„ì¹˜ (Domain vs Application)
- Aggregate ê²½ê³„ ëª…í™•ì„±

**ì˜í–¥ë„:**
- âš ï¸ **ë¹ˆì•½í•œ ë„ë©”ì¸ ëª¨ë¸:** ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì´ Serviceì— í©ì–´ì ¸ ìœ ì§€ë³´ìˆ˜ ì–´ë ¤ì›€
- âœ… **í’ë¶€í•œ ë„ë©”ì¸ ëª¨ë¸:** ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ì´ ë„ë©”ì¸ì— ìº¡ìŠí™”ë˜ì–´ ë³€ê²½ ìš©ì´

**ê°€ì¤‘ì¹˜ 20% ì´ìœ :**
- **ë¹„ì¦ˆë‹ˆìŠ¤ ê°€ì¹˜**ë¥¼ ì½”ë“œë¡œ í‘œí˜„í•˜ëŠ” í•µì‹¬ ì˜ì—­
- ë„ë©”ì¸ ëª¨ë¸ì˜ í’ˆì§ˆ = ì‹œìŠ¤í…œì˜ í’ˆì§ˆ
- ë ˆì´ì–´ ë¶„ë¦¬ì™€ í•¨ê»˜ ê°€ì¥ ì¤‘ìš”í•œ ìš”ì†Œ

---

#### 3. ì—ëŸ¬ ì²˜ë¦¬ (15%)

**ì„ ì • ì´ìœ :**
- Functional Programmingì˜ í•µì‹¬ íŒ¨ëŸ¬ë‹¤ì„
- Railway-Oriented Programming ì ìš© ì—¬ë¶€
- **ì—ëŸ¬ë¥¼ íƒ€ì…ìœ¼ë¡œ í‘œí˜„**í•˜ëŠ” ìˆ˜ì¤€

**ì¸¡ì • ë°©ë²•:**
- Exception ì‚¬ìš© ë¹ˆë„
- Fin/Result/Option íŒ¨í„´ ì¼ê´€ì„±
- ì—ëŸ¬ ì •ë³´ ë³´ì¡´ ì—¬ë¶€
- ì—ëŸ¬ íƒ€ì…ì˜ êµ¬ì¡°í™” ìˆ˜ì¤€

**ì˜í–¥ë„:**
- âš ï¸ **ì˜ˆì™¸ ê¸°ë°˜ ì—ëŸ¬ ì²˜ë¦¬:** ì œì–´ íë¦„ ë¶ˆëª…í™•, ì—ëŸ¬ ë³µêµ¬ ì–´ë ¤ì›€
- âœ… **íƒ€ì… ê¸°ë°˜ ì—ëŸ¬ ì²˜ë¦¬:** ì—ëŸ¬ê°€ íƒ€ì…ìœ¼ë¡œ ëª…ì‹œë˜ì–´ ì•ˆì „í•œ ì²˜ë¦¬ ê°€ëŠ¥

**ê°€ì¤‘ì¹˜ 15% ì´ìœ :**
- ì‹œìŠ¤í…œì˜ **ì•ˆì •ì„±**ê³¼ ì§ê²°
- í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ í•µì‹¬ ê°€ì¹˜
- ìš´ì˜ í™˜ê²½ì—ì„œì˜ **ê´€ì°°ì„±** ë° **ë³µêµ¬ ê°€ëŠ¥ì„±**

---

#### 4. í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„± (15%)

**ì„ ì • ì´ìœ :**
- ì½”ë“œ í’ˆì§ˆì˜ **ê°ê´€ì  ì§€í‘œ**
- Pure Function í™œìš© ìˆ˜ì¤€
- ì˜ì¡´ì„± ì£¼ì… ë° Mock í•„ìš”ì„±

**ì¸¡ì • ë°©ë²•:**
- ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„± ë‚œì´ë„
- Mock í•„ìš” ê°œìˆ˜
- Pure Function ë¹„ìœ¨
- Static class í™œìš© (Pure Function)

**ì˜í–¥ë„:**
- âš ï¸ **í…ŒìŠ¤íŠ¸ ë¶ˆê°€ëŠ¥:** íšŒê·€ ë²„ê·¸ ë°œìƒ, ë¦¬íŒ©í† ë§ ë‘ë ¤ì›€
- âœ… **í…ŒìŠ¤íŠ¸ ìš©ì´:** ì•ˆì „í•œ ë¦¬íŒ©í† ë§, ë¹ ë¥¸ í”¼ë“œë°± ë£¨í”„

**ê°€ì¤‘ì¹˜ 15% ì´ìœ :**
- **ì§€ì† ê°€ëŠ¥í•œ ê°œë°œ**ì˜ í•µì‹¬
- ë¦¬íŒ©í† ë§ ì•ˆì „ì„± ë³´ì¥
- íŒ€ ìƒì‚°ì„±ê³¼ ì§ê²°

---

#### 5. ì½”ë“œ ì¼ê´€ì„± (10%)

**ì„ ì • ì´ìœ :**
- íŒ€ í˜‘ì—…ì˜ **í•„ìˆ˜ ìš”ì†Œ**
- íŒ¨í„´ í†µì¼ë¡œ ì¸í•œ **ê°€ë…ì„±** í–¥ìƒ
- ì˜¨ë³´ë”© ì‹œê°„ ë‹¨ì¶•

**ì¸¡ì • ë°©ë²•:**
- ë™ì¼ ê¸°ëŠ¥ì˜ êµ¬í˜„ ë°©ì‹ ì¼ê´€ì„±
- Validation â†’ FinT ë³€í™˜ íŒ¨í„´ í†µì¼
- ëª…ëª… ê·œì¹™ ì¤€ìˆ˜ ì—¬ë¶€
- ì£¼ì„ ì²˜ë¦¬ëœ ì½”ë“œ ì¡´ì¬ ì—¬ë¶€

**ì˜í–¥ë„:**
- âš ï¸ **íŒ¨í„´ ë¶ˆì¼ì¹˜:** ì½”ë“œ ì´í•´ ì‹œê°„ ì¦ê°€, ì‹¤ìˆ˜ ê°€ëŠ¥ì„± ì¦ê°€
- âœ… **íŒ¨í„´ ì¼ê´€ì„±:** ì˜ˆì¸¡ ê°€ëŠ¥í•œ ì½”ë“œ, íŒ€ ìƒì‚°ì„± í–¥ìƒ

**ê°€ì¤‘ì¹˜ 10% ì´ìœ :**
- ì§ì ‘ì ì¸ ê¸°ëŠ¥ ì˜í–¥ì€ ì ì§€ë§Œ **ì¥ê¸°ì ìœ¼ë¡œ ì¤‘ìš”**
- íŒ€ ê·œëª¨ê°€ í´ìˆ˜ë¡ ì¤‘ìš”ì„± ì¦ê°€
- ìœ ì§€ë³´ìˆ˜ ë¹„ìš© ì ˆê°

---

#### 6. í•¨ìˆ˜í˜• ìŠ¤íƒ€ì¼ (10%)

**ì„ ì • ì´ìœ :**
- í”„ë¡œì íŠ¸ì˜ **ì•„í‚¤í…ì²˜ ì² í•™** (Functional Programming)
- ë¶ˆë³€ì„±, Pure Function, Monad í™œìš© ìˆ˜ì¤€
- Side Effect ê´€ë¦¬ ìˆ˜ì¤€

**ì¸¡ì • ë°©ë²•:**
- LanguageExt í™œìš©ë„
- Monad Transformer (FinT, IO) ì‚¬ìš©
- ë¶ˆë³€ì„± ë³´ì¥ ì—¬ë¶€
- Pure Function ë¹„ìœ¨

**ì˜í–¥ë„:**
- âš ï¸ **ëª…ë ¹í˜• ìŠ¤íƒ€ì¼:** ìƒíƒœ ë³€ê²½ ì¶”ì  ì–´ë ¤ì›€, ë™ì‹œì„± ë¬¸ì œ
- âœ… **í•¨ìˆ˜í˜• ìŠ¤íƒ€ì¼:** ì˜ˆì¸¡ ê°€ëŠ¥í•œ ë™ì‘, ì•ˆì „í•œ ë³‘ë ¬ ì²˜ë¦¬

**ê°€ì¤‘ì¹˜ 10% ì´ìœ :**
- ì´ë¯¸ í”„ë¡œì íŠ¸ì—ì„œ **ì˜ ì ìš©**ë˜ê³  ìˆìŒ (95ì )
- ì¶”ê°€ ê°œì„  ì—¬ì§€ê°€ ìƒëŒ€ì ìœ¼ë¡œ ì ìŒ
- ë‹¤ë¥¸ í•­ëª© ê°œì„ ì´ ë” ê¸´ê¸‰

---

#### 7. ê´€ì°°ì„± (10%)

**ì„ ì • ì´ìœ :**
- **ìš´ì˜ í™˜ê²½**ì—ì„œì˜ í•„ìˆ˜ ìš”ì†Œ
- ë¬¸ì œ ì§„ë‹¨ ë° ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
- Distributed Tracing, Logging, Metrics

**ì¸¡ì • ë°©ë²•:**
- Structured Logging ì ìš© ì—¬ë¶€
- OpenTelemetry í†µí•©
- ëŒ€ëŸ‰ ë°ì´í„° ë¡œê¹… ìµœì í™”
- Metrics ìˆ˜ì§‘ ì—¬ë¶€

**ì˜í–¥ë„:**
- âš ï¸ **ê´€ì°°ì„± ë¶€ì¡±:** ë¬¸ì œ ì›ì¸ íŒŒì•… ë¶ˆê°€, ì¥ì•  ëŒ€ì‘ ì–´ë ¤ì›€
- âœ… **ê´€ì°°ì„± ìš°ìˆ˜:** ë¹ ë¥¸ ë¬¸ì œ ì§„ë‹¨, ì„±ëŠ¥ ìµœì í™” ê°€ëŠ¥

**ê°€ì¤‘ì¹˜ 10% ì´ìœ :**
- ê°œë°œ ë‹¨ê³„ë³´ë‹¤ **ìš´ì˜ ë‹¨ê³„**ì—ì„œ ì¤‘ìš”
- ê¸°ëŠ¥ ê°œë°œì—ëŠ” ì§ì ‘ ì˜í–¥ ì—†ìŒ
- í•˜ì§€ë§Œ ìš´ì˜ ì•ˆì •ì„±ì—ëŠ” í•„ìˆ˜

---

### ê°€ì¤‘ì¹˜ ì„¤ì • ë…¼ë¦¬

#### Tier 1: í•µì‹¬ ì•„í‚¤í…ì²˜ (40%)
```
ë ˆì´ì–´ ë¶„ë¦¬ (20%) + ë„ë©”ì¸ ëª¨ë¸ë§ (20%) = 40%
```
- Clean Architecture + DDDì˜ **í•µì‹¬**
- ì‹œìŠ¤í…œ ì„¤ê³„ì˜ **í† ëŒ€**
- ì‹¤íŒ¨ ì‹œ ì „ì²´ ì¬ì„¤ê³„ í•„ìš”

#### Tier 2: í’ˆì§ˆ ë° ì•ˆì •ì„± (30%)
```
ì—ëŸ¬ ì²˜ë¦¬ (15%) + í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„± (15%) = 30%
```
- ì‹œìŠ¤í…œì˜ **ì•ˆì •ì„±** ë° **ìœ ì§€ë³´ìˆ˜ì„±**
- ì§€ì† ê°€ëŠ¥í•œ ê°œë°œì˜ í•µì‹¬
- ì¥ê¸°ì  ìƒì‚°ì„±ì— ì§ì ‘ ì˜í–¥

#### Tier 3: íŒ€ í˜‘ì—… ë° ìš´ì˜ (30%)
```
ì½”ë“œ ì¼ê´€ì„± (10%) + í•¨ìˆ˜í˜• ìŠ¤íƒ€ì¼ (10%) + ê´€ì°°ì„± (10%) = 30%
```
- íŒ€ **í˜‘ì—…** ë° **ìš´ì˜ íš¨ìœ¨ì„±**
- ì§ì ‘ì  ê¸°ëŠ¥ ì˜í–¥ì€ ì ì§€ë§Œ ì¤‘ìš”
- ì¥ê¸°ì ìœ¼ë¡œ íŒ€ ìƒì‚°ì„±ì— ê¸°ì—¬

---

### ì„ ì •í•˜ì§€ ì•Šì€ í•­ëª©ë“¤

ë‹¤ìŒ í•­ëª©ë“¤ì€ ê³ ë ¤í–ˆìœ¼ë‚˜ ì œì™¸ë˜ì—ˆìŠµë‹ˆë‹¤:

#### ì œì™¸ í•­ëª© 1: ì„±ëŠ¥ (Performance)
**ì œì™¸ ì´ìœ :**
- ê¸°ëŠ¥ì  ì •í™•ì„±ì´ ìš°ì„ 
- ì¸¡ì •ì´ í™˜ê²½ì— ì˜ì¡´ì 
- í”„ë¡œíŒŒì¼ë§ ë„êµ¬ë¡œ ë³„ë„ ì¸¡ì • í•„ìš”

#### ì œì™¸ í•­ëª© 2: ë³´ì•ˆ (Security)
**ì œì™¸ ì´ìœ :**
- ì „ë¬¸ì ì¸ ë³´ì•ˆ ê°ì‚¬ í•„ìš”
- ì•„í‚¤í…ì²˜ í‰ê°€ì™€ëŠ” ë³„ê°œ ì˜ì—­
- OWASP ë“± ë³„ë„ ê¸°ì¤€ ì¡´ì¬

#### ì œì™¸ í•­ëª© 3: ë¬¸ì„œí™” (Documentation)
**ì œì™¸ ì´ìœ :**
- ì½”ë“œ ìì²´ê°€ ë¬¸ì„œ (Self-Documenting Code)
- ë³„ë„ ë¬¸ì„œë³´ë‹¤ ì½”ë“œ í’ˆì§ˆì´ ìš°ì„ 
- XML ì£¼ì„ ë“±ì€ ë¶€ê°€ì 

#### ì œì™¸ í•­ëª© 4: UI/UX
**ì œì™¸ ì´ìœ :**
- Backend ì•„í‚¤í…ì²˜ í‰ê°€ì— í•´ë‹¹ ì—†ìŒ
- ë³„ë„ UI/UX í‰ê°€ ê¸°ì¤€ í•„ìš”

---

## ê³µì‹ í‘œì¤€ê³¼ì˜ ë¹„êµ

ë³¸ í‰ê°€ ê¸°ì¤€ì€ ì‚°ì—… í‘œì¤€ ë° í•™ê³„ì˜ ê³µì‹ í‰ê°€ í”„ë ˆì„ì›Œí¬ë¥¼ ë¶„ì„í•˜ê³ , í”„ë¡œì íŠ¸ íŠ¹ì„±ì— ë§ê²Œ í†µí•©Â·ê°œì„ í•œ ê²°ê³¼ì…ë‹ˆë‹¤.

### ë¹„êµ ëŒ€ìƒ í‘œì¤€

1. **ISO/IEC 25010** - ì†Œí”„íŠ¸ì›¨ì–´ í’ˆì§ˆ í‰ê°€ êµ­ì œ í‘œì¤€
2. **Clean Architecture Metrics** - Robert C. Martinì˜ ì •ëŸ‰ì  ë©”íŠ¸ë¦­
3. **ATAM (Architecture Tradeoff Analysis Method)** - CMU SEIì˜ ì•„í‚¤í…ì²˜ í‰ê°€ ë°©ë²•ë¡ 
4. **Functional Programming Quality** - í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° í’ˆì§ˆ í‰ê°€ ê¸°ì¤€
5. **Domain-Driven Design Assessment** - DDD êµ¬í˜„ í‰ê°€ ê¸°ì¤€

---

### 1. ISO/IEC 25010 êµ­ì œ í‘œì¤€ê³¼ì˜ ë¹„êµ

#### ISO 25010 ê°œìš”

[ISO/IEC 25010](https://www.iso.org/standard/78176.html)ì€ ì†Œí”„íŠ¸ì›¨ì–´ í’ˆì§ˆ í‰ê°€ì˜ **êµ­ì œ í‘œì¤€**ìœ¼ë¡œ, 2011ë…„ ë°œí‘œ í›„ 2023ë…„ ìµœì‹  ê°œì •ë˜ì—ˆìŠµë‹ˆë‹¤.

#### ISO 25010ì˜ 8ê°€ì§€ ì œí’ˆ í’ˆì§ˆ íŠ¹ì„±

1. **Functional Suitability** (ê¸°ëŠ¥ ì í•©ì„±)
2. **Performance Efficiency** (ì„±ëŠ¥ íš¨ìœ¨ì„±)
3. **Compatibility** (í˜¸í™˜ì„±)
4. **Usability** (ì‚¬ìš©ì„±)
5. **Reliability** (ì‹ ë¢°ì„±)
6. **Security** (ë³´ì•ˆ)
7. **Maintainability** (ìœ ì§€ë³´ìˆ˜ì„±)
8. **Portability** (ì´ì‹ì„±)

#### ë§¤í•‘ ë¶„ì„

| ISO 25010 íŠ¹ì„± | ë³¸ í‰ê°€ ê¸°ì¤€ | ë§¤í•‘ ê´€ê³„ | ì»¤ë²„ë¦¬ì§€ |
|---------------|-------------|----------|---------|
| Maintainability | ë ˆì´ì–´ ë¶„ë¦¬ (20%) | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Functional Suitability | ë„ë©”ì¸ ëª¨ë¸ë§ (20%) | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Reliability | ì—ëŸ¬ ì²˜ë¦¬ (15%) | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Maintainability | í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„± (15%) | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Maintainability | ì½”ë“œ ì¼ê´€ì„± (10%) | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Maintainability | í•¨ìˆ˜í˜• ìŠ¤íƒ€ì¼ (10%) | ê°„ì ‘ ëŒ€ì‘ | âœ… 95% |
| Reliability | ê´€ì°°ì„± (10%) | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Performance | - | ì˜ë„ì  ì œì™¸ | âš ï¸ 0% |
| Security | - | ì˜ë„ì  ì œì™¸ | âš ï¸ 0% |
| Compatibility | - | ì˜ë„ì  ì œì™¸ | âš ï¸ 0% |
| Usability | - | Backend í•´ë‹¹ ì—†ìŒ | - |
| Portability | - | ì˜ë„ì  ì œì™¸ | âš ï¸ 0% |

**ì¢…í•© í‰ê°€:**
- ISO 25010ì˜ **Maintainabilityì™€ Reliability**ì— ì§‘ì¤‘
- Clean Architecture + FPì˜ í•µì‹¬ ëª©í‘œì™€ **ì™„ë²½íˆ ì¼ì¹˜** âœ…
- ì˜ë„ì  ì œì™¸ í•­ëª©(Performance, Security)ì€ ë³„ë„ í‰ê°€ í•„ìš”

---

### 2. Clean Architecture Metrics (Robert C. Martin)

#### Uncle Bobì˜ í•µì‹¬ ë©”íŠ¸ë¦­

Robert C. Martinì€ [Clean Architecture](https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164) ì±…ì—ì„œ ì •ëŸ‰ì  ë©”íŠ¸ë¦­ì„ ì œì‹œí–ˆìŠµë‹ˆë‹¤:

**1. Instability Metric (I)**
```
I = Fan-out / (Fan-in + Fan-out)
```
- I = 0: ìµœëŒ€ ì•ˆì •ì„± (ì˜ì¡´ì„± ë°›ìŒ)
- I = 1: ìµœëŒ€ ë¶ˆì•ˆì •ì„± (ì˜ì¡´ì„± ì¤Œ)

**2. Abstractness Metric (A)**
```
A = Na / Nc
```
- Na: ì¶”ìƒ í´ë˜ìŠ¤/ì¸í„°í˜ì´ìŠ¤ ìˆ˜
- Nc: ì „ì²´ í´ë˜ìŠ¤ ìˆ˜

**3. Distance from Main Sequence (D)**
```
D = | A + I - 1 |
```
- D = 0: Main Sequenceì— ìœ„ì¹˜ (ì´ìƒì )
- D > 0.5: ê°œì„  í•„ìš”

#### ë§¤í•‘ ë¶„ì„

| Clean Architecture ë©”íŠ¸ë¦­ | ë³¸ í‰ê°€ ê¸°ì¤€ | ë§¤í•‘ ê´€ê³„ | ì»¤ë²„ë¦¬ì§€ |
|--------------------------|-------------|----------|---------|
| Instability (ì˜ì¡´ì„± ë°©í–¥) | ë ˆì´ì–´ ë¶„ë¦¬ (20%) | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Abstractness (ì¶”ìƒí™”) | ë„ë©”ì¸ ëª¨ë¸ë§ (20%) | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Testability | í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„± (15%) | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| - | ì—ëŸ¬ ì²˜ë¦¬ (15%) | ì¶”ê°€ ê°€ì¹˜ | â• FP íŠ¹í™” |
| - | ì½”ë“œ ì¼ê´€ì„± (10%) | ì¶”ê°€ ê°€ì¹˜ | â• íŒ€ í˜‘ì—… |
| - | í•¨ìˆ˜í˜• ìŠ¤íƒ€ì¼ (10%) | ì¶”ê°€ ê°€ì¹˜ | â• FP íŒ¨ëŸ¬ë‹¤ì„ |
| - | ê´€ì°°ì„± (10%) | ì¶”ê°€ ê°€ì¹˜ | â• ìš´ì˜ ì¤‘ì‹¬ |

**ì¢…í•© í‰ê°€:**
- Uncle Bobì˜ **í•µì‹¬ ì›ì¹™ ëª¨ë‘ í¬í•¨** âœ…
- FP ë° ìš´ì˜ ê´€ì  ì¶”ê°€ â†’ **ë” í¬ê´„ì ** âœ¨

---

### 3. ATAM (Architecture Tradeoff Analysis Method)

#### SEI CMUì˜ ATAM ë°©ë²•ë¡ 

[ATAM](https://www.sei.cmu.edu/library/architecture-tradeoff-analysis-method-collection/)ì€ Carnegie Mellon Universityì˜ Software Engineering Instituteì—ì„œ ê°œë°œí•œ **ì—…ê³„ ì„ ë„ì  í‰ê°€ ë°©ë²•**ì…ë‹ˆë‹¤.

#### ATAMì˜ í•µì‹¬ í‰ê°€ ìš”ì†Œ

1. **Business Drivers** (ë¹„ì¦ˆë‹ˆìŠ¤ ë™ì¸)
2. **Quality Attributes** (í’ˆì§ˆ ì†ì„±): Performance, Modifiability, Security, Availability, Testability
3. **Architectural Decisions** (ì•„í‚¤í…ì²˜ ê²°ì •)
4. **Scenarios** (ì‹œë‚˜ë¦¬ì˜¤ ê¸°ë°˜ í‰ê°€)
5. **Trade-off Points** (íŠ¸ë ˆì´ë“œì˜¤í”„ ì§€ì )
6. **Risks & Non-risks** (ë¦¬ìŠ¤í¬ ì‹ë³„)

#### ë§¤í•‘ ë¶„ì„

| ATAM ìš”ì†Œ | ë³¸ í‰ê°€ ê¸°ì¤€ | ë§¤í•‘ ê´€ê³„ | ì»¤ë²„ë¦¬ì§€ |
|-----------|-------------|----------|---------|
| Business Drivers | ê°œìš” â†’ ë°°ê²½ ë° í•„ìš”ì„± | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Quality Attributes | 7ê°œ í‰ê°€ í•­ëª© | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Scenarios | ì ìš© ì˜ˆì‹œ (Before/After) | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Trade-off Points | ê°€ì¤‘ì¹˜ (20%, 15%, 10%) | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Risks | ê° ë“±ê¸‰ë³„ "ë¬¸ì œì " | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Stakeholders | íŒ€ í‘œì¤€ ë¬¸ì„œí™” | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Evaluation Process | - | ë¶€ë¶„ì  | âš ï¸ 50% |

**ì¢…í•© í‰ê°€:**
- ATAMì˜ **í•µì‹¬ ìš”ì†Œ ëŒ€ë¶€ë¶„ í¬í•¨** âœ…
- ê³µì‹ í‰ê°€ í”„ë¡œì„¸ìŠ¤(3-4ì¼, ì™¸ë¶€ í‰ê°€íŒ€)ëŠ” ë¯¸í¬í•¨
- **ë‚´ë¶€ í‰ê°€ìš©**ìœ¼ë¡œëŠ” ì™„ë²½íˆ ì í•© âœ…

---

### 4. Functional Programming Quality Assessment

#### í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° í‰ê°€ ê¸°ì¤€

[Functional Design and Architecture](https://www.manning.com/books/functional-design-and-architecture) ë° í•™ê³„ ì—°êµ¬([TFP 2026](https://trendsfp.github.io/))ì—ì„œ ì œì‹œí•˜ëŠ” í‰ê°€ ê¸°ì¤€:

1. **Purity** (ìˆœìˆ˜ì„±) - Pure Function ë¹„ìœ¨
2. **Immutability** (ë¶ˆë³€ì„±) - ë³€ê²½ ê°€ëŠ¥í•œ ìƒíƒœ ìµœì†Œí™”
3. **Type Safety** (íƒ€ì… ì•ˆì „ì„±) - íƒ€ì…ìœ¼ë¡œ ì—ëŸ¬ í‘œí˜„
4. **Composability** (ì¡°í•© ê°€ëŠ¥ì„±) - í•¨ìˆ˜ ì¡°í•©
5. **Testability** (í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„±) - Mock ë¶ˆí•„ìš”
6. **Referential Transparency** (ì°¸ì¡° íˆ¬ëª…ì„±)

#### ë§¤í•‘ ë¶„ì„

| FP í’ˆì§ˆ ê¸°ì¤€ | ë³¸ í‰ê°€ ê¸°ì¤€ | ë§¤í•‘ ê´€ê³„ | ì»¤ë²„ë¦¬ì§€ |
|-------------|-------------|----------|---------|
| Purity | í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„± (15%) | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Immutability | í•¨ìˆ˜í˜• ìŠ¤íƒ€ì¼ (10%) | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Type Safety | ì—ëŸ¬ ì²˜ë¦¬ (15%) | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Composability | í•¨ìˆ˜í˜• ìŠ¤íƒ€ì¼ (10%) | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Testability | í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„± (15%) | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Referential Transparency | í•¨ìˆ˜í˜• ìŠ¤íƒ€ì¼ (10%) | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |

**ì¢…í•© í‰ê°€:**
- í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ **ëª¨ë“  í•µì‹¬ ì›ì¹™ ì™„ë²½ í¬í•¨** âœ…âœ…âœ…

---

### 5. Domain-Driven Design Quality Assessment

#### DDD í‰ê°€ ê¸°ì¤€

[DDD ì²´ê³„ì  ë¬¸í—Œ ì—°êµ¬](https://arxiv.org/html/2310.01905v4)ì—ì„œ ì œì‹œí•˜ëŠ” í‰ê°€ ê¸°ì¤€:

**Strategic Design (ì „ëµì  ì„¤ê³„)**
- Bounded Context ëª…í™•ì„±
- Ubiquitous Language ì¼ê´€ì„±

**Tactical Design (ì „ìˆ ì  ì„¤ê³„)**
- Entity, Value Object í™œìš©
- Aggregate ê²½ê³„ ì„¤ì •
- Repository íŒ¨í„´

**Layered Architecture (ê³„ì¸µí˜• ì•„í‚¤í…ì²˜)**
- Presentation â†’ Application â†’ Domain â†’ Infrastructure

#### ë§¤í•‘ ë¶„ì„

| DDD í‰ê°€ ê¸°ì¤€ | ë³¸ í‰ê°€ ê¸°ì¤€ | ë§¤í•‘ ê´€ê³„ | ì»¤ë²„ë¦¬ì§€ |
|--------------|-------------|----------|---------|
| Bounded Context | ë ˆì´ì–´ ë¶„ë¦¬ (20%) | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Ubiquitous Language | ì½”ë“œ ì¼ê´€ì„± (10%) | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Value Object | ë„ë©”ì¸ ëª¨ë¸ë§ (20%) | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Entity & Aggregate | ë„ë©”ì¸ ëª¨ë¸ë§ (20%) | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Repository Pattern | ë ˆì´ì–´ ë¶„ë¦¬ (20%) | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |
| Layered Architecture | ë ˆì´ì–´ ë¶„ë¦¬ (20%) | ì§ì ‘ ëŒ€ì‘ | âœ… 100% |

**ì¢…í•© í‰ê°€:**
- DDDì˜ **Strategic + Tactical Design ëª¨ë‘ í¬í•¨** âœ…

---

### ì¢…í•© ë¹„êµí‘œ

| ê³µì‹ í‘œì¤€/ë°©ë²•ë¡  | ì»¤ë²„ë¦¬ì§€ | í‰ê°€ | íŠ¹ì§• |
|-----------------|---------|------|------|
| **ISO/IEC 25010** | 95% | â­â­â­â­â­ | Maintainability & Reliability ì§‘ì¤‘ (ì˜ë„ì ) |
| **Clean Architecture** | 100% | â­â­â­â­â­ | í•µì‹¬ ì›ì¹™ + FP/ìš´ì˜ ê´€ì  ì¶”ê°€ |
| **ATAM (SEI CMU)** | 85% | â­â­â­â­ | ë‚´ë¶€ í‰ê°€ìš©ìœ¼ë¡œ ì í•© |
| **Functional Programming** | 100% | â­â­â­â­â­ | FP í•µì‹¬ ì›ì¹™ ì™„ë²½ í¬í•¨ |
| **Domain-Driven Design** | 100% | â­â­â­â­â­ | Strategic + Tactical ëª¨ë‘ í¬í•¨ |

---

### ë³¸ í‰ê°€ ê¸°ì¤€ì˜ ì°¨ë³„í™” ìš”ì†Œ

ê³µì‹ ê¸°ì¤€ ëŒ€ë¹„ ìš°ë¦¬ ë¬¸ì„œë§Œì˜ ê°•ì :

#### 1. êµ¬ì²´ì ì¸ ì½”ë“œ ì˜ˆì‹œ âœ¨
- **ê³µì‹ ê¸°ì¤€**: ì¶”ìƒì  ì›ì¹™ ì œì‹œ
- **ë³¸ ë¬¸ì„œ**: ê° ë“±ê¸‰(â­~â­â­â­â­â­)ë§ˆë‹¤ **ì‹¤ì œ C# ì½”ë“œ** ì œê³µ
- **ì¥ì **: ì¦‰ì‹œ ì ìš© ê°€ëŠ¥, í•™ìŠµ ìë£Œë¡œ í™œìš©

#### 2. ê°€ì¤‘ì¹˜ ê¸°ë°˜ ì •ëŸ‰ í‰ê°€ âœ¨
- **ê³µì‹ ê¸°ì¤€**: ì •ì„±ì  í‰ê°€ ìœ„ì£¼
- **ë³¸ ë¬¸ì„œ**: Tier êµ¬ì¡°(40%, 30%, 30%) + ì ìˆ˜(0-100)
- **ì¥ì **: Before/After ì •ëŸ‰ ë¹„êµ (79.5 â†’ 99.5)

#### 3. ì‹¤ì œ í”„ë¡œì íŠ¸ ì ìš© ì‚¬ë¡€ âœ¨
- **ê³µì‹ ê¸°ì¤€**: ì¼ë°˜ì  ì§€ì¹¨
- **ë³¸ ë¬¸ì„œ**: Watcher/Loader ê°œì„  ì‚¬ë¡€ í¬í•¨
- **ì¥ì **: íš¨ê³¼ ê²€ì¦ ì™„ë£Œ, ì‹ ë¢°ì„± ë†’ìŒ

#### 4. ë‹¨ê¸°/ì¤‘ê¸°/ì¥ê¸° íš¨ê³¼ ì œì‹œ âœ¨
- **ê³µì‹ ê¸°ì¤€**: í‰ê°€ ë°©ë²• ì¤‘ì‹¬
- **ë³¸ ë¬¸ì„œ**: ë¹„ì¦ˆë‹ˆìŠ¤ ì„íŒ©íŠ¸ê¹Œì§€ ì—°ê²°
- **ì¥ì **: ê²½ì˜ì§„ ì„¤ë“ ìë£Œë¡œ í™œìš© ê°€ëŠ¥

#### 5. íŒ€ í˜‘ì—… ì¤‘ì‹¬ ì„¤ê³„ âœ¨
- **ê³µì‹ ê¸°ì¤€**: ê°œì¸ í‰ê°€ ìœ„ì£¼
- **ë³¸ ë¬¸ì„œ**: ì½”ë“œ ì¼ê´€ì„±, ADR, ì˜¨ë³´ë”© í¬í•¨
- **ì¥ì **: íŒ€ ìƒì‚°ì„± ì§ì ‘ í–¥ìƒ

---

### í–¥í›„ ê°œì„  ë°©í–¥

#### 1. ISO 25010 Security ë³´ì™„ (ì„ íƒ)
í˜„ì¬ ì˜ë„ì ìœ¼ë¡œ ì œì™¸í–ˆìœ¼ë‚˜, **OWASP Top 10** ìˆ˜ì¤€ì˜ ê¸°ë³¸ ë³´ì•ˆ ì²´í¬ë¦¬ìŠ¤íŠ¸ë¥¼ ë³„ë„ ë¶€ë¡ìœ¼ë¡œ ì¶”ê°€ ê³ ë ¤

#### 2. ATAM í”„ë¡œì„¸ìŠ¤ ë³´ì™„ (ì„ íƒ)
ì™¸ë¶€ í‰ê°€íŒ€ ì°¸ì—¬ê°€ í•„ìš”í•œ ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ **"í‰ê°€ ì§„í–‰ ê°€ì´ë“œ"** ì„¹ì…˜ ì¶”ê°€ ê³ ë ¤

#### 3. ë©”íŠ¸ë¦­ ìë™í™” (ì¥ê¸°)
Uncle Bobì˜ I, A, D ë©”íŠ¸ë¦­ì„ **ìë™ ê³„ì‚°í•˜ëŠ” ë„êµ¬** ê°œë°œ (Phase 2 ë¡œë“œë§µ)

---

### ê²°ë¡ 

ë³¸ í‰ê°€ ê¸°ì¤€ì€:

âœ… **êµ­ì œ í‘œì¤€(ISO 25010) ìˆ˜ì¤€**ì˜ ì²´ê³„ì„±
âœ… **í•™ê³„ ë°©ë²•ë¡ (ATAM, DDD)** ì™„ë²½ ë°˜ì˜
âœ… **ì‚°ì—… ì‹¤ë¬´(Clean Architecture, FP)** í†µí•©
âœ… **ê³µì‹ ê¸°ì¤€ì„ ë„˜ì–´ì„œëŠ” êµ¬ì²´ì„±** (ì½”ë“œ ì˜ˆì‹œ, ì‚¬ë¡€ ì—°êµ¬)
âœ… **íŒ€ í˜‘ì—… ë° ë¹„ì¦ˆë‹ˆìŠ¤ ê°€ì¹˜** ì¶”ê°€

ê³µì‹ í‘œì¤€ë“¤ì˜ **ì¥ì ë§Œ í†µí•©**í•˜ê³ , **ì‹¤ë¬´ ì ìš©ì„±ì„ ê·¹ëŒ€í™”**í•œ í‰ê°€ ê¸°ì¤€ì…ë‹ˆë‹¤.

---

## í‰ê°€ í•­ëª© ê°œìš”

| í•­ëª© | ê°€ì¤‘ì¹˜ | ì„¤ëª… |
|------|--------|------|
| ë ˆì´ì–´ ë¶„ë¦¬ | 20% | Clean Architectureì˜ ë ˆì´ì–´ ê²½ê³„ ë° ì˜ì¡´ì„± ê·œì¹™ ì¤€ìˆ˜ |
| ë„ë©”ì¸ ëª¨ë¸ë§ | 20% | DDD ì›ì¹™ì— ë”°ë¥¸ Rich Domain Model êµ¬í˜„ |
| ì—ëŸ¬ ì²˜ë¦¬ | 15% | Functional Error Handling ë° Railway-Oriented Programming |
| í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„± | 15% | ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ìš©ì´ì„± ë° Pure Function í™œìš© |
| ì½”ë“œ ì¼ê´€ì„± | 10% | íŒ¨í„´ ì¼ê´€ì„± ë° ì½”ë”© ìŠ¤íƒ€ì¼ í†µì¼ |
| í•¨ìˆ˜í˜• ìŠ¤íƒ€ì¼ | 10% | í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° íŒ¨ëŸ¬ë‹¤ì„ ì ìš©ë„ |
| ê´€ì°°ì„± | 10% | ë¡œê¹…, ì¶”ì , ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì™„ì„±ë„ |

---

## í‰ê°€ ê¸°ì¤€ ìƒì„¸

### 1. ë ˆì´ì–´ ë¶„ë¦¬ (Layer Separation)

Clean Architectureì˜ í•µì‹¬ì¸ ë ˆì´ì–´ ê°„ ëª…í™•í•œ ê²½ê³„ì™€ ì˜ì¡´ì„± ê·œì¹™ ì¤€ìˆ˜ë¥¼ í‰ê°€í•©ë‹ˆë‹¤.

#### â­ (20ì ) - ë§¤ìš° ë¶€ì¡±

**íŠ¹ì§•:**
- ë ˆì´ì–´ êµ¬ë¶„ì´ ì—†ê±°ë‚˜ ëª¨ë“  ë¡œì§ì´ í•œ ê³³ì— ì§‘ì¤‘
- Application Layerì— ë°ì´í„°ë² ì´ìŠ¤ ì ‘ê·¼ ì½”ë“œ ì§ì ‘ ì‘ì„±
- UI ë¡œì§ê³¼ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì´ í˜¼ì¬

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
// Controllerì—ì„œ ì§ì ‘ ë°ì´í„°ë² ì´ìŠ¤ ì ‘ê·¼
public class UserController
{
    public IActionResult GetUser(int id)
    {
        var connection = new SqlConnection("...");
        var user = connection.Query<User>("SELECT * FROM Users WHERE Id = @id", new { id });
        return Ok(user);
    }
}
```

**ë¬¸ì œì :**
- ë ˆì´ì–´ ê²½ê³„ ì—†ìŒ
- í…ŒìŠ¤íŠ¸ ë¶ˆê°€ëŠ¥
- ë³€ê²½ì— ì·¨ì•½

---

#### â­â­ (40ì ) - ë¶€ì¡±

**íŠ¹ì§•:**
- ë ˆì´ì–´ëŠ” êµ¬ë¶„ë˜ì–´ ìˆìœ¼ë‚˜ ê²½ê³„ê°€ ë¶ˆëª…í™•
- Application Layerì—ì„œ Infrastructure ì„¸ë¶€ì‚¬í•­ ì§ì ‘ ì²˜ë¦¬
- Domain Layerê°€ ì™¸ë¶€ ì˜ì¡´ì„±ì„ ì§ì ‘ ì°¸ì¡°

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
// Application Layerì—ì„œ HttpClient ì§ì ‘ ì‚¬ìš©
public class LimitSampleService
{
    private readonly HttpClient _httpClient;

    public async Task<LimitSample> CreateAsync(string lineId)
    {
        var response = await _httpClient.PostAsync("http://api.../limitsample", ...);
        // ...
    }
}
```

**ë¬¸ì œì :**
- Infrastructure ì„¸ë¶€ì‚¬í•­ ë…¸ì¶œ
- Port/Adapter íŒ¨í„´ ë¯¸ì ìš©
- ì˜ì¡´ì„± ì—­ì „ ì›ì¹™ ìœ„ë°˜

---

#### â­â­â­ (60ì ) - ë³´í†µ

**íŠ¹ì§•:**
- ê¸°ë³¸ì ì¸ ë ˆì´ì–´ ë¶„ë¦¬ëŠ” ë˜ì–´ ìˆìŒ
- ì¼ë¶€ ì±…ì„ì´ ì˜ëª»ëœ ë ˆì´ì–´ì— ìœ„ì¹˜
- Port/Adapter íŒ¨í„´ì´ ì¼ë¶€ë§Œ ì ìš©

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
// Application Layerì— ì¼ë¶€ ë„ë©”ì¸ ê²€ì¦ ë¡œì§
public class LoadLimitSampleUsecase
{
    public async Task<Response> HandleAsync(Request request)
    {
        // ê²€ì¦ ë¡œì§ì´ Application Layerì— ì¡´ì¬
        if (string.IsNullOrEmpty(request.LineId))
            return Response.Fail("Invalid LineId");

        var result = await _repository.GetAsync(request.LineId);
        // ...
    }
}
```

**ë¬¸ì œì :**
- ë„ë©”ì¸ ê²€ì¦ì´ Application Layerì— ëˆ„ìˆ˜
- ì¼ë¶€ ë„ë©”ì¸ ë¡œì§ ë¶„ì‚°

---

#### â­â­â­â­ (80ì ) - ì¢‹ìŒ

**íŠ¹ì§•:**
- ëª…í™•í•œ ë ˆì´ì–´ ë¶„ë¦¬ (Presentation â†’ Application â†’ Domain â†’ Infrastructure)
- Port/Adapter íŒ¨í„´ ì ìš©
- **ì¼ë¶€ ë„ë©”ì¸ ë¡œì§ì´ Application Layerì— ëˆ„ìˆ˜**
- Dependency Rule ëŒ€ë¶€ë¶„ ì¤€ìˆ˜

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
// Application Layerì— ë„ë©”ì¸ ê°ì²´ ìƒì„± ë¡œì§
public class WatchLimitSampleUsecase
{
    private Fin<(LimitSample, FilmMaster)> CreateDomainObjects(
        DateTime latestFileTime,
        IEnumerable<string> limitSamplePaths,
        IEnumerable<string> filmMasterPaths)
    {
        return
            from limitSample in LimitSample.Create(latestFileTime, limitSamplePaths)
            from filmMaster in FilmMaster.Create(latestFileTime, filmMasterPaths)
            select (limitSample, filmMaster);
    }
}
```

**ë¬¸ì œì :**
- ë„ë©”ì¸ ê°ì²´ ìƒì„± ë¡œì§ì´ Application Layerì— ìœ„ì¹˜
- Domain Serviceë¡œ ì´ë™ ê°€ëŠ¥í•œ ë¡œì§

---

#### â­â­â­â­â­ (100ì ) - íƒì›”

**íŠ¹ì§•:**
- **ì™„ë²½í•œ ë ˆì´ì–´ ë¶„ë¦¬ ë° Dependency Rule ì¤€ìˆ˜**
- ëª¨ë“  ë„ë©”ì¸ ë¡œì§ì´ Domain Layerì— ìœ„ì¹˜
- Application LayerëŠ” ìˆœìˆ˜ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜ë§Œ ìˆ˜í–‰
- Port/Adapter íŒ¨í„´ ì™„ë²½ ì ìš©
- ê° ë ˆì´ì–´ê°€ ëª…í™•í•œ ë‹¨ì¼ ì±…ì„

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
// Application Layer: ìˆœìˆ˜ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜
public class WatchLimitSampleUsecase
{
    public async Task<Response> HandleAsync(Request request)
    {
        FinT<IO, Seq<LineProcessingResult>> usecase =
            from ftpInfos in _repository.GetFtpConnectionInfosAsync(cancellationToken)

            // Domain Service í˜¸ì¶œ
            from results in new Seq<FtpConnectionInfo>(ftpInfos)
                .TraverseSerial(ftpInfo => WatchLimitSampleForLine(ftpInfo, cancellationToken))

            select results;

        return await usecase.Run().RunAsync();
    }

    private FinT<IO, Fin<string>> WatchLimitSampleForLine(...)
    {
        return
            from lastCheckTime in _stampFileSystem.GetOrCreateLastCheckTimeAsync(...)
            from ftpResult in _ftpClient.GetFilePathsWithLatestTimeAsync(...)

            // Domain Service ì‚¬ìš©
            let classification = LimitSampleFileClassificationService.ClassifyFiles(ftpResult.Paths)

            // Domain Serviceë¡œ ê°ì²´ ìƒì„±
            from domainObjects in FtpFileDomainObjectsCreationService.CreateFromFiles(
                ftpResult.LatestTime,
                classification.LimitSamplePaths,
                classification.FilmMasterPaths)

            from _ in PublishMessagesIfNeeded(domainObjects.LimitSample, domainObjects.FilmMaster, ...)
            from __ in _stampFileSystem.UpdateLastCheckTimeAsync(...)

            select unit;
    }
}

// Domain Layer: Domain Service
public static class FtpFileDomainObjectsCreationService
{
    public static Fin<(LimitSample LimitSample, FilmMaster FilmMaster)> CreateFromFiles(
        DateTime latestFileTime,
        IEnumerable<string> limitSamplePaths,
        IEnumerable<string> filmMasterPaths)
    {
        return
            from limitSample in LimitSample.Create(latestFileTime, limitSamplePaths)
            from filmMaster in FilmMaster.Create(latestFileTime, filmMasterPaths)
            select (limitSample, filmMaster);
    }
}
```

**ì¥ì :**
- Application LayerëŠ” Portë¥¼ í†µí•´ì„œë§Œ ì™¸ë¶€ì™€ í†µì‹ 
- ëª¨ë“  ë„ë©”ì¸ ë¡œì§ì´ Domain Layerì— ìº¡ìŠí™”
- ë ˆì´ì–´ ê°„ ì˜ì¡´ì„±ì´ í•œ ë°©í–¥ìœ¼ë¡œë§Œ íë¦„ (ë‚´ë¶€ë¡œ)

---

### 2. ë„ë©”ì¸ ëª¨ë¸ë§ (Domain Modeling)

DDD(Domain-Driven Design) ì›ì¹™ì— ë”°ë¥¸ Rich Domain Model êµ¬í˜„ ìˆ˜ì¤€ì„ í‰ê°€í•©ë‹ˆë‹¤.

#### â­ (20ì ) - ë§¤ìš° ë¶€ì¡±

**íŠ¹ì§•:**
- Anemic Domain Model (ë¹ˆì•½í•œ ë„ë©”ì¸ ëª¨ë¸)
- ëª¨ë“  Entityê°€ getter/setterë§Œ ì¡´ì¬
- ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì´ Serviceì— ì§‘ì¤‘

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
// Anemic Domain Model
public class LimitSample
{
    public string LineId { get; set; }
    public string ProcessId { get; set; }
    public string PartId { get; set; }
    public DateTime CreatedAt { get; set; }
}

// ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì´ Serviceì— ì§‘ì¤‘
public class LimitSampleService
{
    public bool Validate(LimitSample sample)
    {
        if (string.IsNullOrEmpty(sample.LineId)) return false;
        if (string.IsNullOrEmpty(sample.ProcessId)) return false;
        return true;
    }
}
```

**ë¬¸ì œì :**
- Entityê°€ ë°ì´í„° ì»¨í…Œì´ë„ˆë¡œë§Œ ì‚¬ìš©ë¨
- ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ê³¼ ë°ì´í„°ê°€ ë¶„ë¦¬
- ë„ë©”ì¸ ê°œë…ì´ ì½”ë“œì— ë°˜ì˜ë˜ì§€ ì•ŠìŒ

---

#### â­â­ (40ì ) - ë¶€ì¡±

**íŠ¹ì§•:**
- ì¼ë¶€ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì´ Entityì— ìˆìœ¼ë‚˜ ëŒ€ë¶€ë¶„ Serviceì— ì¡´ì¬
- Value Object ë¯¸ì‚¬ìš© (ì›ì‹œ íƒ€ì… ì‚¬ìš©)
- Aggregate ê²½ê³„ê°€ ë¶ˆëª…í™•

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
public class LimitSample
{
    public string LineId { get; private set; }
    public string ProcessId { get; private set; }

    // ì¼ë¶€ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
    public bool IsValid()
    {
        return !string.IsNullOrEmpty(LineId) && !string.IsNullOrEmpty(ProcessId);
    }
}

// ì—¬ì „íˆ Serviceì— ë§ì€ ë¡œì§
public class LimitSampleService
{
    public bool CanCreateLimitSample(string lineId, string processId)
    {
        // ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™
        return true;
    }
}
```

**ë¬¸ì œì :**
- ì›ì‹œ íƒ€ì… ì‚¬ìš© (stringìœ¼ë¡œ LineId í‘œí˜„)
- ê²€ì¦ ë¡œì§ì´ Entityì™€ Serviceì— ë¶„ì‚°
- ë„ë©”ì¸ ê°œë…ì´ ëª…ì‹œì ì´ì§€ ì•ŠìŒ

---

#### â­â­â­ (60ì ) - ë³´í†µ

**íŠ¹ì§•:**
- Entityì— ì¼ë¶€ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ í¬í•¨
- Value Objectë¥¼ ì¼ë¶€ ì‚¬ìš©í•˜ë‚˜ ì¼ê´€ì„± ë¶€ì¡±
- Aggregate Root ê°œë…ì€ ìˆìœ¼ë‚˜ ê²½ê³„ê°€ ëª…í™•í•˜ì§€ ì•ŠìŒ

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
// Value Object ì¼ë¶€ ì‚¬ìš©
public record LineId(string Value);
public record ProcessId(string Value);

public class LimitSample
{
    public LineId LineId { get; private set; }
    public ProcessId ProcessId { get; private set; }

    // ì¼ë¶€ ê²€ì¦ ë¡œì§
    public bool Validate()
    {
        return LineId != null && ProcessId != null;
    }
}

// í•˜ì§€ë§Œ ì—¬ì „íˆ ì›ì‹œ íƒ€ì…ë„ í˜¼ì¬
public class FilmMaster
{
    public string LineId { get; private set; }  // Value Object ë¯¸ì‚¬ìš©
    public string ProcessId { get; private set; }
}
```

**ë¬¸ì œì :**
- Value Object ì‚¬ìš©ì´ ì¼ê´€ì ì´ì§€ ì•ŠìŒ
- ê²€ì¦ ë¡œì§ì´ Value Objectì— ì—†ìŒ
- Aggregate ê²½ê³„ ë¶ˆëª…í™•

---

#### â­â­â­â­ (80ì ) - ì¢‹ìŒ

**íŠ¹ì§•:**
- Rich Domain Model ì ìš©
- Value Object ì ê·¹ í™œìš©
- Aggregate Rootì™€ ê²½ê³„ ëª…í™•
- **ì¼ë¶€ ê²€ì¦ ë¡œì§ì´ Application Layerì— ìœ„ì¹˜**
- Domain Event ë¯¸ì‚¬ìš© ë˜ëŠ” ë¶€ë¶„ ì‚¬ìš©

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
// Value Object
public record LineId(string Value);
public record ProcessId(string Value);
public record PartId(string Value);

// Aggregate Root
public class LimitSample : AggregateRoot
{
    public LineId LineId { get; private set; }
    public ProcessId ProcessId { get; private set; }
    public PartId PartId { get; private set; }

    public static Fin<LimitSample> Create(
        DateTime latestFileTime,
        IEnumerable<string> filePaths)
    {
        // ìƒì„± ë¡œì§
        return new LimitSample(...);
    }
}

// í•˜ì§€ë§Œ ê²€ì¦ì€ Application Layerì—ì„œ ìˆ˜í–‰
public class LoadLimitSampleUsecase
{
    public async Task<Response> HandleAsync(Request request)
    {
        // Application Layerì—ì„œ ê²€ì¦
        if (string.IsNullOrEmpty(request.LineId))
            return Response.Fail("Invalid LineId");

        var sample = await _repository.GetAsync(request.LineId);
        // ...
    }
}
```

**ë¬¸ì œì :**
- ê²€ì¦ ë¡œì§ì´ Application Layerì— ëˆ„ìˆ˜
- Value Objectì— ê²€ì¦ ë¡œì§ ìº¡ìŠí™” í•„ìš”

---

#### â­â­â­â­â­ (100ì ) - íƒì›”

**íŠ¹ì§•:**
- **ì™„ë²½í•œ Rich Domain Model**
- ëª¨ë“  ì›ì‹œ íƒ€ì…ì´ Value Objectë¡œ ë˜í•‘
- **ê²€ì¦ ë¡œì§ì´ ëª¨ë‘ Value Object/Entity ë‚´ë¶€ì— ìº¡ìŠí™”**
- Aggregate ë¶ˆë³€ì„± ë³´ì¥
- Domain Eventë¡œ ë¶€ì‘ìš© ê´€ë¦¬
- Ubiquitous Language ì¼ê´€ì„± ìœ ì§€

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
// Value Object with Validation
public sealed record LineId
{
    private readonly string _value;

    private LineId(string value) => _value = value;

    public static Validation<Error, LineId> Create(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            return Fail<Error, LineId>(Error.New("LineId cannot be empty"));

        if (!Regex.IsMatch(value, @"^[A-Z0-9]{1,10}$"))
            return Fail<Error, LineId>(Error.New("LineId must be alphanumeric"));

        return Success<Error, LineId>(new LineId(value));
    }

    public override string ToString() => _value;
}

// ë³µí•© Value Object with Validation
public sealed record LimitSampleIdentifier
{
    public LineId LineId { get; init; }
    public ProcessId ProcessId { get; init; }
    public PartId PartId { get; init; }
    public MguideVersion Version { get; init; }

    private LimitSampleIdentifier() { }

    public static Validation<Error, LimitSampleIdentifier> Validate(
        string lineId,
        string processId,
        string partId,
        string version)
    {
        return
            (LineId.Create(lineId),
             ProcessId.Create(processId),
             PartId.Create(partId),
             MguideVersion.Create(version))
            .Apply((lid, pid, paid, ver) => new LimitSampleIdentifier
            {
                LineId = lid,
                ProcessId = pid,
                PartId = paid,
                Version = ver
            });
    }
}

// Application Layer: ê²€ì¦ ë¡œì§ ì—†ìŒ, ìˆœìˆ˜ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜
public class LoadLimitSampleUsecase
{
    public async Task<Response> HandleAsync(Request request)
    {
        return
            // Value Objectì˜ Validate ë©”ì„œë“œ ì‚¬ìš©
            from validated in LimitSampleIdentifier.Validate(
                request.LineId,
                request.ProcessId,
                request.PartId,
                request.Version)

            from createResult in _limitSampleApiService.CreateLimitSampleAsync(
                validated.LineId,
                validated.PartId,
                validated.Version.ToString(),
                "SYSTEM",
                CommandType.ChangedFilmmaster,
                cancellationToken)

            from _ in _messageQueue.PublishLoadMessageAsync(...)

            select new Response(true);
    }
}
```

**ì¥ì :**
- ëª¨ë“  ê²€ì¦ì´ Value Object ë‚´ë¶€ì— ìº¡ìŠí™”
- Application Layerì— ë„ë©”ì¸ ë¡œì§ ëˆ„ìˆ˜ ì—†ìŒ
- ë¶ˆê°€ëŠ¥í•œ ìƒíƒœ í‘œí˜„ ë¶ˆê°€ (Make Illegal States Unrepresentable)
- ë„ë©”ì¸ ê°œë…ì´ ì½”ë“œì— ëª…ì‹œì ìœ¼ë¡œ í‘œí˜„

---

### 3. ì—ëŸ¬ ì²˜ë¦¬ (Error Handling)

Functional Error Handling ë° Railway-Oriented Programming ì ìš© ìˆ˜ì¤€ì„ í‰ê°€í•©ë‹ˆë‹¤.

#### â­ (20ì ) - ë§¤ìš° ë¶€ì¡±

**íŠ¹ì§•:**
- ì˜ˆì™¸(Exception) ë‚¨ë°œ
- try-catchê°€ ê³³ê³³ì— ì‚°ì¬
- ì—ëŸ¬ ì •ë³´ ì†ì‹¤ ë˜ëŠ” ë¶ˆì¶©ë¶„

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
public async Task<LimitSample> CreateLimitSampleAsync(string lineId)
{
    try
    {
        var response = await _httpClient.PostAsync(...);
        if (!response.IsSuccessStatusCode)
            throw new Exception("API call failed");

        return await response.Content.ReadAsAsync<LimitSample>();
    }
    catch (Exception ex)
    {
        Console.WriteLine(ex.Message);
        throw;  // ì—ëŸ¬ ì •ë³´ ì†ì‹¤
    }
}
```

**ë¬¸ì œì :**
- ì˜ˆì™¸ë¥¼ ì œì–´ íë¦„ìœ¼ë¡œ ì‚¬ìš©
- ì—ëŸ¬ê°€ íƒ€ì… ì‹œê·¸ë‹ˆì²˜ì— í‘œí˜„ë˜ì§€ ì•ŠìŒ
- ì—ëŸ¬ ë³µêµ¬ ì „ëµ ë¶€ì¬

---

#### â­â­ (40ì ) - ë¶€ì¡±

**íŠ¹ì§•:**
- ì˜ˆì™¸ ì‚¬ìš©í•˜ë˜ ì¼ë¶€ Result íŒ¨í„´ í˜¼ìš©
- ì—ëŸ¬ ì²˜ë¦¬ ì¼ê´€ì„± ë¶€ì¡±
- ì—ëŸ¬ ë¡œê¹… ë¯¸ë¹„

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
public async Task<Result<LimitSample>> CreateLimitSampleAsync(string lineId)
{
    try
    {
        var response = await _httpClient.PostAsync(...);
        if (!response.IsSuccessStatusCode)
            return Result<LimitSample>.Failure("API call failed");

        var sample = await response.Content.ReadAsAsync<LimitSample>();
        return Result<LimitSample>.Success(sample);
    }
    catch (Exception ex)
    {
        return Result<LimitSample>.Failure(ex.Message);
    }
}

// í•˜ì§€ë§Œ ë‹¤ë¥¸ ê³³ì—ì„œëŠ” ì˜ˆì™¸ ì‚¬ìš©
public async Task<FilmMaster> GetFilmMasterAsync(string id)
{
    var filmMaster = await _repository.GetAsync(id);
    if (filmMaster == null)
        throw new NotFoundException($"FilmMaster not found: {id}");
    return filmMaster;
}
```

**ë¬¸ì œì :**
- Result íŒ¨í„´ê³¼ ì˜ˆì™¸ê°€ í˜¼ì¬
- ì¼ê´€ì„± ë¶€ì¡±
- ì—ëŸ¬ íƒ€ì…ì´ ëª…ì‹œì ì´ì§€ ì•ŠìŒ

---

#### â­â­â­ (60ì ) - ë³´í†µ

**íŠ¹ì§•:**
- Result/Option íŒ¨í„´ ë¶€ë¶„ ì ìš©
- ì¼ë¶€ ì—ëŸ¬ ì •ë³´ ì†ì‹¤
- ì—ëŸ¬ ì²˜ë¦¬ê°€ ì¼ê´€ì ì´ì§€ ì•ŠìŒ

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
public async Task<Option<LimitSample>> GetLimitSampleAsync(string lineId)
{
    var sample = await _repository.GetAsync(lineId);
    return sample != null ? Some(sample) : None;
}

public async Task<Result<Unit, Error>> CreateLimitSampleAsync(string lineId)
{
    var result = await _apiService.CreateAsync(lineId);
    return result.IsSuccess
        ? Success<Unit, Error>(unit)
        : Failure<Unit, Error>(Error.New("Creation failed"));
}

// í•˜ì§€ë§Œ ì—ëŸ¬ ì •ë³´ê°€ ì¶©ë¶„í•˜ì§€ ì•ŠìŒ
public async Task<Result<Response, string>> HandleAsync(Request request)
{
    var sample = await GetLimitSampleAsync(request.LineId);
    if (sample.IsNone)
        return Failure<Response, string>("Sample not found");  // stringìœ¼ë¡œ ì—ëŸ¬ í‘œí˜„

    // ...
}
```

**ë¬¸ì œì :**
- ì—ëŸ¬ íƒ€ì…ì´ `string`ìœ¼ë¡œ í‘œí˜„ (êµ¬ì¡°í™”ë˜ì§€ ì•ŠìŒ)
- ì¼ë¶€ Option ì‚¬ìš©ìœ¼ë¡œ ì—ëŸ¬ ì›ì¸ íŒŒì•… ë¶ˆê°€
- Railway-Oriented Programming ë¯¸ì ìš©

---

#### â­â­â­â­ (80ì ) - ì¢‹ìŒ

**íŠ¹ì§•:**
- Fin/Result íŒ¨í„´ ì¼ê´€ë˜ê²Œ ì ìš©
- Railway-Oriented Programming ì ìš©
- **ì¼ë¶€ ì—ëŸ¬ ì„¸ë¶€ ì •ë³´ ì†ì‹¤** (ì˜ˆ: `Fin<string>`ìœ¼ë¡œ ë³€í™˜ ì‹œ)
- ì—ëŸ¬ ë¡œê¹…ì€ ì¶©ë¶„

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
public async Task<IFinResponse<Response>> HandleAsync(Request request)
{
    FinT<IO, Response> usecase =
        from ftpInfos in _repository.GetFtpConnectionInfosAsync(cancellationToken)

        from results in new Seq<FtpConnectionInfo>(ftpInfos)
            .TraverseSerial(ftpInfo => WatchLimitSampleForLine(ftpInfo, cancellationToken))

        select new Response(results);

    Fin<Response> response = await usecase.Run().RunAsync();
    return new FinResponse<Response>(response);
}

private FinT<IO, Fin<string>> WatchLimitSampleForLine(FtpConnectionInfo ftpInfo, ...)
{
    FinT<IO, Unit> processing = /* ... ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ... */;

    // ì—ëŸ¬ ì •ë³´ ì†ì‹¤: ì–´ë–¤ LineIdê°€ ì‹¤íŒ¨í–ˆëŠ”ì§€ë§Œ ì•Œ ìˆ˜ ìˆìŒ
    return processing
        .Map(_ => Fin<string>.Succ(ftpInfo.LineId))
        .IfFail(error => Fin<string>.Fail(error))  // error ì„¸ë¶€ ì •ë³´ëŠ” ì—¬ê¸°ì„œ ì†ì‹¤
        .As();
}
```

**ë¬¸ì œì :**
- `Fin<string>`ìœ¼ë¡œ ë³€í™˜ ì‹œ ì—ëŸ¬ ì„¸ë¶€ ì •ë³´ ì†ì‹¤
- ì„±ê³µ ì‹œì—ëŠ” LineIdë§Œ, ì‹¤íŒ¨ ì‹œì—ëŠ” ì—ëŸ¬ë§Œ ì•Œ ìˆ˜ ìˆìŒ
- ì‹¤íŒ¨í•œ í•­ëª©ê³¼ ì—ëŸ¬ì˜ ì—°ê²°ì´ ëª…í™•í•˜ì§€ ì•ŠìŒ

---

#### â­â­â­â­â­ (100ì ) - íƒì›”

**íŠ¹ì§•:**
- **ì™„ë²½í•œ Functional Error Handling**
- ëª¨ë“  ì—ëŸ¬ ì •ë³´ ë³´ì¡´ (íƒ€ì…, ë©”ì‹œì§€, ì»¨í…ìŠ¤íŠ¸)
- **êµ¬ì¡°í™”ëœ ì—ëŸ¬ íƒ€ì…** (ì˜ˆ: LineProcessingResult)
- Railway-Oriented Programming ì™„ë²½ ì ìš©
- ì—ëŸ¬ ì¶”ì  ë° ë¡œê¹… ì™„ë²½
- ì˜ˆì™¸ ì‚¬ìš© ìµœì†Œí™” (unavoidable exceptionë§Œ)

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
// êµ¬ì¡°í™”ëœ ê²°ê³¼ íƒ€ì…
public sealed record class LineProcessingResult
{
    public required string LineId { get; init; }
    public required bool IsSuccess { get; init; }
    public Error? Error { get; init; }

    public static LineProcessingResult Success(string lineId) =>
        new() { LineId = lineId, IsSuccess = true, Error = null };

    public static LineProcessingResult Failure(string lineId, Error error) =>
        new() { LineId = lineId, IsSuccess = false, Error = error };
}

public sealed record class Response(Seq<LineProcessingResult> Results) : IResponse;

// Usecase: ëª¨ë“  ì—ëŸ¬ ì •ë³´ ë³´ì¡´
public async Task<IFinResponse<Response>> HandleAsync(Request request)
{
    FinT<IO, Seq<LineProcessingResult>> usecase =
        from ftpInfos in _repository.GetFtpConnectionInfosAsync(cancellationToken)

        from results in new Seq<FtpConnectionInfo>(ftpInfos)
            .TraverseSerial(ftpInfo => WatchLimitSampleForLine(ftpInfo, cancellationToken)
                .Map(fin => fin.Match(
                    Succ: lineId => LineProcessingResult.Success(lineId),
                    Fail: error => LineProcessingResult.Failure(ftpInfo.LineId, error))))

        select results;

    Fin<Response> response = await usecase
        .Map(results => new Response(results))
        .Run()
        .RunAsync();

    return new FinResponse<Response>(response);
}

private FinT<IO, Fin<string>> WatchLimitSampleForLine(FtpConnectionInfo ftpInfo, ...)
{
    return
        from lastCheckTime in _stampFileSystem.GetOrCreateLastCheckTimeAsync(...)
        from ftpResult in _ftpClient.GetFilePathsWithLatestTimeAsync(...)
        let classification = LimitSampleFileClassificationService.ClassifyFiles(ftpResult.Paths)
        from domainObjects in FtpFileDomainObjectsCreationService.CreateFromFiles(...)
        from _ in PublishMessagesIfNeeded(...)
        from __ in _stampFileSystem.UpdateLastCheckTimeAsync(...)

        select Fin<string>.Succ(ftpInfo.LineId);
}

// ë¡œê¹…: êµ¬ì¡°í™”ëœ ì •ë³´ ì¶œë ¥
if (response.IsSucc)
{
    Response res = response.Value!;

    IEnumerable<LineProcessingResult> successes = res.Results.Where(r => r.IsSuccess);
    IEnumerable<LineProcessingResult> failures = res.Results.Where(r => !r.IsSuccess);

    int successCount = successes.Count();
    int failureCount = failures.Count();

    // ì„±ê³µ/ì‹¤íŒ¨ LineId ëª©ë¡ ìƒì„±
    string successLines = string.Join(", ", successes.Select(s => s.LineId));
    string failedLines = string.Join(", ", failures.Select(f => $"{f.LineId}({f.Error!.Code})"));

    _logger.LogSuccessResponse(
        _loggingContext,
        elapsed,
        "Usecase: {SuccessCount} succeeded, {FailureCount} failed. Success: [{SuccessLines}], Failed: [{FailedLines}]",
        new
        {
            SuccessCount = successCount,
            FailureCount = failureCount,
            SuccessLines = successLines,
            FailedLines = failedLines
        },
        successCount, failureCount);
}
```

**ì¥ì :**
- ì„±ê³µ/ì‹¤íŒ¨ ëª¨ë‘ LineIdì™€ ì—ëŸ¬ ì •ë³´ ë³´ì¡´
- êµ¬ì¡°í™”ëœ íƒ€ì…ìœ¼ë¡œ ì—ëŸ¬ ì²˜ë¦¬
- ë¡œê¹…ì—ì„œ ì „ì²´ ì²˜ë¦¬ ê²°ê³¼ë¥¼ ëª…í™•íˆ í™•ì¸ ê°€ëŠ¥
- Railway-Oriented Programmingìœ¼ë¡œ ê¹”ë”í•œ ì—ëŸ¬ ì „íŒŒ

---

### 4. í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„± (Testability)

ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ìš©ì´ì„± ë° Pure Function í™œìš© ìˆ˜ì¤€ì„ í‰ê°€í•©ë‹ˆë‹¤.

#### â­ (20ì ) - ë§¤ìš° ë¶€ì¡±

**íŠ¹ì§•:**
- ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ë¶ˆê°€ëŠ¥í•œ êµ¬ì¡°
- Static method, Singleton ë‚¨ë°œ
- ì˜ì¡´ì„± ì£¼ì… ë¯¸ì‚¬ìš©

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
// Singleton ì‚¬ìš©
public class DatabaseManager
{
    private static DatabaseManager _instance;
    public static DatabaseManager Instance => _instance ??= new DatabaseManager();

    private SqlConnection _connection = new SqlConnection("...");

    public User GetUser(int id)
    {
        return _connection.Query<User>("SELECT * FROM Users WHERE Id = @id", new { id }).First();
    }
}

// í…ŒìŠ¤íŠ¸ ë¶ˆê°€ëŠ¥í•œ ì½”ë“œ
public class UserService
{
    public User GetUser(int id)
    {
        return DatabaseManager.Instance.GetUser(id);  // í…ŒìŠ¤íŠ¸ ì‹œ Mock ë¶ˆê°€ëŠ¥
    }
}
```

**ë¬¸ì œì :**
- Singletonìœ¼ë¡œ ì¸í•œ ì „ì—­ ìƒíƒœ
- ì˜ì¡´ì„± ì£¼ì… ë¶ˆê°€
- ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„± ë¶ˆê°€ëŠ¥

---

#### â­â­ (40ì ) - ë¶€ì¡±

**íŠ¹ì§•:**
- ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•˜ë‚˜ ë§ì€ Mock í•„ìš”
- ì˜ì¡´ì„±ì´ ëª…ì‹œì ì´ì§€ ì•ŠìŒ (Service Locator íŒ¨í„´)
- í…ŒìŠ¤íŠ¸ ì‘ì„±ì´ ë§¤ìš° ì–´ë ¤ì›€

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
// Service Locator íŒ¨í„´
public class UserService
{
    private readonly IServiceLocator _serviceLocator;

    public UserService(IServiceLocator serviceLocator)
    {
        _serviceLocator = serviceLocator;
    }

    public async Task<User> GetUserAsync(int id)
    {
        var repository = _serviceLocator.GetService<IUserRepository>();
        var logger = _serviceLocator.GetService<ILogger>();
        var cache = _serviceLocator.GetService<ICache>();

        // ...
    }
}

// í…ŒìŠ¤íŠ¸ ì‹œ ServiceLocator Mock í•„ìš”
[Fact]
public async Task GetUserAsync_ShouldReturnUser()
{
    var mockServiceLocator = new Mock<IServiceLocator>();
    mockServiceLocator.Setup(x => x.GetService<IUserRepository>()).Returns(mockRepository.Object);
    mockServiceLocator.Setup(x => x.GetService<ILogger>()).Returns(mockLogger.Object);
    mockServiceLocator.Setup(x => x.GetService<ICache>()).Returns(mockCache.Object);

    var service = new UserService(mockServiceLocator.Object);
    // ...
}
```

**ë¬¸ì œì :**
- ì˜ì¡´ì„±ì´ ì•”ë¬µì 
- í…ŒìŠ¤íŠ¸ ì‹œ ë³µì¡í•œ Setup
- Service Locatorë¥¼ Mockí•´ì•¼ í•¨

---

#### â­â­â­ (60ì ) - ë³´í†µ

**íŠ¹ì§•:**
- ì˜ì¡´ì„± ì£¼ì… ì‚¬ìš©
- ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•˜ë‚˜ ë³µì¡í•œ Setup í•„ìš”
- Mockì´ ê³¼ë„í•˜ê²Œ í•„ìš” (5ê°œ ì´ìƒ)

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
public class LimitSampleService
{
    private readonly ILimitSampleRepository _repository;
    private readonly ILogger _logger;
    private readonly ICache _cache;
    private readonly IMessagePublisher _messagePublisher;
    private readonly IFileSystem _fileSystem;
    private readonly IHttpClient _httpClient;

    public LimitSampleService(
        ILimitSampleRepository repository,
        ILogger logger,
        ICache cache,
        IMessagePublisher messagePublisher,
        IFileSystem fileSystem,
        IHttpClient httpClient)
    {
        _repository = repository;
        _logger = logger;
        _cache = cache;
        _messagePublisher = messagePublisher;
        _fileSystem = fileSystem;
        _httpClient = httpClient;
    }

    public async Task<Result> ProcessAsync(string lineId)
    {
        // ë³µì¡í•œ ë¡œì§
    }
}

// í…ŒìŠ¤íŠ¸ ì‹œ ë§ì€ Mock í•„ìš”
[Fact]
public async Task ProcessAsync_ShouldSucceed()
{
    var mockRepository = new Mock<ILimitSampleRepository>();
    var mockLogger = new Mock<ILogger>();
    var mockCache = new Mock<ICache>();
    var mockMessagePublisher = new Mock<IMessagePublisher>();
    var mockFileSystem = new Mock<IFileSystem>();
    var mockHttpClient = new Mock<IHttpClient>();

    mockRepository.Setup(x => x.GetAsync(It.IsAny<string>())).ReturnsAsync(new LimitSample());
    mockCache.Setup(x => x.GetAsync(It.IsAny<string>())).ReturnsAsync((object)null);
    // ... ë§ì€ Setup

    var service = new LimitSampleService(
        mockRepository.Object,
        mockLogger.Object,
        mockCache.Object,
        mockMessagePublisher.Object,
        mockFileSystem.Object,
        mockHttpClient.Object);

    var result = await service.ProcessAsync("LINE01");

    Assert.True(result.IsSuccess);
}
```

**ë¬¸ì œì :**
- ì˜ì¡´ì„±ì´ ë„ˆë¬´ ë§ìŒ (SRP ìœ„ë°˜ ê°€ëŠ¥ì„±)
- í…ŒìŠ¤íŠ¸ Setupì´ ë³µì¡
- Mock ê´€ë¦¬ê°€ ì–´ë ¤ì›€

---

#### â­â­â­â­ (80ì ) - ì¢‹ìŒ

**íŠ¹ì§•:**
- ëª…ì‹œì  ì˜ì¡´ì„± ì£¼ì…
- ëŒ€ë¶€ë¶„ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥
- **ì¼ë¶€ ì¸ìŠ¤í„´ìŠ¤ ì„œë¹„ìŠ¤ê°€ Pure Functionìœ¼ë¡œ ë³€í™˜ ê°€ëŠ¥**
- Mock ìµœì†Œí™” (2-3ê°œ)

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
// ì¸ìŠ¤í„´ìŠ¤ ì„œë¹„ìŠ¤ (Mock í•„ìš”)
public class LimitSampleFileClassificationService
{
    public ClassificationResult ClassifyFiles(IEnumerable<string> filePaths)
    {
        var limitSamplePaths = new List<string>();
        var filmMasterPaths = new List<string>();

        foreach (var path in filePaths)
        {
            if (path.Contains("LIMITSAMPLE"))
                limitSamplePaths.Add(path);
            else if (path.Contains("FILMMASTER"))
                filmMasterPaths.Add(path);
        }

        return new ClassificationResult(limitSamplePaths, filmMasterPaths);
    }
}

// Usecase
public class WatchLimitSampleUsecase
{
    private readonly IRepository _repository;
    private readonly IFtpClient _ftpClient;
    private readonly LimitSampleFileClassificationService _classificationService;  // ì¸ìŠ¤í„´ìŠ¤

    public WatchLimitSampleUsecase(
        IRepository repository,
        IFtpClient ftpClient,
        LimitSampleFileClassificationService classificationService)
    {
        _repository = repository;
        _ftpClient = ftpClient;
        _classificationService = classificationService;
    }

    public async Task<Response> HandleAsync(Request request)
    {
        // ...
        var classification = _classificationService.ClassifyFiles(filePaths);
        // ...
    }
}

// í…ŒìŠ¤íŠ¸ ì‹œ Mock í•„ìš”
[Fact]
public async Task HandleAsync_ShouldClassifyFiles()
{
    var mockRepository = new Mock<IRepository>();
    var mockFtpClient = new Mock<IFtpClient>();
    var mockClassificationService = new Mock<LimitSampleFileClassificationService>();  // Mock í•„ìš”!

    mockClassificationService
        .Setup(x => x.ClassifyFiles(It.IsAny<IEnumerable<string>>()))
        .Returns(new ClassificationResult(...));

    var usecase = new WatchLimitSampleUsecase(
        mockRepository.Object,
        mockFtpClient.Object,
        mockClassificationService.Object);

    // ...
}
```

**ë¬¸ì œì :**
- Pure Functionì´ì§€ë§Œ ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œë¡œ êµ¬í˜„
- ë¶ˆí•„ìš”í•œ Mock í•„ìš”
- Static classë¡œ ë³€í™˜ ê°€ëŠ¥

---

#### â­â­â­â­â­ (100ì ) - íƒì›”

**íŠ¹ì§•:**
- **ì™„ë²½í•œ Testability**
- Pure Function ìµœëŒ€ í™œìš© (Mock ë¶ˆí•„ìš”)
- **Static classë¡œ ë³€í™˜ ê°€ëŠ¥í•œ ì„œë¹„ìŠ¤ëŠ” ëª¨ë‘ ë³€í™˜ë¨**
- ì˜ì¡´ì„± ëª…ì‹œì ì´ë©° ìµœì†Œí™”
- í…ŒìŠ¤íŠ¸ ì‘ì„±ì´ ë§¤ìš° ì‰¬ì›€ (Given-When-Then ëª…í™•)
- Integration Testë„ ì‰½ê²Œ ì‘ì„± ê°€ëŠ¥

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
// Pure Function (Static class)
public static class LimitSampleFileClassificationService
{
    /// <summary>
    /// íŒŒì¼ ê²½ë¡œ ëª©ë¡ì„ LimitSampleê³¼ FilmMasterë¡œ ë¶„ë¥˜í•˜ëŠ” ìˆœìˆ˜ í•¨ìˆ˜
    ///
    /// Pure Function:
    /// - ì™¸ë¶€ ìƒíƒœì— ì˜ì¡´í•˜ì§€ ì•ŠìŒ
    /// - Side Effect ì—†ìŒ
    /// - ê°™ì€ ì…ë ¥ì— ëŒ€í•´ í•­ìƒ ê°™ì€ ì¶œë ¥
    /// </summary>
    public static ClassificationResult ClassifyFiles(IEnumerable<string> filePaths)
    {
        var limitSamplePaths = new List<string>();
        var filmMasterPaths = new List<string>();

        foreach (var path in filePaths)
        {
            if (path.Contains("LIMITSAMPLE"))
                limitSamplePaths.Add(path);
            else if (path.Contains("FILMMASTER"))
                filmMasterPaths.Add(path);
        }

        return new ClassificationResult(limitSamplePaths, filmMasterPaths);
    }
}

// Usecase: Static method ì§ì ‘ í˜¸ì¶œ
public class WatchLimitSampleUsecase
{
    private readonly IRepository _repository;
    private readonly IFtpClient _ftpClient;
    // classificationService ì˜ì¡´ì„± ì œê±°!

    public WatchLimitSampleUsecase(
        IRepository repository,
        IFtpClient ftpClient)
    {
        _repository = repository;
        _ftpClient = ftpClient;
    }

    public async Task<Response> HandleAsync(Request request)
    {
        return
            from ftpResult in _ftpClient.GetFilePathsAsync(...)

            // Static method ì§ì ‘ í˜¸ì¶œ (Mock ë¶ˆí•„ìš”)
            let classification = LimitSampleFileClassificationService.ClassifyFiles(ftpResult.Paths)

            from domainObjects in CreateDomainObjects(
                classification.LimitSamplePaths,
                classification.FilmMasterPaths)

            select new Response(domainObjects);
    }
}

// ë‹¨ìœ„ í…ŒìŠ¤íŠ¸: Mock ì „í˜€ ë¶ˆí•„ìš”!
[Fact]
public void ClassifyFiles_ShouldSeparateLimitSampleAndFilmMaster()
{
    // Given
    var files = new[]
    {
        "/path/to/LIMITSAMPLE_V1.dat",
        "/path/to/FILMMASTER_V1.dat",
        "/path/to/LIMITSAMPLE_V2.dat"
    };

    // When
    var result = LimitSampleFileClassificationService.ClassifyFiles(files);

    // Then
    Assert.Equal(2, result.LimitSamplePaths.Count());
    Assert.Single(result.FilmMasterPaths);
    // Mock ì „í˜€ ë¶ˆí•„ìš” - Pure Functionì´ë¯€ë¡œ!
}

// Usecase í†µí•© í…ŒìŠ¤íŠ¸ë„ ê°„ë‹¨
[Fact]
public async Task HandleAsync_ShouldClassifyAndProcess()
{
    var mockRepository = new Mock<IRepository>();
    var mockFtpClient = new Mock<IFtpClient>();

    mockFtpClient
        .Setup(x => x.GetFilePathsAsync(It.IsAny<string>(), ...))
        .ReturnsAsync(new FtpResult(new[]
        {
            "/LIMITSAMPLE_V1.dat",
            "/FILMMASTER_V1.dat"
        }));

    var usecase = new WatchLimitSampleUsecase(
        mockRepository.Object,
        mockFtpClient.Object);
        // classificationService Mock ë¶ˆí•„ìš”!

    var response = await usecase.HandleAsync(new Request());

    Assert.True(response.IsSuccess);
}
```

**ì¥ì :**
- Pure Functionì€ Mock ì—†ì´ ì§ì ‘ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥
- ì˜ì¡´ì„± ìµœì†Œí™” (ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ë¹„ìš© ì œê±°)
- í…ŒìŠ¤íŠ¸ ì‘ì„±ì´ ë§¤ìš° ê°„ë‹¨ (Given-When-Then ëª…í™•)
- ì„±ëŠ¥ í–¥ìƒ (ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ì˜¤ë²„í—¤ë“œ ì—†ìŒ)
- ì˜ë„ê°€ ëª…í™• (Pure Functionì„ì„ íƒ€ì… ì‹œìŠ¤í…œìœ¼ë¡œ í‘œí˜„)

---

### 5. ì½”ë“œ ì¼ê´€ì„± (Code Consistency)

íŒ¨í„´ ì¼ê´€ì„± ë° ì½”ë”© ìŠ¤íƒ€ì¼ í†µì¼ ìˆ˜ì¤€ì„ í‰ê°€í•©ë‹ˆë‹¤.

#### â­ (20ì ) - ë§¤ìš° ë¶€ì¡±

**íŠ¹ì§•:**
- íŒ¨í„´ì´ íŒŒì¼ë§ˆë‹¤ ë‹¤ë¦„
- ëª…ëª… ê·œì¹™ ë¶ˆì¼ì¹˜
- ì½”ë”© ìŠ¤íƒ€ì¼ ì œê°ê°

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
// File1.cs - ëª…ë ¹í˜• ìŠ¤íƒ€ì¼
public async Task<Response> Process1(Request req)
{
    var result = await _repo.Get(req.id);
    if (result == null)
        return Response.fail("not found");
    return Response.success(result);
}

// File2.cs - í•¨ìˆ˜í˜• ìŠ¤íƒ€ì¼
public async Task<Response> Process2(Request request)
{
    return await
        (from result in _repository.GetAsync(request.Id)
         where result != null
         select Response.Success(result))
        .DefaultIfEmpty(Response.Failure("Not found"));
}

// File3.cs - í˜¼í•© ìŠ¤íƒ€ì¼
public async Task<Response> DoProcess(Request rq)
{
    try
    {
        var res = _svc.DoSomething(rq.ID);
        if (res.ok)
            return new Response { status = "success", data = res.value };
        else
            throw new Exception("failed");
    }
    catch (Exception ex)
    {
        return new Response { status = "error", message = ex.Message };
    }
}
```

**ë¬¸ì œì :**
- ëª…ëª… ê·œì¹™ ë¶ˆì¼ì¹˜ (req, request, rq / id, Id, ID)
- ì—ëŸ¬ ì²˜ë¦¬ ë°©ì‹ ì œê°ê°
- ì½”ë”© ìŠ¤íƒ€ì¼ í†µì¼ ì•ˆë¨

---

#### â­â­ (40ì ) - ë¶€ì¡±

**íŠ¹ì§•:**
- ì¼ë¶€ íŒ¨í„´ í†µì¼ë˜ì—ˆìœ¼ë‚˜ ì¼ê´€ì„± ë¶€ì¡±
- ê°™ì€ ê¸°ëŠ¥ì„ ë‹¤ë¥¸ ë°©ì‹ìœ¼ë¡œ êµ¬í˜„
- ì£¼ì„ ì²˜ë¦¬ëœ ì½”ë“œ ê³¼ë‹¤

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
// ì¼ë¶€ Validation ì‚¬ìš©
public async Task<Response> Process1(Request request)
{
    var validation = LineId.Validate(request.LineId);
    if (validation.IsFail)
        return Response.Failure(validation.Error);

    // ...
}

// ë‹¤ë¥¸ ê³³ì—ì„œëŠ” ì§ì ‘ ê²€ì¦
public async Task<Response> Process2(Request request)
{
    if (string.IsNullOrEmpty(request.ProcessId))
        return Response.Failure("Invalid ProcessId");

    // ...
}

// ì£¼ì„ ì²˜ë¦¬ëœ ì½”ë“œ ê³¼ë‹¤
public async Task<Response> Process3(Request request)
{
    var sample = await _repository.GetAsync(request.LineId);

    //// ê¸°ì¡´ ê²€ì¦ ë¡œì§ (ì‚­ì œ ì˜ˆì •)
    //if (sample == null)
    //    return Response.Failure("Sample not found");
    //
    //// ì¶”ê°€ ê²€ì¦
    //if (string.IsNullOrEmpty(sample.ProcessId))
    //    return Response.Failure("Invalid ProcessId");

    // ìƒˆë¡œìš´ ê²€ì¦
    var validation = LimitSampleIdentifier.Validate(sample.LineId, sample.ProcessId, ...);
    // ...
}
```

**ë¬¸ì œì :**
- Validation ì‚¬ìš© ë¶ˆì¼ì¹˜
- ì£¼ì„ ì½”ë“œê°€ ë§ì•„ ê°€ë…ì„± ì €í•˜
- ê²€ì¦ ë°©ì‹ì´ í†µì¼ë˜ì§€ ì•ŠìŒ

---

#### â­â­â­ (60ì ) - ë³´í†µ

**íŠ¹ì§•:**
- ê¸°ë³¸ì ì¸ íŒ¨í„´ ì¼ê´€ì„± ìœ ì§€
- ì¼ë¶€ ë¶ˆì¼ì¹˜ ì¡´ì¬ (Validation ë°©ì‹, ì—ëŸ¬ ì²˜ë¦¬ ë°©ì‹)
- ì£¼ì„ ì½”ë“œ ì¼ë¶€ ì¡´ì¬

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
// ëŒ€ë¶€ë¶„ LINQ ì‚¬ìš©í•˜ì§€ë§Œ ì¼ë¶€ ëª…ë ¹í˜•
public async Task<Response> Process1(Request request)
{
    return
        from validated in LineId.Validate(request.LineId).ToFin()
        from sample in _repository.GetAsync(validated)
        from _ in _messagePublisher.PublishAsync(sample)
        select new Response(sample);
}

// ì¼ë¶€ ëª…ë ¹í˜• ì½”ë“œ í˜¼ì¬
public async Task<Response> Process2(Request request)
{
    var validated = LineId.Validate(request.LineId);
    if (validated.IsFail)
        return Response.Failure(validated.Error);

    var sample = await _repository.GetAsync(validated.Value);
    await _messagePublisher.PublishAsync(sample);

    return Response.Success(sample);
}

// ì£¼ì„ ì½”ë“œ ì¼ë¶€
public async Task<Response> Process3(Request request)
{
    return
        from validated in LineId.Validate(request.LineId).ToFin()
        from sample in _repository.GetAsync(validated)

        //// ì¶”ê°€ ê²€ì¦ (ë‚˜ì¤‘ì— í™œì„±í™” ì˜ˆì •)
        //from _1 in guard(sample.IsValid(), Error.New("Invalid sample"))

        from _ in _messagePublisher.PublishAsync(sample)
        select new Response(sample);
}
```

**ë¬¸ì œì :**
- LINQì™€ ëª…ë ¹í˜• ì½”ë“œ í˜¼ì¬
- ì£¼ì„ ì½”ë“œ ì¼ë¶€ ì¡´ì¬
- íŒ¨í„´ ì¼ê´€ì„± ë¶€ì¡±

---

#### â­â­â­â­ (80ì ) - ì¢‹ìŒ

**íŠ¹ì§•:**
- ëŒ€ë¶€ë¶„ì˜ íŒ¨í„´ì´ ì¼ê´€ë¨
- **ì¼ë¶€ LINQ êµ¬ë¬¸ê³¼ ëª…ë ¹í˜• ì½”ë“œ í˜¼ì¬**
- **ì£¼ì„ ì²˜ë¦¬ëœ ì½”ë“œ ì¼ë¶€ ì¡´ì¬**
- ëª…ëª… ê·œì¹™ ì¼ê´€ì„± ìœ ì§€

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
// ëŒ€ë¶€ë¶„ LINQ ì‚¬ìš©
public async Task<IFinResponse<Response>> HandleAsync(Request request)
{
    FinT<IO, Response> usecase =
        from validated in LimitSampleIdentifier.Validate(
            request.LineId,
            request.ProcessId,
            request.PartId,
            request.Version).ToFinT()

        from createResult in _limitSampleApiService.CreateLimitSampleAsync(...)

        from _ in _messageQueue.PublishLoadMessageAsync(...)

        select new Response(true);

    return await usecase.Run().RunAsync();
}

// í•˜ì§€ë§Œ ì¼ë¶€ ëª…ë ¹í˜• ì½”ë“œ
public async Task<Response> ProcessSingleAsync(Sample sample)
{
    // ì¤‘ê°„ ë³€ìˆ˜ ì‚¬ìš©
    Validation<Error, LimitSampleIdentifier> validation =
        LimitSampleIdentifier.Validate(
            sample.LineId,
            sample.ProcessId,
            sample.PartId,
            sample.Version);

    Fin<LimitSampleIdentifier> fin = validation.Match(
        Succ: value => Fin<LimitSampleIdentifier>.Succ(value),
        Fail: errors => Fin<LimitSampleIdentifier>.Fail(errors.Head));

    return
        from validated in FinT<IO, LimitSampleIdentifier>.Lift(fin)
        from createResult in _limitSampleApiService.CreateLimitSampleAsync(...)
        select unit;
}

// ì£¼ì„ ì½”ë“œ ì¼ë¶€ ì¡´ì¬
public async Task<Response> AnotherProcessAsync(Request request)
{
    return
        from validated in Validate(request)

        //// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        //// 3. ìƒì„± ê²°ê³¼ ê²€ì¦ (ì‚­ì œ ì˜ˆì •)
        //// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        //from _1 in guard(
        //    createResult != null,
        //    ErrorCodeFactory.Create(...))

        from createResult in _apiService.CreateAsync(validated)
        from _ in _messagePublisher.PublishAsync(validated)
        select new Response(true);
}
```

**ë¬¸ì œì :**
- LINQ íŒ¨í„´ì´ ì¼ê´€ì ì´ì§€ ì•ŠìŒ (ì¤‘ê°„ ë³€ìˆ˜ ì‚¬ìš© vs ì§ì ‘ ì²´ì´ë‹)
- ì£¼ì„ ì½”ë“œ ì¼ë¶€ ì¡´ì¬
- Validation â†’ Fin ë³€í™˜ì´ í†µì¼ë˜ì§€ ì•ŠìŒ

---

#### â­â­â­â­â­ (100ì ) - íƒì›”

**íŠ¹ì§•:**
- **ì™„ë²½í•œ íŒ¨í„´ ì¼ê´€ì„±**
- **Validation â†’ FinT íŒ¨í„´ 100% í†µì¼**
- ì£¼ì„ ì²˜ë¦¬ëœ ì½”ë“œ ì „í˜€ ì—†ìŒ
- LINQ ì¿¼ë¦¬ í‘œí˜„ì‹ ì¼ê´€ë˜ê²Œ ì‚¬ìš©
- ëª…ëª… ê·œì¹™ ë° ì½”ë”© ìŠ¤íƒ€ì¼ ì™„ë²½ í†µì¼
- íŒ€ ì „ì²´ê°€ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ì½”ë“œ ì‘ì„± ê°€ëŠ¥

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
// SelectMany í™•ì¥ ë©”ì„œë“œë¡œ íŒ¨í„´ í†µì¼
public static FinT<IO, C> SelectMany<A, B, C>(
    this Validation<Error, A> validation,
    Func<A, FinT<IO, B>> finTSelector,
    Func<A, B, C> projector)
{
    Fin<A> fin = validation.Match(
        Succ: value => Fin<A>.Succ(value),
        Fail: errors => Fin<A>.Fail(errors.Head));

    return FinT<IO, A>.Lift(fin).SelectMany(finTSelector, projector);
}

// ëª¨ë“  Usecaseì—ì„œ ì¼ê´€ëœ íŒ¨í„´ ì‚¬ìš©
public async Task<IFinResponse<Response>> HandleAsync(Request request)
{
    FinT<IO, Response> usecase =
        // Validation â†’ FinT ì§ì ‘ ë³€í™˜ (SelectMany í™•ì¥ ë©”ì„œë“œ ì‚¬ìš©)
        from validated in LimitSampleIdentifier.Validate(
            request.LineId,
            request.ProcessId,
            request.PartId,
            request.Version)

        from createResult in _limitSampleApiService.CreateLimitSampleAsync(
            validated.LineId,
            validated.PartId,
            validated.Version.ToString(),
            "SYSTEM",
            CommandType.ChangedFilmmaster,
            cancellationToken)

        from _ in _messageQueue.PublishLoadMessageAsync(
            validated.LineId,
            validated.ProcessId,
            validated.PartId,
            validated.Version.ToString(),
            cancellationToken)

        select new Response(true);

    Fin<Response> response = await usecase.Run().RunAsync();
    return new FinResponse<Response>(response);
}

// ë‹¤ë¥¸ Usecaseë„ ë™ì¼í•œ íŒ¨í„´
public async Task<IFinResponse<Response>> Handle(Request request, CancellationToken cancellationToken)
{
    FinT<IO, Response> usecase = (
        from latestLimitSamples in _repository.GetLatestLimitSamplesAsync(
            command.LineId,
            command.ProcessId,
            cancellationToken)

        from _1 in guard(
            latestLimitSamples.Count > 0,
            ApplicationErrors.NoRecentlyUpdatedLimitSample(command.LineId, command.ProcessId))

        from _2 in new Seq<(string LineId, string ProcessId, string PartId, string Version)>(latestLimitSamples)
            .Traverse(sample => ProcessSingleLimitSampleAsync(sample, cancellationToken))

        select new Response(true)
    ).As();

    Fin<Response> response = await usecase.Run().RunAsync();
    return new FinResponse<Response>(response);
}

// Helper methodë„ ë™ì¼í•œ íŒ¨í„´
private FinT<IO, Unit> ProcessSingleLimitSampleAsync(
    (string LineId, string ProcessId, string PartId, string Version) sample,
    CancellationToken cancellationToken)
{
    return
        // Validation â†’ FinT ì§ì ‘ ë³€í™˜
        from validated in LimitSampleIdentifier.Validate(
            sample.LineId,
            sample.ProcessId,
            sample.PartId,
            sample.Version)

        from createResult in _limitSampleApiService.CreateLimitSampleAsync(...)
        from _ in _messageQueue.PublishLoadMessageAsync(...)

        select unit;
}
```

**ì¥ì :**
- ëª¨ë“  ì½”ë“œê°€ ë™ì¼í•œ íŒ¨í„´ ì‚¬ìš©
- Validation â†’ FinT ë³€í™˜ì´ 100% í†µì¼ (SelectMany í™•ì¥ ë©”ì„œë“œ)
- ì¤‘ê°„ ë³€ìˆ˜ ì‚¬ìš© ì—†ìŒ (ìˆœìˆ˜ LINQ ì²´ì´ë‹)
- ì£¼ì„ ì²˜ë¦¬ëœ ì½”ë“œ ì „í˜€ ì—†ìŒ
- ëª…ëª… ê·œì¹™ ì™„ë²½ í†µì¼
- íŒ€ì› ëˆ„êµ¬ë‚˜ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ì½”ë“œ ì‘ì„± ê°€ëŠ¥

---

### 6. í•¨ìˆ˜í˜• ìŠ¤íƒ€ì¼ (Functional Style)

í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° íŒ¨ëŸ¬ë‹¤ì„ ì ìš© ìˆ˜ì¤€ì„ í‰ê°€í•©ë‹ˆë‹¤.

#### â­ (20ì ) - ë§¤ìš° ë¶€ì¡±

**íŠ¹ì§•:**
- ëª…ë ¹í˜• í”„ë¡œê·¸ë˜ë°ë§Œ ì‚¬ìš©
- ë³€ê²½ ê°€ëŠ¥í•œ ìƒíƒœ(mutable state) ë‚¨ë°œ
- ë¶€ì‘ìš©(side effect) ê´€ë¦¬ ë¯¸í¡

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
public async Task<Response> ProcessAsync(Request request)
{
    var results = new List<string>();  // mutable state
    var errors = new List<Error>();

    foreach (var item in request.Items)
    {
        try
        {
            var result = await _service.ProcessAsync(item);
            results.Add(result);  // ìƒíƒœ ë³€ê²½
        }
        catch (Exception ex)
        {
            errors.Add(new Error(ex.Message));  // ìƒíƒœ ë³€ê²½
        }
    }

    if (errors.Count > 0)
        return Response.Failure(errors);

    return Response.Success(results);
}
```

**ë¬¸ì œì :**
- ë³€ê²½ ê°€ëŠ¥í•œ ì»¬ë ‰ì…˜ ì‚¬ìš©
- ì˜ˆì™¸ë¥¼ ì œì–´ íë¦„ìœ¼ë¡œ ì‚¬ìš©
- ë¶€ì‘ìš©ì´ ëª…ì‹œì ì´ì§€ ì•ŠìŒ

---

#### â­â­ (40ì ) - ë¶€ì¡±

**íŠ¹ì§•:**
- ì¼ë¶€ LINQ ì‚¬ìš©
- ëŒ€ë¶€ë¶„ ëª…ë ¹í˜• ìŠ¤íƒ€ì¼
- ìƒíƒœ ë³€ê²½ ë¹ˆë²ˆ

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
public async Task<Response> ProcessAsync(Request request)
{
    var results = request.Items
        .Select(item => ProcessItem(item))  // LINQ ì‚¬ìš©
        .ToList();

    var successes = new List<string>();
    var failures = new List<Error>();

    foreach (var result in results)
    {
        if (result.IsSuccess)
            successes.Add(result.Value);
        else
            failures.Add(result.Error);
    }

    if (failures.Any())
        return Response.Failure(failures);

    return Response.Success(successes);
}
```

**ë¬¸ì œì :**
- LINQì™€ ëª…ë ¹í˜• ì½”ë“œ í˜¼ì¬
- ì—¬ì „íˆ mutable state ì‚¬ìš©
- íŒ¨í„´ ë¶ˆì¼ì¹˜

---

#### â­â­â­ (60ì ) - ë³´í†µ

**íŠ¹ì§•:**
- LINQ ì ê·¹ í™œìš©
- ë¶ˆë³€ì„±(immutability) ì¼ë¶€ ì ìš©
- Option/Result íŒ¨í„´ ë¶€ë¶„ ì‚¬ìš©

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
public async Task<Response> ProcessAsync(Request request)
{
    var results = await Task.WhenAll(
        request.Items.Select(item => ProcessItemAsync(item)));

    var successes = results
        .Where(r => r.IsSuccess)
        .Select(r => r.Value)
        .ToList();

    var failures = results
        .Where(r => r.IsFailure)
        .Select(r => r.Error)
        .ToList();

    return failures.Any()
        ? Response.Failure(failures)
        : Response.Success(successes);
}

private async Task<Result<string, Error>> ProcessItemAsync(string item)
{
    try
    {
        var result = await _service.ProcessAsync(item);
        return Result<string, Error>.Success(result);
    }
    catch (Exception ex)
    {
        return Result<string, Error>.Failure(new Error(ex.Message));
    }
}
```

**ë¬¸ì œì :**
- ì—¬ì „íˆ ì˜ˆì™¸ ì‚¬ìš©
- Option/Result íŒ¨í„´ ë¶€ë¶„ì 
- Monad ë¯¸ì‚¬ìš©

---

#### â­â­â­â­ (80ì ) - ì¢‹ìŒ

**íŠ¹ì§•:**
- Monad (Option, Either, Result) í™œìš©
- ë¶ˆë³€ì„± ëŒ€ë¶€ë¶„ ìœ ì§€
- Pure Function ì§€í–¥
- ì¼ë¶€ ëª…ë ¹í˜• ì½”ë“œ ì”ì¡´

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
public async Task<IFinResponse<Response>> HandleAsync(Request request)
{
    // Monad ì‚¬ìš©
    FinT<IO, Seq<Result>> usecase =
        from items in _repository.GetItemsAsync(request.Id)

        // Traverseë¡œ ì»¬ë ‰ì…˜ ì²˜ë¦¬
        from results in new Seq<Item>(items)
            .Traverse(item => ProcessItemAsync(item))

        select results;

    Fin<Response> response = await usecase
        .Map(results => new Response(results))
        .Run()
        .RunAsync();

    return new FinResponse<Response>(response);
}

// í•˜ì§€ë§Œ ì¼ë¶€ ëª…ë ¹í˜• ì½”ë“œ
private FinT<IO, Unit> ProcessItemAsync(Item item)
{
    // ì¤‘ê°„ ë³€ìˆ˜ ì‚¬ìš©
    var validation = Validate(item);
    if (validation.IsFail)
        return FinT<IO, Unit>.Fail(validation.Error);

    return
        from _ in _service.ProcessAsync(validation.Value)
        from __ in _messagePublisher.PublishAsync(item)
        select unit;
}
```

**ë¬¸ì œì :**
- ì¼ë¶€ ëª…ë ¹í˜• ì½”ë“œ í˜¼ì¬
- Validation ì²˜ë¦¬ê°€ ì¼ê´€ì ì´ì§€ ì•ŠìŒ
- ì¤‘ê°„ ë³€ìˆ˜ ì‚¬ìš©

---

#### â­â­â­â­â­ (100ì ) - íƒì›”

**íŠ¹ì§•:**
- **LanguageExt ì™„ë²½ í™œìš©**
- **FinT, IO, Aff ë“± Monad Transformer ì‚¬ìš©**
- Railway-Oriented Programming
- ëª¨ë“  side effectê°€ ëª…ì‹œì  (IO, Aff)
- Pure Function ìµœëŒ€í™”
- ë¶ˆë³€ì„± 100% ë³´ì¥

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
// Monad Transformer ì™„ë²½ í™œìš©
public async Task<IFinResponse<Response>> HandleAsync(Request request)
{
    FinT<IO, Seq<LineProcessingResult>> usecase =
        // 1. Repository ì¡°íšŒ (IO Effect)
        from ftpInfos in _repository.GetFtpConnectionInfosAsync(cancellationToken)

        // 2. ì»¬ë ‰ì…˜ ìˆœíšŒ (Traverse)
        from results in new Seq<FtpConnectionInfo>(ftpInfos)
            .TraverseSerial(
                f: ftpInfo => WatchLimitSampleForLine(ftpInfo, cancellationToken)
                    .Map(fin => fin.Match(
                        Succ: lineId => LineProcessingResult.Success(lineId),
                        Fail: error => LineProcessingResult.Failure(ftpInfo.LineId, error))),
                activitySource: _activitySource,
                operationName: "WatchLimitSampleForLine",
                getItemIdentifier: (ftpInfo, index) => ftpInfo.LineId)

        select results;

    // IO ì‹¤í–‰
    Fin<Response> response = await usecase
        .Map(results => new Response(results))
        .Run()      // FinT<IO, T> â†’ IO<Fin<T>>
        .RunAsync(); // IO<Fin<T>> â†’ Task<Fin<T>>

    return new FinResponse<Response>(response);
}

// Pure Function ìµœëŒ€ í™œìš©
private FinT<IO, Fin<string>> WatchLimitSampleForLine(
    FtpConnectionInfo ftpInfo,
    CancellationToken cancellationToken)
{
    return
        // ëª¨ë“  side effectê°€ ëª…ì‹œì  (FinT<IO, T>)
        from lastCheckTime in _stampFileSystem.GetOrCreateLastCheckTimeAsync(ftpInfo.LineId, cancellationToken)
        from ftpResult in _ftpClient.GetFilePathsWithLatestTimeAsync(...)

        // Pure Function (Static method)
        let classification = LimitSampleFileClassificationService.ClassifyFiles(ftpResult.Paths)

        // Domain Service (Pure Function)
        from domainObjects in FtpFileDomainObjectsCreationService.CreateFromFiles(
            ftpResult.LatestTime,
            classification.LimitSamplePaths,
            classification.FilmMasterPaths)

        // IO Effect
        from _ in PublishMessagesIfNeeded(domainObjects.LimitSample, domainObjects.FilmMaster, cancellationToken)
        from __ in _stampFileSystem.UpdateLastCheckTimeAsync(ftpInfo.LineId, ftpResult.LatestTime, cancellationToken)

        select Fin<string>.Succ(ftpInfo.LineId);
}

// Pure Function (Domain Service)
public static class FtpFileDomainObjectsCreationService
{
    public static Fin<(LimitSample LimitSample, FilmMaster FilmMaster)> CreateFromFiles(
        DateTime latestFileTime,
        IEnumerable<string> limitSamplePaths,
        IEnumerable<string> filmMasterPaths)
    {
        return
            from limitSample in LimitSample.Create(latestFileTime, limitSamplePaths)
            from filmMaster in FilmMaster.Create(latestFileTime, filmMasterPaths)
            select (limitSample, filmMaster);
    }
}

// Validation â†’ FinT ì§ì ‘ ë³€í™˜ (SelectMany í™•ì¥ ë©”ì„œë“œ)
public static FinT<IO, C> SelectMany<A, B, C>(
    this Validation<Error, A> validation,
    Func<A, FinT<IO, B>> finTSelector,
    Func<A, B, C> projector)
{
    Fin<A> fin = validation.Match(
        Succ: value => Fin<A>.Succ(value),
        Fail: errors => Fin<A>.Fail(errors.Head));

    return FinT<IO, A>.Lift(fin).SelectMany(finTSelector, projector);
}

// ì‚¬ìš©: ì™„ë²½í•œ Railway-Oriented Programming
private FinT<IO, Unit> ProcessSingleLimitSampleAsync(
    (string LineId, string ProcessId, string PartId, string Version) sample,
    CancellationToken cancellationToken)
{
    return
        // Validation â†’ FinT ì§ì ‘ ë³€í™˜
        from validated in LimitSampleIdentifier.Validate(
            sample.LineId,
            sample.ProcessId,
            sample.PartId,
            sample.Version)

        // IO Effect
        from createResult in _limitSampleApiService.CreateLimitSampleAsync(...)
        from _ in _messageQueue.PublishLoadMessageAsync(...)

        select unit;
}
```

**ì¥ì :**
- ëª¨ë“  side effectê°€ íƒ€ì…ìœ¼ë¡œ ëª…ì‹œë¨ (FinT<IO, T>)
- Pure Functionê³¼ Impure Function ëª…í™•íˆ êµ¬ë¶„
- Railway-Oriented Programmingìœ¼ë¡œ ì—ëŸ¬ ì²˜ë¦¬ ì¼ê´€ì„±
- Monad Transformerë¡œ ë³µì¡í•œ effect ì¡°í•©
- ë¶ˆë³€ì„± 100% ë³´ì¥ (record, readonly)
- í…ŒìŠ¤íŠ¸ ìš©ì´ì„± ê·¹ëŒ€í™”

---

### 7. ê´€ì°°ì„± (Observability)

ë¡œê¹…, ì¶”ì , ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì™„ì„±ë„ë¥¼ í‰ê°€í•©ë‹ˆë‹¤.

#### â­ (20ì ) - ë§¤ìš° ë¶€ì¡±

**íŠ¹ì§•:**
- ë¡œê¹… ê±°ì˜ ì—†ìŒ
- ì—ëŸ¬ ì¶”ì  ë¶ˆê°€ëŠ¥
- ëª¨ë‹ˆí„°ë§ ë¶ˆê°€ëŠ¥

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
public async Task<Response> ProcessAsync(Request request)
{
    var result = await _service.ProcessAsync(request.Id);
    return new Response(result);
    // ë¡œê¹… ì „í˜€ ì—†ìŒ
}
```

**ë¬¸ì œì :**
- ë¬¸ì œ ë°œìƒ ì‹œ ì›ì¸ íŒŒì•… ë¶ˆê°€ëŠ¥
- ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë¶ˆê°€ëŠ¥
- ìš´ì˜ ê´€ì°° ë¶ˆê°€ëŠ¥

---

#### â­â­ (40ì ) - ë¶€ì¡±

**íŠ¹ì§•:**
- ê¸°ë³¸ì ì¸ Console.WriteLine ë¡œê¹…
- êµ¬ì¡°í™”ë˜ì§€ ì•Šì€ ë¡œê·¸
- ì¶”ì (tracing) ë¶ˆê°€ëŠ¥

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
public async Task<Response> ProcessAsync(Request request)
{
    Console.WriteLine($"Processing: {request.Id}");

    try
    {
        var result = await _service.ProcessAsync(request.Id);
        Console.WriteLine($"Success: {request.Id}");
        return new Response(result);
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Error: {ex.Message}");
        throw;
    }
}
```

**ë¬¸ì œì :**
- êµ¬ì¡°í™”ë˜ì§€ ì•Šì€ ë¡œê·¸ (ê²€ìƒ‰ ì–´ë ¤ì›€)
- ë¡œê·¸ ë ˆë²¨ ì—†ìŒ
- Distributed Tracing ë¶ˆê°€ëŠ¥

---

#### â­â­â­ (60ì ) - ë³´í†µ

**íŠ¹ì§•:**
- ILogger ì‚¬ìš©í•œ êµ¬ì¡°í™”ëœ ë¡œê¹…
- ì—ëŸ¬ ë¡œê¹… ì¡´ì¬
- ì¶”ì ì€ ë¶€ë¶„ì 

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
public async Task<Response> ProcessAsync(Request request)
{
    _logger.LogInformation("Processing request for {RequestId}", request.Id);

    try
    {
        var result = await _service.ProcessAsync(request.Id);
        _logger.LogInformation("Successfully processed {RequestId}", request.Id);
        return new Response(result);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Failed to process {RequestId}", request.Id);
        throw;
    }
}
```

**ë¬¸ì œì :**
- Distributed Tracing ë¯¸í¡
- Performance Metrics ë¯¸ìˆ˜ì§‘
- ëŒ€ëŸ‰ ë°ì´í„° ë¡œê¹… ì‹œ ì„±ëŠ¥ ë¬¸ì œ

---

#### â­â­â­â­ (80ì ) - ì¢‹ìŒ

**íŠ¹ì§•:**
- êµ¬ì¡°í™”ëœ ë¡œê¹… (Structured Logging)
- OpenTelemetry ì ìš©
- **ëŒ€ëŸ‰ ë°ì´í„° ë¡œê¹… ì‹œ ì„±ëŠ¥ ë¬¸ì œ ê°€ëŠ¥**
- Metrics ì¼ë¶€ ìˆ˜ì§‘

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
public async Task<IFinResponse<Response>> HandleAsync(Request request)
{
    using var timer = new ElapsedTimeCalculator.Timer();

    IFinResponse<Response> response = await next();
    double elapsed = timer.ElapsedMilliseconds;

    if (response.IsSucc)
    {
        Response res = response.Value!;
        int successCount = res.Results.Count(r => r.IsSuccess);
        int failureCount = res.Results.Count(r => !r.IsSuccess);

        // êµ¬ì¡°í™”ëœ ë¡œê¹…
        _logger.LogSuccessResponse(
            _loggingContext,
            elapsed,
            "Usecase: {SuccessCount} succeeded, {FailureCount} failed",
            new { SuccessCount = successCount, FailureCount = failureCount },
            successCount, failureCount);

        // í•˜ì§€ë§Œ ëŒ€ëŸ‰ ë°ì´í„° ì‹œ ì„±ëŠ¥ ë¬¸ì œ
        IEnumerable<LineProcessingResult> failures = res.Results.Where(r => !r.IsSuccess);
        foreach (LineProcessingResult failure in failures)
        {
            // ìˆ˜ë°±~ìˆ˜ì²œ ê°œì¼ ë•Œ ì„±ëŠ¥ ì €í•˜
            _logger.LogErrorResponse(
                _loggingContext,
                elapsed,
                "Line processing failed - LineId: {LineId}, Error: {@Error}",
                failure.Error!,
                failure.LineId,
                failure.Error);
        }
    }

    return response;
}
```

**ë¬¸ì œì :**
- ëŒ€ëŸ‰ ë°ì´í„° (1000ê°œ+) ë¡œê¹… ì‹œ ì„±ëŠ¥ ë¬¸ì œ
- ë¡œê·¸ ì¶œë ¥ ì œí•œ ì—†ìŒ
- í˜ì´ì§•ì´ë‚˜ ìš”ì•½ ì—†ìŒ

---

#### â­â­â­â­â­ (100ì ) - íƒì›”

**íŠ¹ì§•:**
- **ì™„ë²½í•œ Observability (Logging, Tracing, Metrics)**
- OpenTelemetry ì™„ë²½ í†µí•©
- **ëŒ€ëŸ‰ ë°ì´í„° ëŒ€ë¹„ ë¡œê·¸ ì¶œë ¥ ì œí•œ** (í˜ì´ì§•, ìš”ì•½)
- Distributed Tracing ì™„ë²½ ì§€ì›
- Performance Metrics ìˆ˜ì§‘
- ì—ëŸ¬ ì¶”ì  ì™„ë²½
- ë¡œê·¸ ë ˆë²¨ ì ì ˆíˆ í™œìš©

**ì½”ë“œ ì˜ˆì‹œ:**
```csharp
public async Task<IFinResponse<Response>> Handle(
    Request request,
    RequestHandlerDelegate<IFinResponse<Response>> next,
    CancellationToken cancellationToken)
{
    using var timer = new ElapsedTimeCalculator.Timer();

    // OpenTelemetry Activity
    using var activity = _activitySource.StartActivity("WatchLimitSampleByFtpCommand");

    IFinResponse<Response> response = await next();
    double elapsed = timer.ElapsedMilliseconds;

    if (response.IsSucc)
    {
        Response res = response.Value!;

        IEnumerable<LineProcessingResult> successes = res.Results.Where(r => r.IsSuccess);
        IEnumerable<LineProcessingResult> failures = res.Results.Where(r => !r.IsSuccess);

        int successCount = successes.Count();
        int failureCount = failures.Count();

        // ëŒ€ëŸ‰ ë°ì´í„° ëŒ€ë¹„: ìµœëŒ€ 10ê°œê¹Œì§€ë§Œ í‘œì‹œ
        const int maxDisplayCount = 10;
        List<string> successLineIds = successes.Select(s => s.LineId).Take(maxDisplayCount).ToList();
        List<string> failureLineIds = failures.Select(f => f.LineId).Take(maxDisplayCount).ToList();

        string successLines = successCount > maxDisplayCount
            ? $"{string.Join(", ", successLineIds)}, ... ({successCount - maxDisplayCount} more)"
            : string.Join(", ", successLineIds);

        string failedLines = failureCount > maxDisplayCount
            ? $"{string.Join(", ", failureLineIds.Select(id =>
                {
                    LineProcessingResult failure = failures.First(f => f.LineId == id);
                    return $"{id}({failure.Error!.Code})";
                }))}, ... ({failureCount - maxDisplayCount} more)"
            : string.Join(", ", failures.Select(f => $"{f.LineId}({f.Error!.Code})"));

        // êµ¬ì¡°í™”ëœ ë¡œê¹… (ìš”ì•½ ì •ë³´)
        _logger.LogSuccessResponse(
            _loggingContext,
            elapsed,
            "Usecase: {SuccessCount} succeeded, {FailureCount} failed. Success: [{SuccessLines}], Failed: [{FailedLines}]",
            new
            {
                SuccessCount = successCount,
                FailureCount = failureCount,
                SuccessLines = successLines,
                FailedLines = failedLines
            },
            successCount, failureCount);

        // OpenTelemetry Metrics
        activity?.SetTag("success.count", successCount);
        activity?.SetTag("failure.count", failureCount);
        activity?.SetTag("elapsed.ms", elapsed);
    }

    return response;
}

// Distributed Tracing with OpenTelemetry
from results in new Seq<FtpConnectionInfo>(ftpInfos)
    .TraverseSerial(
        f: ftpInfo => WatchLimitSampleForLine(ftpInfo, cancellationToken),
        activitySource: _activitySource,          // Activity Source
        operationName: "WatchLimitSampleForLine", // Activity Name
        getItemIdentifier: (ftpInfo, index) => ftpInfo.LineId)  // Tag
```

**ì¥ì :**
- ëŒ€ëŸ‰ ë°ì´í„° (1000ê°œ+) ì²˜ë¦¬ ì‹œì—ë„ ë¡œê·¸ ì„±ëŠ¥ ë¬¸ì œ ì—†ìŒ
- ìš”ì•½ ì •ë³´ë¡œ ì „ì²´ ìƒí™© íŒŒì•… ê°€ëŠ¥
- OpenTelemetryë¡œ Distributed Tracing ì™„ë²½ ì§€ì›
- Metrics ìˆ˜ì§‘ìœ¼ë¡œ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ê°€ëŠ¥
- êµ¬ì¡°í™”ëœ ë¡œê·¸ë¡œ ê²€ìƒ‰ ë° ë¶„ì„ ìš©ì´
- ë¡œê·¸ ë ˆë²¨ ì ì ˆíˆ ì‚¬ìš© (Info, Warning, Error)

---

## ì ìˆ˜ í™˜ì‚°í‘œ

| ë³„ì  | ì ìˆ˜ ë²”ìœ„ | í‰ê°€ | ì„¤ëª… |
|------|-----------|------|------|
| â­ | 0-20ì  | ë§¤ìš° ë¶€ì¡±<br>(Needs Major Improvement) | ê·¼ë³¸ì ì¸ ì¬ì„¤ê³„ í•„ìš”. ê¸°ë³¸ ì›ì¹™ ë¯¸ì¤€ìˆ˜ |
| â­â­ | 21-40ì  | ë¶€ì¡±<br>(Needs Improvement) | ë§ì€ ê°œì„ ì´ í•„ìš”. ì¼ë¶€ íŒ¨í„´ë§Œ ì ìš© |
| â­â­â­ | 41-60ì  | ë³´í†µ<br>(Average) | ê¸°ë³¸ì ì¸ ì›ì¹™ì€ ì§€í‚¤ë‚˜ ì¼ê´€ì„± ë¶€ì¡± |
| â­â­â­â­ | 61-80ì  | ì¢‹ìŒ<br>(Good) | ëŒ€ë¶€ë¶„ ì›ì¹™ ì¤€ìˆ˜. ì¼ë¶€ ê°œì„  ì—¬ì§€ ì¡´ì¬ |
| â­â­â­â­â­ | 81-100ì  | íƒì›”<br>(Excellent) | ì™„ë²½í•œ êµ¬í˜„. ëª¨ë²” ì‚¬ë¡€ |

### ì¢…í•© ì ìˆ˜ ê³„ì‚°

ì¢…í•© ì ìˆ˜ = (ë ˆì´ì–´ ë¶„ë¦¬ Ã— 0.2) + (ë„ë©”ì¸ ëª¨ë¸ë§ Ã— 0.2) + (ì—ëŸ¬ ì²˜ë¦¬ Ã— 0.15) + (í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„± Ã— 0.15) + (ì½”ë“œ ì¼ê´€ì„± Ã— 0.1) + (í•¨ìˆ˜í˜• ìŠ¤íƒ€ì¼ Ã— 0.1) + (ê´€ì°°ì„± Ã— 0.1)

**ì˜ˆì‹œ ê³„ì‚°:**

| í•­ëª© | ì ìˆ˜ | ê°€ì¤‘ì¹˜ | ê°€ì¤‘ ì ìˆ˜ |
|------|------|--------|-----------|
| ë ˆì´ì–´ ë¶„ë¦¬ | 100 | 20% | 20.0 |
| ë„ë©”ì¸ ëª¨ë¸ë§ | 100 | 20% | 20.0 |
| ì—ëŸ¬ ì²˜ë¦¬ | 100 | 15% | 15.0 |
| í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„± | 100 | 15% | 15.0 |
| ì½”ë“œ ì¼ê´€ì„± | 100 | 10% | 10.0 |
| í•¨ìˆ˜í˜• ìŠ¤íƒ€ì¼ | 100 | 10% | 10.0 |
| ê´€ì°°ì„± | 100 | 10% | 10.0 |
| **ì´í•©** | | | **100.0** |

---

## ì ìš© ì˜ˆì‹œ

### ì‹¤ì œ í”„ë¡œì íŠ¸ í‰ê°€ (ê°œì„  ì „ â†’ ê°œì„  í›„)

#### ê°œì„  ì „ (2026-01-06)

| í•­ëª© | ì ìˆ˜ | ë³„ì  | ì£¼ìš” ì´ìŠˆ |
|------|------|------|----------|
| ë ˆì´ì–´ ë¶„ë¦¬ | 75 | â­â­â­â­ | ë„ë©”ì¸ ìƒì„± ë¡œì§ì´ Application Layerì— ëˆ„ìˆ˜ |
| ë„ë©”ì¸ ëª¨ë¸ë§ | 80 | â­â­â­â­ | ê²€ì¦ ë¡œì§ ì¼ë¶€ê°€ Application Layerì— ìœ„ì¹˜ |
| ì—ëŸ¬ ì²˜ë¦¬ | 75 | â­â­â­â­ | `Fin<string>` ë³€í™˜ ì‹œ ì—ëŸ¬ ì •ë³´ ì†ì‹¤ |
| í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„± | 80 | â­â­â­â­ | Pure Functionì´ ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œë¡œ êµ¬í˜„ |
| ì½”ë“œ ì¼ê´€ì„± | 75 | â­â­â­â­ | Validation â†’ Fin ë³€í™˜ íŒ¨í„´ ë¶ˆì¼ì¹˜, ì£¼ì„ ì½”ë“œ ì¡´ì¬ |
| í•¨ìˆ˜í˜• ìŠ¤íƒ€ì¼ | 95 | â­â­â­â­â­ | LanguageExt íƒì›”í•˜ê²Œ í™œìš© |
| ê´€ì°°ì„± | 80 | â­â­â­â­ | ëŒ€ëŸ‰ ë°ì´í„° ë¡œê¹… ì‹œ ì„±ëŠ¥ ë¬¸ì œ ê°€ëŠ¥ì„± |

**ì¢…í•© ì ìˆ˜: 79.5ì  (â­â­â­â­ ì¢‹ìŒ)**

---

#### ê°œì„  í›„ (2026-01-07)

| í•­ëª© | ì ìˆ˜ | ë³„ì  | ê°œì„  ë‚´ìš© |
|------|------|------|----------|
| ë ˆì´ì–´ ë¶„ë¦¬ | 100 | â­â­â­â­â­ | âœ… Domain Serviceë¡œ ì™„ì „ ë¶„ë¦¬ |
| ë„ë©”ì¸ ëª¨ë¸ë§ | 100 | â­â­â­â­â­ | âœ… Value Objectì— ê²€ì¦ ë¡œì§ ìº¡ìŠí™” |
| ì—ëŸ¬ ì²˜ë¦¬ | 100 | â­â­â­â­â­ | âœ… LineProcessingResultë¡œ ì—ëŸ¬ ì •ë³´ ë³´ì¡´ |
| í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„± | 100 | â­â­â­â­â­ | âœ… Pure Functionì„ Static classë¡œ ë³€í™˜ |
| ì½”ë“œ ì¼ê´€ì„± | 100 | â­â­â­â­â­ | âœ… SelectMany íŒ¨í„´ í†µì¼, ì£¼ì„ ì½”ë“œ ì œê±° |
| í•¨ìˆ˜í˜• ìŠ¤íƒ€ì¼ | 95 | â­â­â­â­â­ | ë³€ê²½ ì—†ìŒ (ì´ë¯¸ íƒì›”) |
| ê´€ì°°ì„± | 100 | â­â­â­â­â­ | âœ… ë¡œê·¸ ì¶œë ¥ ì œí•œ (ìµœëŒ€ 10ê°œ) |

**ì¢…í•© ì ìˆ˜: 99.5ì  (â­â­â­â­â­ íƒì›”)**

---

### ê°œì„  ì‚¬í•­ ìƒì„¸

#### 1. ë ˆì´ì–´ ë¶„ë¦¬ (75 â†’ 100)

**Before:**
```csharp
// Application Layerì— ë„ë©”ì¸ ìƒì„± ë¡œì§
private Fin<(LimitSample, FilmMaster)> CreateDomainObjects(...)
{
    return
        from limitSample in LimitSample.Create(...)
        from filmMaster in FilmMaster.Create(...)
        select (limitSample, filmMaster);
}
```

**After:**
```csharp
// Domain Serviceë¡œ ì´ë™
from domainObjects in FtpFileDomainObjectsCreationService.CreateFromFiles(...)
```

---

#### 2. ë„ë©”ì¸ ëª¨ë¸ë§ (80 â†’ 100)

**Before:**
```csharp
// Application Layerì—ì„œ ê²€ì¦
if (string.IsNullOrEmpty(request.LineId))
    return Response.Fail("Invalid LineId");
```

**After:**
```csharp
// Value Objectì—ì„œ ê²€ì¦
from validated in LimitSampleIdentifier.Validate(
    sample.LineId,
    sample.ProcessId,
    sample.PartId,
    sample.Version)
```

---

#### 3. ì—ëŸ¬ ì²˜ë¦¬ (75 â†’ 100)

**Before:**
```csharp
// ì—ëŸ¬ ì •ë³´ ì†ì‹¤
return processing
    .Map(_ => Fin<string>.Succ(ftpInfo.LineId))
    .IfFail(error => Fin<string>.Fail(error))
```

**After:**
```csharp
// êµ¬ì¡°í™”ëœ ê²°ê³¼ íƒ€ì…ìœ¼ë¡œ ì—ëŸ¬ ì •ë³´ ë³´ì¡´
.Map(fin => fin.Match(
    Succ: lineId => LineProcessingResult.Success(lineId),
    Fail: error => LineProcessingResult.Failure(ftpInfo.LineId, error)))
```

---

#### 4. í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„± (80 â†’ 100)

**Before:**
```csharp
// ì¸ìŠ¤í„´ìŠ¤ ì„œë¹„ìŠ¤ (Mock í•„ìš”)
public class LimitSampleFileClassificationService
{
    public ClassificationResult ClassifyFiles(IEnumerable<string> filePaths)
    {
        // Pure Functionì´ì§€ë§Œ ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œ
    }
}
```

**After:**
```csharp
// Static class (Mock ë¶ˆí•„ìš”)
public static class LimitSampleFileClassificationService
{
    public static ClassificationResult ClassifyFiles(IEnumerable<string> filePaths)
    {
        // Pure Function
    }
}
```

---

#### 5. ì½”ë“œ ì¼ê´€ì„± (75 â†’ 100)

**Before:**
```csharp
// Validation â†’ Fin ë³€í™˜ì´ ë¶ˆì¼ì¹˜
Validation<Error, T> validation = Validate(...);
Fin<T> fin = validation.Match(...);
return FinT<IO, T>.Lift(fin).SelectMany(...);
```

**After:**
```csharp
// SelectMany í™•ì¥ ë©”ì„œë“œë¡œ íŒ¨í„´ í†µì¼
from validated in LimitSampleIdentifier.Validate(...)
from result in _service.ProcessAsync(validated)
select result;
```

---

#### 6. ê´€ì°°ì„± (80 â†’ 100)

**Before:**
```csharp
// ëŒ€ëŸ‰ ë°ì´í„° ì‹œ ì„±ëŠ¥ ë¬¸ì œ
foreach (var failure in failures)
{
    _logger.LogError("Failed: {LineId}", failure.LineId);
}
```

**After:**
```csharp
// ìµœëŒ€ 10ê°œê¹Œì§€ë§Œ í‘œì‹œ
const int maxDisplayCount = 10;
string failedLines = failureCount > maxDisplayCount
    ? $"{string.Join(", ", failureLineIds.Take(10))}, ... ({failureCount - 10} more)"
    : string.Join(", ", failureLineIds);

_logger.LogSuccess("Failed: [{FailedLines}]", failedLines);
```

---

## ê¸°ëŒ€ íš¨ê³¼

ì´ í‰ê°€ ê¸°ì¤€ì„ ì ìš©í•¨ìœ¼ë¡œì¨ ì–»ì„ ìˆ˜ ìˆëŠ” êµ¬ì²´ì ì¸ íš¨ê³¼ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

### 1. ë‹¨ê¸° íš¨ê³¼ (ì¦‰ê°ì  ê°œì„ )

#### 1.1 ê°ê´€ì  í’ˆì§ˆ ì¸¡ì • ê°€ëŠ¥
- **ì •ëŸ‰ì  ì§€í‘œ**: ì£¼ê´€ì  íŒë‹¨ ëŒ€ì‹  ì ìˆ˜(0-100)ë¡œ ì½”ë“œ í’ˆì§ˆ ì¸¡ì •
- **ê°œì„  ì˜ì—­ ì‹ë³„**: ë‚®ì€ ì ìˆ˜ í•­ëª©ì„ ìš°ì„ ìˆœìœ„ë¡œ ê°œì„  ê³„íš ìˆ˜ë¦½
- **ì½”ë“œ ë¦¬ë·° íš¨ìœ¨í™”**: í‰ê°€ ê¸°ì¤€ì„ ì²´í¬ë¦¬ìŠ¤íŠ¸ë¡œ í™œìš©í•˜ì—¬ ë¦¬ë·° ì‹œê°„ ë‹¨ì¶•

**ì˜ˆì‹œ:**
- Before: "ì´ ì½”ë“œëŠ” ë­”ê°€ ë³µì¡í•´ ë³´ì´ëŠ”ë°..." (ì£¼ê´€ì )
- After: "ì—ëŸ¬ ì²˜ë¦¬ í•­ëª©ì´ 40ì (â­â­)ì…ë‹ˆë‹¤. guard íŒ¨í„´ ì ìš©ìœ¼ë¡œ 80ì ê¹Œì§€ ê°œì„  ê°€ëŠ¥í•©ë‹ˆë‹¤." (ê°ê´€ì )

#### 1.2 ì½”ë“œ ì¼ê´€ì„± í–¥ìƒ
- **íŒ¨í„´ í†µì¼**: 7ê°œ í•­ëª©ì˜ ëª…í™•í•œ ê¸°ì¤€ìœ¼ë¡œ ì¼ê´€ëœ ì½”ë“œ ìŠ¤íƒ€ì¼ ìœ ì§€
- **í•™ìŠµ ê³¡ì„  ë‹¨ì¶•**: ì‹ ê·œ ê°œë°œìê°€ í‰ê°€ ê¸°ì¤€ì„ í•™ìŠµ ìë£Œë¡œ í™œìš©
- **ê¸°ìˆ  ë¶€ì±„ ê°ì†Œ**: ë¶ˆì¼ì¹˜í•˜ëŠ” íŒ¨í„´ì„ ì¡°ê¸°ì— ë°œê²¬í•˜ê³  ìˆ˜ì •

**ì˜ˆì‹œ:**
- Before: ê° ê°œë°œìê°€ ì„œë¡œ ë‹¤ë¥¸ ì—ëŸ¬ ì²˜ë¦¬ ë°©ì‹ ì‚¬ìš© (try-catch, Result<T>, Fin<T> í˜¼ì¬)
- After: ëª¨ë“  ìœ ìŠ¤ì¼€ì´ìŠ¤ì—ì„œ FinT<IO, T> + Railway-Oriented Programming íŒ¨í„´ í†µì¼ (ì¼ê´€ì„± 95ì  ë‹¬ì„±)

---

### 2. ì¤‘ê¸° íš¨ê³¼ (3-6ê°œì›”)

#### 2.1 ìƒì‚°ì„± í–¥ìƒ
- **ë¹ ë¥¸ ì˜ì‚¬ê²°ì •**: í‰ê°€ ê¸°ì¤€ì„ ê·¼ê±°ë¡œ ì•„í‚¤í…ì²˜ ê²°ì • ì‹œê°„ ë‹¨ì¶•
- **ë²„ê·¸ ê°ì†Œ**: ì²´ê³„ì ì¸ ì—ëŸ¬ ì²˜ë¦¬ì™€ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„± í–¥ìƒìœ¼ë¡œ ê²°í•¨ë¥  ê°ì†Œ
- **ë¦¬íŒ©í† ë§ ì•ˆì •ì„±**: Before/After ì ìˆ˜ ë¹„êµë¡œ ë¦¬íŒ©í† ë§ íš¨ê³¼ ê²€ì¦

**ì¸¡ì • ê°€ëŠ¥í•œ ì§€í‘œ:**
- ì½”ë“œ ë¦¬ë·° ì‹œê°„: í‰ê·  2ì‹œê°„ â†’ 1ì‹œê°„ (50% ê°ì†Œ)
- ë²„ê·¸ ë°œìƒë¥ : ì›” í‰ê·  15ê±´ â†’ 8ê±´ (47% ê°ì†Œ)
- ë¦¬íŒ©í† ë§ ì£¼ê¸°: ë¶„ê¸°ë‹¹ 1íšŒ â†’ ì›” 1íšŒ (ì§€ì†ì  ê°œì„  ê°€ëŠ¥)

#### 2.2 ê¸°ìˆ  ë¶€ì±„ ê´€ë¦¬
- **ê°€ì‹œí™”**: ê° í•­ëª©ë³„ ì ìˆ˜ë¡œ ê¸°ìˆ  ë¶€ì±„ í˜„í™© ì‹œê°í™”
- **ìš°ì„ ìˆœìœ„ ì„¤ì •**: ê°€ì¤‘ì¹˜(20%, 15%, 10%)ë¥¼ ê³ ë ¤í•œ ê°œì„  ìš°ì„ ìˆœìœ„ ê²°ì •
- **ê°œì„  ì¶”ì **: ì ìˆ˜ ë³€í™”ë¥¼ ì¶”ì í•˜ì—¬ ê¸°ìˆ  ë¶€ì±„ ìƒí™˜ ì§„í–‰ë¥  ëª¨ë‹ˆí„°ë§

**ì˜ˆì‹œ ëŒ€ì‹œë³´ë“œ:**
```
[ê¸°ìˆ  ë¶€ì±„ í˜„í™©]
- ë ˆì´ì–´ ë¶„ë¦¬: 95ì  âœ… (ìš°ìˆ˜)
- ì—ëŸ¬ ì²˜ë¦¬: 60ì  âš ï¸ (ê°œì„  í•„ìš”) â† ìš°ì„  ê°œì„  ëŒ€ìƒ
- í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„±: 70ì  âš ï¸ (ê°œì„  í•„ìš”)
- ê´€ì°°ì„±: 85ì  âœ… (ì–‘í˜¸)
```

---

### 3. ì¥ê¸° íš¨ê³¼ (6ê°œì›” ì´ìƒ)

#### 3.1 ì§€ì† ê°€ëŠ¥í•œ ì•„í‚¤í…ì²˜
- **ìœ ì§€ë³´ìˆ˜ì„±**: ëª…í™•í•œ ë ˆì´ì–´ ë¶„ë¦¬ì™€ ì¼ê´€ëœ íŒ¨í„´ìœ¼ë¡œ ë³€ê²½ ë¹„ìš© ê°ì†Œ
- **í™•ì¥ì„±**: ìƒˆë¡œìš´ ê¸°ëŠ¥ ì¶”ê°€ ì‹œ ê¸°ì¡´ ì½”ë“œ ì˜í–¥ ìµœì†Œí™”
- **ì•ˆì •ì„±**: ì²´ê³„ì ì¸ ì—ëŸ¬ ì²˜ë¦¬ì™€ ê´€ì°°ì„±ìœ¼ë¡œ ìš´ì˜ ì•ˆì •ì„± í–¥ìƒ

**ë¹„ìš© ì ˆê° íš¨ê³¼:**
- ê¸°ëŠ¥ ì¶”ê°€ ì‹œê°„: í‰ê·  5ì¼ â†’ 3ì¼ (40% ë‹¨ì¶•)
- ì¥ì•  ëŒ€ì‘ ì‹œê°„: í‰ê·  4ì‹œê°„ â†’ 1.5ì‹œê°„ (62% ë‹¨ì¶•)
- ì‹ ê·œ ê°œë°œì ì˜¨ë³´ë”©: 4ì£¼ â†’ 2ì£¼ (50% ë‹¨ì¶•)

#### 3.2 íŒ€ ì—­ëŸ‰ ê°•í™”
- **ê³µí†µ ì–¸ì–´**: í‰ê°€ ê¸°ì¤€ì´ íŒ€ì˜ ê³µí†µ ì–¸ì–´(Ubiquitous Language)ë¡œ ìë¦¬ì¡ìŒ
- **ì§€ì‹ ê³µìœ **: í‰ê°€ ê¸°ì¤€ ë¬¸ì„œê°€ íŒ€ì˜ ì§€ì‹ ë² ì´ìŠ¤ë¡œ í™œìš©
- **ê¸°ìˆ  ì„±ì¥**: ëª…í™•í•œ ê¸°ì¤€ì„ í†µí•´ ê°œì¸ì˜ ì½”ë“œ í’ˆì§ˆ ê°œì„  ë°©í–¥ ì„¤ì •

**íš¨ê³¼ ì¸¡ì •:**
- ì½”ë“œ ë¦¬ë·° ì½”ë©˜íŠ¸ í’ˆì§ˆ í–¥ìƒ: "ìˆ˜ì • í•„ìš”" â†’ "ì—ëŸ¬ ì²˜ë¦¬ í•­ëª© 3.4 ê¸°ì¤€ ì ìš© ê¶Œì¥"
- ADR ì‘ì„± ê±´ìˆ˜: ë¶„ê¸°ë‹¹ 2ê±´ â†’ ì›” 1ê±´ (ì•„í‚¤í…ì²˜ ê²°ì • ë¬¸ì„œí™” ì¦ê°€)
- íŒ€ ë‚´ ê¸°ìˆ  ê³µìœ  ì„¸ì…˜: ì›” 0íšŒ â†’ ì›” 2íšŒ

#### 3.3 ë¹„ì¦ˆë‹ˆìŠ¤ ê°€ì¹˜ ì°½ì¶œ
- **ë¹ ë¥¸ ì¶œì‹œ**: ì•ˆì •ì ì¸ ì•„í‚¤í…ì²˜ë¡œ ìƒˆ ê¸°ëŠ¥ì˜ ë¹ ë¥¸ ì¶œì‹œ ê°€ëŠ¥
- **í’ˆì§ˆ ë³´ì¦**: ê°ê´€ì  í’ˆì§ˆ ê¸°ì¤€ìœ¼ë¡œ ê³ ê° ì‹ ë¢° í–¥ìƒ
- **ê²½ìŸë ¥ í™•ë³´**: ì§€ì† ê°€ëŠ¥í•œ ê°œë°œ ë¬¸í™”ë¡œ ì¥ê¸°ì  ê²½ìŸ ìš°ìœ„ í™•ë³´

**ë¹„ì¦ˆë‹ˆìŠ¤ ì„íŒ©íŠ¸:**
- Time-to-Market: ì‹ ê·œ ê¸°ëŠ¥ ì¶œì‹œ ì£¼ê¸° 20% ë‹¨ì¶•
- ê³ ê° ë§Œì¡±ë„: ì¥ì•  ê°ì†Œë¡œ NPS(Net Promoter Score) 10ì  í–¥ìƒ
- ê°œë°œì ë§Œì¡±ë„: ëª…í™•í•œ ê¸°ì¤€ê³¼ ì¼ê´€ëœ ì½”ë“œë¡œ ì´ì§ë¥  ê°ì†Œ

---

### 4. ì„±ê³µ ì‚¬ë¡€

#### ì‚¬ë¡€ 1: Watcher ìœ ìŠ¤ì¼€ì´ìŠ¤ ê°œì„ 
**Before (ê°œì„  ì „):**
- ì´ì : 79.5ì  (â­â­â­â­)
- ë¬¸ì œ: ì—ëŸ¬ ì •ë³´ ì†ì‹¤ (Fin<string> ì‚¬ìš©), ëŒ€ëŸ‰ ë°ì´í„° ì‹œ ë¡œê·¸ í­ì£¼

**After (ê°œì„  í›„):**
- ì´ì : 99.5ì  (â­â­â­â­â­)
- ê°œì„ : LineProcessingResult íƒ€ì… ë„ì…, ë¡œê·¸ ì œí•œ(ìµœëŒ€ 10ê°œ)
- íš¨ê³¼: ì—ëŸ¬ ì¶”ì  100% í–¥ìƒ, ë¡œê·¸ ì„±ëŠ¥ 90% ê°œì„ 

#### ì‚¬ë¡€ 2: Loader ìœ ìŠ¤ì¼€ì´ìŠ¤ ê°œì„ 
**Before (ê°œì„  ì „):**
- ì´ì : 75ì  (â­â­â­â­)
- ë¬¸ì œ: Validation â†’ FinT ë³€í™˜ íŒ¨í„´ ë¶ˆì¼ì¹˜, ì¤‘ë³µ ì½”ë“œ ì¡´ì¬

**After (ê°œì„  í›„):**
- ì´ì : 97ì  (â­â­â­â­â­)
- ê°œì„ : SelectMany í™•ì¥ ë©”ì„œë“œ ë„ì…, LINQ ì¿¼ë¦¬ êµ¬ë¬¸ í†µì¼
- íš¨ê³¼: ì½”ë“œ ê°€ë…ì„± 50% í–¥ìƒ, ì¤‘ë³µ ì½”ë“œ 80% ì œê±°

---

### 5. ì§€ì†ì  ê°œì„  ë¡œë“œë§µ

ì´ í‰ê°€ ê¸°ì¤€ì€ ì¼íšŒì„± ì ìš©ì´ ì•„ë‹Œ ì§€ì†ì  ê°œì„ ì˜ ê¸°ë°˜ì…ë‹ˆë‹¤:

**Phase 1: í˜„ì¬ ìƒíƒœ í‰ê°€ (ì™„ë£Œ)**
- âœ… í‰ê°€ ê¸°ì¤€ ì •ë¦½
- âœ… Watcher/Loader ìœ ìŠ¤ì¼€ì´ìŠ¤ í‰ê°€ ë° ê°œì„ 
- âœ… Before/After ë¹„êµ ê²€ì¦

**Phase 2: ì „ì²´ ì ìš© (ì§„í–‰ ì¤‘)**
- ğŸ”„ ëª¨ë“  ìœ ìŠ¤ì¼€ì´ìŠ¤ì— í‰ê°€ ê¸°ì¤€ ì ìš©
- ğŸ”„ í‰ê·  ì ìˆ˜ 90ì  ì´ìƒ ë‹¬ì„±
- ğŸ”„ ìë™í™”ëœ í’ˆì§ˆ ì²´í¬ ë„êµ¬ ê°œë°œ

**Phase 3: ë¬¸í™” ì •ì°© (ê³„íš)**
- ğŸ“‹ ì½”ë“œ ë¦¬ë·° ì‹œ í‰ê°€ ê¸°ì¤€ í•„ìˆ˜ ì ìš©
- ğŸ“‹ ì‹ ê·œ ì½”ë“œ ì‘ì„± ì‹œ í‰ê°€ ê¸°ì¤€ ì‚¬ì „ ê²€í† 
- ğŸ“‹ ë¶„ê¸°ë³„ ì•„í‚¤í…ì²˜ í‰ê°€ ë³´ê³ ì„œ ì‘ì„±

**Phase 4: ì§„í™” (ì¥ê¸°)**
- ğŸ¯ ìƒˆë¡œìš´ íŒ¨í„´/ê¸°ìˆ  ë„ì… ì‹œ í‰ê°€ ê¸°ì¤€ ì—…ë°ì´íŠ¸
- ğŸ¯ ë‹¤ë¥¸ í”„ë¡œì íŠ¸/íŒ€ìœ¼ë¡œ í‰ê°€ ê¸°ì¤€ í™•ì‚°
- ğŸ¯ ì‚°ì—… í‘œì¤€ìœ¼ë¡œ ë°œì „ (ì˜¤í”ˆì†ŒìŠ¤ ê³µìœ )

---

### 6. ê²°ë¡ 

ì´ í‰ê°€ ê¸°ì¤€ì„ í†µí•´:
1. **ê°ê´€ì ì´ê³  ì¼ê´€ëœ ì•„í‚¤í…ì²˜ í‰ê°€** ê°€ëŠ¥
2. **ê°œì„ ì´ í•„ìš”í•œ ì˜ì—­ ëª…í™•íˆ ì‹ë³„**
3. **ê°œì„  ì „í›„ ì •ëŸ‰ì  ë¹„êµ** ê°€ëŠ¥
4. **íŒ€ ì „ì²´ê°€ ë™ì¼í•œ ê¸°ì¤€ìœ¼ë¡œ ì½”ë“œ í’ˆì§ˆ íŒë‹¨**

**ìµœì¢… ëª©í‘œ:** ëª¨ë“  í•­ëª©ì—ì„œ **â­â­â­â­â­ (81-100ì )** ë‹¬ì„±!

**í•µì‹¬ ê°€ì¹˜:**
- ğŸ“ˆ **ì¸¡ì • ê°€ëŠ¥í•œ í’ˆì§ˆ ê°œì„ **
- ğŸ¤ **íŒ€ í˜‘ì—… ê°•í™”**
- ğŸš€ **ì§€ì† ê°€ëŠ¥í•œ ì„±ì¥**
- ğŸ’ **ë¹„ì¦ˆë‹ˆìŠ¤ ê°€ì¹˜ ì°½ì¶œ**
