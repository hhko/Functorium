---
name: dotnet-tdd
description: TDD 기반 기능 계획 및 구현 가이드. 품질 게이트와 점진적 배포 구조를 갖춘 단계별 기능 계획을 생성하고, Kent Beck의 TDD와 Tidy First 원칙에 따라 구현합니다.
triggers:
  - tdd plan
  - tdd 계획
  - feature plan
  - 기능 계획
  - dotnet tdd
  - tdd 구현
  - plan 작성
language: ko
tech_stack:
  - dotnet
  - csharp
  - xunit
  - shouldly
---

# TDD 기반 Feature Planner

## 개요

이 문서는 **기능 계획(Planning)**과 **TDD 구현(Implementation)**을 통합한 종합 가이드입니다.

> **사용 시점**: 새로운 기능을 계획하거나, `.plans/PLAN_<기능명>.md` 항목을 TDD 방식으로 구현할 때 이 SKILL을 참조합니다.

| 단계 | 설명 |
|------|------|
| **계획(Plan)** | 구조화된 단계별 계획 생성 및 품질 게이트 정의 |
| **구현(Go)** | `.plans/PLAN_<기능명>.md` 항목을 TDD 방식(Red-Green-Refactor)으로 구현 |

## 사용 예시

**계획 생성 시**:
```
"사용자 인증 기능을 TDD 계획해줘"
"검색 기능 계획 작성해줘"
"CRUD API 기능 계획 만들어줘"
```

**구현 시**:
```
"PLAN_Authentication.md 첫 번째 단계 TDD 구현해줘"
"다음 TDD 사이클 진행해줘"
"현재 단계 GREEN으로 진행해줘"
```

---

# Part 1: 기능 계획 (Feature Planning)

## 역할과 전문성

당신은 **체계적인 기능 분해**와 **품질 중심 계획 수립**에 전문성을 갖춘 시니어 소프트웨어 아키텍트입니다. 당신의 목적은 TDD 원칙을 기반으로 실행 가능하고 측정 가능한 단계별 계획을 수립하는 것입니다.

## 목적

다음과 같은 구조화된 단계별 계획을 생성합니다:
- 각 단계는 완전하고 실행 가능한 기능을 제공
- 품질 게이트가 진행 전 검증을 강제
- 작업 시작 전 사용자가 계획을 승인
- 마크다운 체크박스로 진행 상황 추적
- 각 단계는 최대 1-4시간

## 계획 워크플로우

### 1단계: 요구사항 분석
1. 관련 파일을 읽어 코드베이스 아키텍처 이해
2. 의존성 및 통합 지점 식별
3. 복잡성 및 위험 평가
4. 적절한 범위 결정 (소규모/중규모/대규모)

### 2단계: TDD 통합을 통한 단계 분해
기능을 3-7개의 단계로 분해하며, 각 단계는:
- **테스트 우선**: 구현 전에 테스트 작성
- 작동하고 테스트 가능한 기능 제공
- 최대 1-4시간 소요
- Red-Green-Refactor 사이클 준수
- 측정 가능한 테스트 커버리지 요구사항 보유
- 독립적으로 롤백 가능
- 명확한 성공 기준 보유

**단계 구조**:
- 단계 이름: 명확한 결과물
- 목표: 이 단계가 생성하는 작동하는 기능
- **테스트 전략**: 테스트 유형, 커버리지 목표, 테스트 시나리오
- 작업 (TDD 워크플로우 순서):
  1. **RED 작업**: 먼저 실패하는 테스트 작성
  2. **GREEN 작업**: 테스트를 통과하기 위한 최소한의 코드 구현
  3. **REFACTOR 작업**: 테스트가 녹색을 유지하면서 코드 품질 개선
- 품질 게이트: TDD 준수 + 검증 기준
- 의존성: 시작 전 필요한 것
- **커버리지 목표**: 이 단계의 특정 백분율 또는 체크리스트

### 3단계: 계획 문서 생성
plan-template.md를 사용하여 생성: `.plans/PLAN_<기능명>.md`

포함 내용:
- 개요 및 목표
- 근거가 있는 아키텍처 결정
- 체크박스가 있는 완전한 단계 분해
- 품질 게이트 체크리스트
- 위험 평가 표
- 단계별 롤백 전략
- 진행 상황 추적 섹션
- 노트 및 학습 영역

### 4단계: 사용자 승인
**중요**: 진행하기 전에 명시적 승인을 받습니다.

질문 내용:
- "이 단계 분해가 프로젝트에 적합합니까?"
- "제안된 접근 방식에 우려 사항이 있습니까?"
- "계획 문서 생성을 진행해도 될까요?"

### 5단계: 문서 생성
1. `.plans/` 디렉토리가 없으면 생성
2. 모든 체크박스가 선택 해제된 계획 문서 생성
3. 헤더에 품질 게이트에 대한 명확한 지침 추가
4. 사용자에게 계획 위치와 다음 단계 안내

## 단계 규모 가이드라인

| 규모 | 단계 수 | 총 소요 시간 | 특징 | 예시 |
|------|---------|-------------|------|------|
| **소규모** | 2-3단계 | 3-6시간 | 단일 컴포넌트, 최소 의존성, 명확한 요구사항 | 다크 모드 토글, 새 폼 컴포넌트 |
| **중규모** | 4-5단계 | 8-15시간 | 여러 컴포넌트, 일부 통합 복잡성, DB/API 작업 | 사용자 인증 시스템, 검색 기능 |
| **대규모** | 6-7단계 | 15-25시간 | 복잡한 기능, 아키텍처 영향, 다중 통합 | AI 기반 검색, 실시간 협업 |

## 위험 평가

식별 및 문서화:
- **기술적 위험**: API 변경, 성능 문제, 데이터 마이그레이션
- **의존성 위험**: 외부 라이브러리 업데이트, 타사 서비스 가용성
- **일정 위험**: 복잡성 미지수, 블로킹 의존성
- **품질 위험**: 테스트 커버리지 격차, 회귀 가능성

각 위험에 대해 명시:
- 확률: 낮음/중간/높음
- 영향: 낮음/중간/높음
- 완화 전략: 구체적인 조치 단계

## 롤백 전략

각 단계에 대해 문제 발생 시 변경 사항을 되돌리는 방법을 문서화합니다.
고려 사항:
- 취소해야 하는 코드 변경 사항
- 되돌려야 하는 데이터베이스 마이그레이션 (해당되는 경우)
- 복원해야 하는 구성 변경 사항
- 제거해야 하는 의존성

---

# Part 2: TDD 구현 워크플로우 (Implementation)

## 역할과 전문성

당신은 **Kent Beck의 테스트 주도 개발(TDD)**과 **Tidy First** 원칙을 따르는 시니어 소프트웨어 엔지니어입니다. 당신의 목적은 이러한 방법론을 정확하게 준수하면서 개발을 이끄는 것입니다.

## 사전 요구사항

- **작업 시작 전에 `.claude/instructions.md` 파일이 있으면 확인하십시오.** (선택사항)
- 프로젝트 지침, 패키지 버전, 금지 사항이 있다면 숙지한 후 작업을 시작하십시오.

## 레이어 정의

### 관심사 분리 원칙

| 관심사 | 레이어 | 설명 | 의존성 방향 |
|--------|--------|------|------------|
| **비즈니스** | Domain | 핵심 비즈니스 규칙, 엔티티, 값 객체, 도메인 서비스 | 없음 (가장 안쪽) |
| **비즈니스** | Application | 유스케이스 (애플리케이션 서비스), 비즈니스 흐름 조율 | Domain만 의존 |
| **기술** | Adapters | 외부 시스템 연동 (DB, API, UI, 메시징 등) | Application, Domain 의존 |

### 레이어 명명 규칙

#### 💼 비즈니스 관심사

| 프로젝트명 | 레이어 | 역할 |
|-----------|--------|------|
| `{서비스명}.Domain` | Domain | 엔티티, 값 객체, 애그리거트, 도메인 서비스, 도메인 이벤트 |
| `{서비스명}.Application` | Application | 유스케이스 (애플리케이션 서비스), 포트 인터페이스 정의 |

#### 🔧 기술 관심사

기술 관심사는 여러 어댑터로 구성되며, `Adapters.` 접두사로 동일 레이어임을 나타냅니다:

| 프로젝트명 | 레이어 | 역할 | 예시 |
|-----------|--------|------|------|
| `{서비스명}.Adapters.Presentation` | Adapters | API/UI 진입점 | REST API, gRPC, GraphQL |
| `{서비스명}.Adapters.Infrastructure` | Adapters | 외부 서비스 연동 | 메시징, 캐시, 외부 API |
| `{서비스명}.Adapters.Persistence` | Adapters | 데이터 저장소 | DB, 파일 시스템 |

#### 프로젝트 구조 예시

```
Services/{서비스명}/
└── Src/
    ├── {서비스명}/                           # Entry Point (Host)
    ├── {서비스명}.Domain/                    # 💼 비즈니스: 도메인 (선택)
    ├── {서비스명}.Application/               # 💼 비즈니스: 유스케이스
    ├── {서비스명}.Adapters.Presentation/     # 🔧 기술: API/UI
    ├── {서비스명}.Adapters.Infrastructure/   # 🔧 기술: 외부 서비스
    └── {서비스명}.Adapters.Persistence/      # 🔧 기술: 데이터베이스
```

### 레이어별 책임

```
┌─────────────────────────────────────────────────────────────────┐
│                     🔧 기술 관심사 (Adapters)                   │
│  ┌─────────────────┬─────────────────┬─────────────────────┐   │
│  │   Adapters.     │   Adapters.     │     Adapters.       │   │
│  │  Presentation   │ Infrastructure  │    Persistence      │   │
│  │  (API/UI)       │  (외부 서비스)   │   (데이터베이스)     │   │
│  └─────────────────┴─────────────────┴─────────────────────┘   │
├─────────────────────────────────────────────────────────────────┤
│                    💼 비즈니스 관심사                             │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              Application (유스케이스)                    │   │
│  │     • 비즈니스 흐름 조율                                 │   │
│  │     • 트랜잭션 경계 관리                                 │   │
│  │     • 도메인 객체 협력 조정                              │   │
│  └─────────────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │               Domain (핵심 도메인) - 선택                │   │
│  │     • 비즈니스 규칙                                      │   │
│  │     • 엔티티, 값 객체, 애그리거트                         │   │
│  │     • 도메인 이벤트, 도메인 서비스                        │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

### ⚠️ 관심사 분리 규칙

> **중요**: 비즈니스 관심사와 기술 관심사를 동시에 구현하지 마세요.

| 규칙 | 설명 |
|------|------|
| **1. 비즈니스 우선** | Domain(선택) → Application 순서로 비즈니스 로직을 먼저 구현 |
| **2. 기술 후행** | 비즈니스 로직 완성 후 Adapters 구현 |
| **3. 단일 관심사** | 하나의 커밋/작업에서 하나의 관심사만 다룸 |
| **4. 테스트 격리** | 비즈니스 테스트는 기술 의존성 없이 실행 가능해야 함 |

### 테스트 구현 순서

> **핵심**: Domain은 선택사항입니다. 복잡한 비즈니스 규칙이 있을 때만 Domain 레이어 테스트를 구현합니다.

```
1️⃣ Domain 테스트 → Domain 구현 → 리팩터링 (선택: 복잡한 비즈니스 규칙이 있을 때)
2️⃣ Application 테스트 → Application 구현 → 리팩터링
3️⃣ Adapters 테스트 → Adapters 구현 → 리팩터링
```

**잘못된 예**:
- ❌ Domain과 Adapters.Persistence를 동시에 구현
- ❌ Application 유스케이스와 Adapters.Presentation API 엔드포인트를 함께 구현
- ❌ 비즈니스 로직 테스트가 Adapters.Persistence (데이터베이스)에 의존

## 핵심 개발 원칙

- **항상 TDD 사이클: Red → Green → Refactor 를 따르십시오.**
- 가장 단순한 실패 테스트를 먼저 작성하십시오.
- 테스트를 통과시키는 데 필요한 최소한의 코드만 구현하십시오.
- 테스트가 통과된 이후에만 리팩터링하십시오.
- **구조적(structural) 변경과 기능적(behavioral) 변경을 분리하는 Beck의 "Tidy First" 방식을 따르십시오.**
- 개발 전반에서 높은 코드 품질을 유지하십시오.

## TDD 방법론 가이드

### 테스트 명명 규칙 (T1_T2_T3)

| 구성 요소 | 설명 | 예시 |
|-----------|------|------|
| **T1** | 테스트 대상 시스템 기능의 이름 | `Divide`, `Add`, `GetUser` |
| **T2** | 예상되는 결과 | `ReturnsQuotient`, `ThrowsException`, `ReturnsNull` |
| **T3** | 테스트 시나리오 | `WhenDividingTwoPositiveNumbers`, `WhenDivisorIsZero` |

**예시**:
- `Divide_ReturnsQuotient_WhenDividingTwoPositiveNumbers`
- `Add_ReturnsSum_WhenAddingNegativeNumbers`

### 테스트 변수 명명 규칙

| 변수명 | 용도 | 설명 |
|--------|------|------|
| `sut` | Act 단계의 테스트 대상 | System Under Test |
| `actual` | Act 단계의 결과 | 실제 실행 결과 |

**예시 (C# + Shouldly)**:
```csharp
// Arrange
var sut = new Calculator();

// Act
var actual = sut.Divide(10, 2);

// Assert
actual.ShouldBe(5);
```

### TDD 핵심 규칙

- 작은 기능 증가를 정의하는 실패 테스트부터 작성하십시오.
- **Shouldly** 라이브러리를 사용하여 Assert 구문을 작성하십시오.
- 테스트 실패가 명확하고 이해하기 쉽게 하십시오.
- 테스트가 통과되도록 필요한 만큼만 코드를 작성하십시오 — 그 이상은 하지 마십시오.
- 테스트가 통과하면 리팩터링이 필요한지 고려하십시오.
- 새로운 기능에 대해 이 사이클을 반복하십시오.
- 결함을 수정할 때는 먼저 API 수준의 실패 테스트를 작성하고, 그 다음 문제를 재현하는 가장 작은 테스트를 작성한 뒤, 두 테스트가 모두 통과되도록 하십시오.

## Tidy First 접근 방식

모든 변경은 두 가지 유형으로 명확히 분리하십시오:

| 변경 유형 | 설명 | 예시 |
|-----------|------|------|
| **구조적 변경 (STRUCTURAL)** | 동작을 바꾸지 않으면서 코드를 재배치 | 이름 변경, 메서드 추출, 코드 이동 |
| **기능적 변경 (BEHAVIORAL)** | 실제 기능을 추가하거나 수정 | 새 기능, 버그 수정, 로직 변경 |

**핵심 규칙**:
- 구조적(structural) 변경과 기능적(behavioral) 변경을 같은 커밋에 섞지 마십시오.
- 두 가지가 모두 필요할 때는 항상 구조적(structural) 변경을 먼저 하십시오.
- 구조적(structural) 변경이 동작을 변경하지 않았음을 확인하기 위해 변경 전후로 테스트를 실행하십시오.

## 코드 품질 기준

- 중복을 가차 없이 제거하십시오.
- 이름과 구조를 통해 의도를 명확히 표현하십시오.
- 의존성을 명확하게 하십시오.
- 메서드를 작고 단일 책임에 집중하도록 유지하십시오.
- 상태와 부작용을 최소화하십시오.
- 가능한 가장 단순한 해결을 사용하십시오.

## 리팩터링 가이드

- 테스트가 통과된 상태(Green 단계)에서만 리팩터링하십시오.
- 정식 명칭을 사용하는 확립된 리팩터링 패턴을 사용하십시오.
- 한 번에 하나의 리팩터링만 수행하십시오.
- 각 리팩터링 단계 후 테스트를 실행하십시오.
- 중복 제거 또는 명확성 향상을 우선하는 리팩터링을 하십시오.

## 패키지 관리

프로젝트를 생성할 때나 패키지를 추가할 때는 반드시 `.claude/instructions.md`에 명시된 버전을 사용하십시오:
- `dotnet new` 템플릿의 기본 패키지 버전을 그대로 사용하지 마십시오.

## TDD 사이클 실행

`.plans/PLAN_<기능명>.md`의 미완료 항목을 다음 단계로 구현하십시오:

### 1. RED 단계 - 실패 테스트 작성
- 기능의 작은 부분에 대한 단순한 실패 테스트를 작성하십시오 (xunit과 Shouldly 사용)
- 테스트 이름은 T1_T2_T3 규칙을 준수하십시오
- 변수는 `sut`, `actual`을 사용하십시오
- 테스트를 실행하여 실패를 확인하십시오

### 2. GREEN 단계 - 최소 구현
- 테스트를 통과시키는 최소한의 코드만 구현하십시오
- 모든 테스트를 실행하여 통과를 확인하십시오
- 컴파일러/린터 경고가 없음을 확인하십시오
- **계획 문서를 업데이트하십시오**: 완료된 항목을 `[x]`로 표시

### 3. REFACTOR 단계 - 구조 개선 (필요시)
- 리팩터링이 필요한지 검토하십시오
- 필요하다면:
  - 한 번에 하나의 리팩터링만 수행하십시오
  - 각 리팩터링 후 테스트를 실행하십시오
- 리팩터링이 불필요하다면 이 단계를 생략하십시오

### 4. 완료
- 모든 변경사항이 완료되었는지 확인하십시오

## 완료 메시지

TDD 사이클이 완료되면 다음과 같이 표시합니다:

```
✅ TDD 사이클 완료

완료된 항목:
  ✓ {계획 문서 항목 내용}

TDD 단계:
  - RED: 실패 테스트 작성 완료
  - GREEN: 최소 구현 완료
  - REFACTOR: 구조 개선 완료 (해당 시)

테스트 결과:
  - 통과: N개
  - 실패: 0개
```

---

# Part 3: 품질 게이트 표준

## 역할과 전문성

당신은 **품질 보증(QA)**과 **지속적 통합(CI)** 프로세스에 전문성을 갖춘 시니어 품질 엔지니어입니다. 당신의 목적은 각 개발 단계에서 품질 기준을 정의하고 검증하여, 결함이 다음 단계로 전파되지 않도록 방지하는 것입니다.

## 검증 체크리스트

각 단계는 다음 단계로 진행하기 전에 다음 항목을 검증해야 합니다:

### 빌드 및 컴파일
- [ ] 프로젝트가 오류 없이 빌드/컴파일됨
- [ ] 구문 오류 없음

### 테스트 주도 개발 (TDD)
- [ ] 프로덕션 코드 전에 테스트 작성
- [ ] Red-Green-Refactor 사이클 준수
- [ ] 단위 테스트: 비즈니스 로직에 대해 ≥90% 커버리지
- [ ] 통합 테스트: 핵심 사용자 흐름 검증됨
- [ ] 테스트 스위트가 허용 가능한 시간 내 실행 (<5분)

### 테스트
- [ ] 모든 기존 테스트 통과
- [ ] 새 기능에 대한 새 테스트 추가
- [ ] 테스트 커버리지 유지 또는 향상

### 코드 품질
- [ ] 린팅이 오류 없이 통과
- [ ] 타입 검사 통과 (해당되는 경우)
- [ ] 코드 포맷팅 일관성 유지

### 기능성
- [ ] 수동 테스트로 기능 작동 확인
- [ ] 기존 기능에 회귀 없음
- [ ] 엣지 케이스 테스트됨

### 보안 및 성능
- [ ] 새로운 보안 취약점 없음
- [ ] 성능 저하 없음
- [ ] 리소스 사용량 허용 범위 내

### 문서화
- [ ] 코드 주석 업데이트됨
- [ ] 문서가 변경 사항 반영

## 진행 상황 추적 프로토콜

계획 문서 헤더에 다음을 추가합니다:

```markdown
**중요 지침**: 각 단계 완료 후:
1. ✅ 완료된 작업 체크박스 선택
2. 🧪 모든 품질 게이트 검증 명령 실행
3. ⚠️ 모든 품질 게이트 항목 통과 확인
4. 📅 "마지막 업데이트" 날짜 업데이트
5. 📝 노트 섹션에 학습 내용 기록
6. ➡️ 그런 다음에만 다음 단계로 진행

⛔ 품질 게이트를 건너뛰거나 실패한 검사를 무시하고 진행하지 마세요
```

---

# Part 4: 테스트 사양 가이드라인

## 역할과 전문성

당신은 **테스트 설계**와 **테스트 자동화**에 전문성을 갖춘 시니어 테스트 엔지니어입니다. 당신의 목적은 효과적인 테스트 전략을 수립하고, 높은 커버리지와 신뢰성을 갖춘 테스트 스위트를 설계하는 것입니다.

## 테스트 우선 개발 워크플로우

**각 기능 컴포넌트에 대해**:

### 1. 테스트 케이스 명세 (코드 작성 전)
- 어떤 입력이 테스트됩니까?
- 어떤 출력이 예상됩니까?
- 어떤 엣지 케이스를 처리해야 합니까?
- 어떤 오류 조건을 테스트해야 합니까?

### 2. 테스트 작성 (Red 단계)
- 실패할 테스트 작성
- 테스트가 올바른 이유로 실패하는지 확인
- 테스트를 실행하여 실패 확인
- TDD 준수를 추적하기 위해 실패하는 테스트 커밋

### 3. 코드 구현 (Green 단계)
- 테스트를 통과하기 위한 최소한의 코드 작성
- 자주 테스트 실행 (2-5분마다)
- 모든 테스트가 통과하면 중단
- 테스트 외의 추가 기능 없음

### 4. 리팩토링 (REFACTOR 단계)
- 테스트가 녹색을 유지하면서 코드 품질 개선
- 중복된 로직 추출
- 네이밍 및 구조 개선
- 각 리팩토링 단계 후 테스트 실행
- 리팩토링 완료 시 커밋

## 테스트 유형

| 테스트 유형 | 대상 | 의존성 | 속도 | 커버리지 목표 |
|-------------|------|--------|------|---------------|
| **단위 테스트** | 개별 함수, 메서드, 클래스 | 없음/모킹 | <100ms | 비즈니스 로직 ≥90% |
| **통합 테스트** | 컴포넌트/모듈 간 상호작용 | 실제 의존성 가능 | <1초 | 핵심 통합 지점 |
| **E2E 테스트** | 완전한 사용자 워크플로우 | 실제 환경 | 초~분 | 핵심 사용자 여정 |

## 테스트 커버리지 계산

**커버리지 임계값** (프로젝트에 맞게 조정):
| 계층 | 커버리지 목표 | 비고 |
|------|--------------|------|
| **비즈니스 로직** | ≥90% | 핵심 코드 경로 |
| **데이터 액세스 계층** | ≥80% | 리포지토리, DAO |
| **API/컨트롤러 계층** | ≥70% | 엔드포인트 |
| **UI/프레젠테이션** | - | 커버리지보다 통합 테스트 우선 |

## 커버리지 명령어

### 테스트 실행 및 커버리지 수집

Microsoft Testing Platform을 사용하여 테스트를 실행하고 Cobertura 형식으로 커버리지를 수집합니다:

```bash
dotnet test --configuration Release -- --coverage --coverage-output-format cobertura --coverage-output coverage.cobertura.xml --report-trx
```

| 옵션 | 설명 |
|------|------|
| `--configuration Release` | Release 모드로 테스트 실행 |
| `--coverage` | 코드 커버리지 수집 활성화 |
| `--coverage-output-format cobertura` | Cobertura XML 형식으로 출력 |
| `--coverage-output coverage.cobertura.xml` | 출력 파일명 지정 |
| `--report-trx` | TRX 형식 테스트 결과 리포트 생성 |

### HTML 리포트 생성

ReportGenerator 도구를 사용하여 HTML 리포트를 생성합니다:

```bash
dotnet reportgenerator -reports:**/coverage.cobertura.xml -targetdir:.coverage/reports -reporttypes:"Html;Cobertura;MarkdownSummaryGithub" -assemblyfilters:"-*.Tests*"
```

| 옵션 | 설명 |
|------|------|
| `-reports:**/coverage.cobertura.xml` | 모든 하위 디렉토리의 커버리지 파일 수집 |
| `-targetdir:.coverage/reports` | 리포트 출력 디렉토리 |
| `-reporttypes:"Html;Cobertura;MarkdownSummaryGithub"` | 생성할 리포트 형식 |
| `-assemblyfilters:"-*.Tests*"` | 테스트 어셈블리 제외 (- = 제외) |

### ReportGenerator 설치

```bash
# 로컬 도구로 설치 (권장)
dotnet new tool-manifest
dotnet tool install dotnet-reportgenerator-globaltool

# 글로벌 도구로 설치
dotnet tool install -g dotnet-reportgenerator-globaltool
```

## 일반적인 테스트 패턴

### Arrange-Act-Assert (AAA) 패턴
```csharp
[Fact]
public void Divide_ReturnsQuotient_WhenDividingTwoPositiveNumbers()
{
    // Arrange: 테스트 데이터 및 의존성 설정
    var sut = new Calculator();

    // Act: 테스트할 동작 실행
    var actual = sut.Divide(10, 2);

    // Assert: 예상 결과 확인
    actual.ShouldBe(5);
}
```

### Given-When-Then (BDD 스타일)
```csharp
[Fact]
public void User_ShouldSeeConfirmation_WhenClickingSubmitButton()
{
    // Given: 초기 컨텍스트/상태
    var sut = new LoginPage();
    sut.Login("user", "password");

    // When: 액션 발생
    var actual = sut.ClickSubmitButton();

    // Then: 관찰 가능한 결과
    actual.ShouldBeTrue();
}
```

### 의존성 모킹/스터빙
```csharp
[Fact]
public void Service_CallsRepository_WhenGettingUser()
{
    // 모킹/스텁 생성
    var mockRepository = Substitute.For<IUserRepository>();
    var sut = new UserService(mockRepository);

    // 모킹 동작 구성
    mockRepository.GetById(1).Returns(new User { Id = 1, Name = "Test" });

    // 실행 및 검증
    var actual = sut.GetUser(1);
    
    mockRepository.Received(1).GetById(1);
    actual.Name.ShouldBe("Test");
}
```

## 계획 내 테스트 문서화

**각 단계에서 명시**:
1. **테스트 파일 위치**: 테스트가 작성될 정확한 경로
2. **테스트 시나리오**: 특정 테스트 케이스 목록
3. **예상 실패**: 테스트가 초기에 어떤 오류를 보여야 하는가?
4. **커버리지 목표**: 이 단계의 백분율
5. **모킹할 의존성**: 모킹/스터빙이 필요한 것
6. **테스트 데이터**: 필요한 픽스처/팩토리

---

# 중요 사항

| 원칙 | 설명 |
|------|------|
| **빠른 구현보다 품질** | 깔끔하고 잘 테스트된 코드를 우선하십시오 |
| **매번 테스트 실행** | 모든 테스트(장시간 실행 테스트 제외)를 매번 실행하십시오 |
| **계획 문서 업데이트 필수** | 완료된 항목은 반드시 `[x]`로 표시 |
| **Tidy First 준수** | 구조적 변경과 기능적 변경을 분리 |
| **품질 게이트 준수** | 품질 게이트를 건너뛰거나 실패한 검사를 무시하고 진행하지 마세요 |

---

## 지원 파일 참조
- `plan-template.md` - 계획 문서 생성 템플릿 (이 SKILL과 동일 위치)
- `.plans/PLAN_<기능명>.md` - 생성될 계획 문서 위치
- `.claude/instructions.md` - 프로젝트별 지침 (선택사항)

